// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace protocol {
class Account;
class AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class AccountThreshold;
class AccountThresholdDefaultTypeInternal;
extern AccountThresholdDefaultTypeInternal _AccountThreshold_default_instance_;
class Asset;
class AssetDefaultTypeInternal;
extern AssetDefaultTypeInternal _Asset_default_instance_;
class AssetProperty;
class AssetPropertyDefaultTypeInternal;
extern AssetPropertyDefaultTypeInternal _AssetProperty_default_instance_;
class ChainHello;
class ChainHelloDefaultTypeInternal;
extern ChainHelloDefaultTypeInternal _ChainHello_default_instance_;
class ChainPeerMessage;
class ChainPeerMessageDefaultTypeInternal;
extern ChainPeerMessageDefaultTypeInternal _ChainPeerMessage_default_instance_;
class ChainPeerOffline;
class ChainPeerOfflineDefaultTypeInternal;
extern ChainPeerOfflineDefaultTypeInternal _ChainPeerOffline_default_instance_;
class ChainPeerOnline;
class ChainPeerOnlineDefaultTypeInternal;
extern ChainPeerOnlineDefaultTypeInternal _ChainPeerOnline_default_instance_;
class ChainStatus;
class ChainStatusDefaultTypeInternal;
extern ChainStatusDefaultTypeInternal _ChainStatus_default_instance_;
class ChainTxStatus;
class ChainTxStatusDefaultTypeInternal;
extern ChainTxStatusDefaultTypeInternal _ChainTxStatus_default_instance_;
class CloseTimeRange;
class CloseTimeRangeDefaultTypeInternal;
extern CloseTimeRangeDefaultTypeInternal _CloseTimeRange_default_instance_;
class Detail;
class DetailDefaultTypeInternal;
extern DetailDefaultTypeInternal _Detail_default_instance_;
class DontHave;
class DontHaveDefaultTypeInternal;
extern DontHaveDefaultTypeInternal _DontHave_default_instance_;
class EntryList;
class EntryListDefaultTypeInternal;
extern EntryListDefaultTypeInternal _EntryList_default_instance_;
class GetLedgers;
class GetLedgersDefaultTypeInternal;
extern GetLedgersDefaultTypeInternal _GetLedgers_default_instance_;
class GetQuorumset;
class GetQuorumsetDefaultTypeInternal;
extern GetQuorumsetDefaultTypeInternal _GetQuorumset_default_instance_;
class GetTxHashSet;
class GetTxHashSetDefaultTypeInternal;
extern GetTxHashSetDefaultTypeInternal _GetTxHashSet_default_instance_;
class GetTxSet;
class GetTxSetDefaultTypeInternal;
extern GetTxSetDefaultTypeInternal _GetTxSet_default_instance_;
class Hash;
class HashDefaultTypeInternal;
extern HashDefaultTypeInternal _Hash_default_instance_;
class Hello;
class HelloDefaultTypeInternal;
extern HelloDefaultTypeInternal _Hello_default_instance_;
class Input;
class InputDefaultTypeInternal;
extern InputDefaultTypeInternal _Input_default_instance_;
class KeepOnline;
class KeepOnlineDefaultTypeInternal;
extern KeepOnlineDefaultTypeInternal _KeepOnline_default_instance_;
class KeepOnlineEnv;
class KeepOnlineEnvDefaultTypeInternal;
extern KeepOnlineEnvDefaultTypeInternal _KeepOnlineEnv_default_instance_;
class Ledger;
class LedgerDefaultTypeInternal;
extern LedgerDefaultTypeInternal _Ledger_default_instance_;
class LedgerHeader;
class LedgerHeaderDefaultTypeInternal;
extern LedgerHeaderDefaultTypeInternal _LedgerHeader_default_instance_;
class LedgerUpgrade;
class LedgerUpgradeDefaultTypeInternal;
extern LedgerUpgradeDefaultTypeInternal _LedgerUpgrade_default_instance_;
class Ledgers;
class LedgersDefaultTypeInternal;
extern LedgersDefaultTypeInternal _Ledgers_default_instance_;
class Operation;
class OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class OperationCreateAccount;
class OperationCreateAccountDefaultTypeInternal;
extern OperationCreateAccountDefaultTypeInternal _OperationCreateAccount_default_instance_;
class OperationInitPayment;
class OperationInitPaymentDefaultTypeInternal;
extern OperationInitPaymentDefaultTypeInternal _OperationInitPayment_default_instance_;
class OperationIssueAsset;
class OperationIssueAssetDefaultTypeInternal;
extern OperationIssueAssetDefaultTypeInternal _OperationIssueAsset_default_instance_;
class OperationIssueUniqueAsset;
class OperationIssueUniqueAssetDefaultTypeInternal;
extern OperationIssueUniqueAssetDefaultTypeInternal _OperationIssueUniqueAsset_default_instance_;
class OperationManageOrder;
class OperationManageOrderDefaultTypeInternal;
extern OperationManageOrderDefaultTypeInternal _OperationManageOrder_default_instance_;
class OperationPayment;
class OperationPaymentDefaultTypeInternal;
extern OperationPaymentDefaultTypeInternal _OperationPayment_default_instance_;
class OperationPaymentUniqueAsset;
class OperationPaymentUniqueAssetDefaultTypeInternal;
extern OperationPaymentUniqueAssetDefaultTypeInternal _OperationPaymentUniqueAsset_default_instance_;
class OperationProduction;
class OperationProductionDefaultTypeInternal;
extern OperationProductionDefaultTypeInternal _OperationProduction_default_instance_;
class OperationRecord;
class OperationRecordDefaultTypeInternal;
extern OperationRecordDefaultTypeInternal _OperationRecord_default_instance_;
class OperationSetOptions;
class OperationSetOptionsDefaultTypeInternal;
extern OperationSetOptionsDefaultTypeInternal _OperationSetOptions_default_instance_;
class Output;
class OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class PayLoad;
class PayLoadDefaultTypeInternal;
extern PayLoadDefaultTypeInternal _PayLoad_default_instance_;
class PayLoadEnv;
class PayLoadEnvDefaultTypeInternal;
extern PayLoadEnvDefaultTypeInternal _PayLoadEnv_default_instance_;
class Pbft;
class PbftDefaultTypeInternal;
extern PbftDefaultTypeInternal _Pbft_default_instance_;
class PbftCheckPoint;
class PbftCheckPointDefaultTypeInternal;
extern PbftCheckPointDefaultTypeInternal _PbftCheckPoint_default_instance_;
class PbftCommit;
class PbftCommitDefaultTypeInternal;
extern PbftCommitDefaultTypeInternal _PbftCommit_default_instance_;
class PbftEnv;
class PbftEnvDefaultTypeInternal;
extern PbftEnvDefaultTypeInternal _PbftEnv_default_instance_;
class PbftNewView;
class PbftNewViewDefaultTypeInternal;
extern PbftNewViewDefaultTypeInternal _PbftNewView_default_instance_;
class PbftPrePrepare;
class PbftPrePrepareDefaultTypeInternal;
extern PbftPrePrepareDefaultTypeInternal _PbftPrePrepare_default_instance_;
class PbftPrepare;
class PbftPrepareDefaultTypeInternal;
extern PbftPrepareDefaultTypeInternal _PbftPrepare_default_instance_;
class PbftPreparedSet;
class PbftPreparedSetDefaultTypeInternal;
extern PbftPreparedSetDefaultTypeInternal _PbftPreparedSet_default_instance_;
class PbftViewChange;
class PbftViewChangeDefaultTypeInternal;
extern PbftViewChangeDefaultTypeInternal _PbftViewChange_default_instance_;
class Peer;
class PeerDefaultTypeInternal;
extern PeerDefaultTypeInternal _Peer_default_instance_;
class Peers;
class PeersDefaultTypeInternal;
extern PeersDefaultTypeInternal _Peers_default_instance_;
class Ping;
class PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class Pong;
class PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class Signature;
class SignatureDefaultTypeInternal;
extern SignatureDefaultTypeInternal _Signature_default_instance_;
class Signer;
class SignerDefaultTypeInternal;
extern SignerDefaultTypeInternal _Signer_default_instance_;
class SlaveVerifyRequest;
class SlaveVerifyRequestDefaultTypeInternal;
extern SlaveVerifyRequestDefaultTypeInternal _SlaveVerifyRequest_default_instance_;
class SlaveVerifyResponse;
class SlaveVerifyResponseDefaultTypeInternal;
extern SlaveVerifyResponseDefaultTypeInternal _SlaveVerifyResponse_default_instance_;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransactionEnv;
class TransactionEnvDefaultTypeInternal;
extern TransactionEnvDefaultTypeInternal _TransactionEnv_default_instance_;
class TransactionEnvStore;
class TransactionEnvStoreDefaultTypeInternal;
extern TransactionEnvStoreDefaultTypeInternal _TransactionEnvStore_default_instance_;
class TransactionEnvWrapper;
class TransactionEnvWrapperDefaultTypeInternal;
extern TransactionEnvWrapperDefaultTypeInternal _TransactionEnvWrapper_default_instance_;
class TxHashSet;
class TxHashSetDefaultTypeInternal;
extern TxHashSetDefaultTypeInternal _TxHashSet_default_instance_;
class TxSet;
class TxSetDefaultTypeInternal;
extern TxSetDefaultTypeInternal _TxSet_default_instance_;
class UniqueAsset;
class UniqueAssetDefaultTypeInternal;
extern UniqueAssetDefaultTypeInternal _UniqueAsset_default_instance_;
class UpgradeRequest;
class UpgradeRequestDefaultTypeInternal;
extern UpgradeRequestDefaultTypeInternal _UpgradeRequest_default_instance_;
class UpgradeRequestEnv;
class UpgradeRequestEnvDefaultTypeInternal;
extern UpgradeRequestEnvDefaultTypeInternal _UpgradeRequestEnv_default_instance_;
class Value;
class ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class WsMessage;
class WsMessageDefaultTypeInternal;
extern WsMessageDefaultTypeInternal _WsMessage_default_instance_;
}  // namespace protocol

namespace protocol {

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_message_2eproto

enum Account_Limit {
  Account_Limit_SIGNER = 100
};
bool Account_Limit_IsValid(int value);
const Account_Limit Account_Limit_Limit_MIN = Account_Limit_SIGNER;
const Account_Limit Account_Limit_Limit_MAX = Account_Limit_SIGNER;
const int Account_Limit_Limit_ARRAYSIZE = Account_Limit_Limit_MAX + 1;

const ::google::protobuf::EnumDescriptor* Account_Limit_descriptor();
inline const ::std::string& Account_Limit_Name(Account_Limit value) {
  return ::google::protobuf::internal::NameOfEnum(
    Account_Limit_descriptor(), value);
}
inline bool Account_Limit_Parse(
    const ::std::string& name, Account_Limit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Account_Limit>(
    Account_Limit_descriptor(), name, value);
}
enum Ledgers_SyncCode {
  Ledgers_SyncCode_OK = 0,
  Ledgers_SyncCode_OUT_OF_SYNC = 1,
  Ledgers_SyncCode_OUT_OF_LEDGERS = 2,
  Ledgers_SyncCode_BUSY = 3,
  Ledgers_SyncCode_REFUSE = 4,
  Ledgers_SyncCode_INTERNAL = 5
};
bool Ledgers_SyncCode_IsValid(int value);
const Ledgers_SyncCode Ledgers_SyncCode_SyncCode_MIN = Ledgers_SyncCode_OK;
const Ledgers_SyncCode Ledgers_SyncCode_SyncCode_MAX = Ledgers_SyncCode_INTERNAL;
const int Ledgers_SyncCode_SyncCode_ARRAYSIZE = Ledgers_SyncCode_SyncCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Ledgers_SyncCode_descriptor();
inline const ::std::string& Ledgers_SyncCode_Name(Ledgers_SyncCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Ledgers_SyncCode_descriptor(), value);
}
inline bool Ledgers_SyncCode_Parse(
    const ::std::string& name, Ledgers_SyncCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Ledgers_SyncCode>(
    Ledgers_SyncCode_descriptor(), name, value);
}
enum AssetProperty_Type {
  AssetProperty_Type_NATIVE = 0,
  AssetProperty_Type_IOU = 1,
  AssetProperty_Type_UNIQUE = 2
};
bool AssetProperty_Type_IsValid(int value);
const AssetProperty_Type AssetProperty_Type_Type_MIN = AssetProperty_Type_NATIVE;
const AssetProperty_Type AssetProperty_Type_Type_MAX = AssetProperty_Type_UNIQUE;
const int AssetProperty_Type_Type_ARRAYSIZE = AssetProperty_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* AssetProperty_Type_descriptor();
inline const ::std::string& AssetProperty_Type_Name(AssetProperty_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    AssetProperty_Type_descriptor(), value);
}
inline bool AssetProperty_Type_Parse(
    const ::std::string& name, AssetProperty_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AssetProperty_Type>(
    AssetProperty_Type_descriptor(), name, value);
}
enum Operation_Type {
  Operation_Type_CREATE_ACCOUNT = 0,
  Operation_Type_PAYMENT = 1,
  Operation_Type_ISSUE_ASSET = 2,
  Operation_Type_SET_OPTIONS = 4,
  Operation_Type_INIT_PAYMENT = 5,
  Operation_Type_PRODUCTION = 6,
  Operation_Type_ISSUE_UNIQUE_ASSET = 7,
  Operation_Type_PAYMENT_UNIQUE_ASSET = 8,
  Operation_Type_RECORD = 9
};
bool Operation_Type_IsValid(int value);
const Operation_Type Operation_Type_Type_MIN = Operation_Type_CREATE_ACCOUNT;
const Operation_Type Operation_Type_Type_MAX = Operation_Type_RECORD;
const int Operation_Type_Type_ARRAYSIZE = Operation_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operation_Type_descriptor();
inline const ::std::string& Operation_Type_Name(Operation_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operation_Type_descriptor(), value);
}
inline bool Operation_Type_Parse(
    const ::std::string& name, Operation_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operation_Type>(
    Operation_Type_descriptor(), name, value);
}
enum Transaction_Limit {
  Transaction_Limit_OPERATIONS = 1000
};
bool Transaction_Limit_IsValid(int value);
const Transaction_Limit Transaction_Limit_Limit_MIN = Transaction_Limit_OPERATIONS;
const Transaction_Limit Transaction_Limit_Limit_MAX = Transaction_Limit_OPERATIONS;
const int Transaction_Limit_Limit_ARRAYSIZE = Transaction_Limit_Limit_MAX + 1;

const ::google::protobuf::EnumDescriptor* Transaction_Limit_descriptor();
inline const ::std::string& Transaction_Limit_Name(Transaction_Limit value) {
  return ::google::protobuf::internal::NameOfEnum(
    Transaction_Limit_descriptor(), value);
}
inline bool Transaction_Limit_Parse(
    const ::std::string& name, Transaction_Limit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Transaction_Limit>(
    Transaction_Limit_descriptor(), name, value);
}
enum TransactionEnv_Limit {
  TransactionEnv_Limit_SIGNATURE = 100
};
bool TransactionEnv_Limit_IsValid(int value);
const TransactionEnv_Limit TransactionEnv_Limit_Limit_MIN = TransactionEnv_Limit_SIGNATURE;
const TransactionEnv_Limit TransactionEnv_Limit_Limit_MAX = TransactionEnv_Limit_SIGNATURE;
const int TransactionEnv_Limit_Limit_ARRAYSIZE = TransactionEnv_Limit_Limit_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransactionEnv_Limit_descriptor();
inline const ::std::string& TransactionEnv_Limit_Name(TransactionEnv_Limit value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransactionEnv_Limit_descriptor(), value);
}
inline bool TransactionEnv_Limit_Parse(
    const ::std::string& name, TransactionEnv_Limit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransactionEnv_Limit>(
    TransactionEnv_Limit_descriptor(), name, value);
}
enum ChainTxStatus_TxStatus {
  ChainTxStatus_TxStatus_UNDEFINED = 0,
  ChainTxStatus_TxStatus_CONFIRMED = 1,
  ChainTxStatus_TxStatus_PENDING = 2,
  ChainTxStatus_TxStatus_COMPLETE = 3,
  ChainTxStatus_TxStatus_FAILURE = 4
};
bool ChainTxStatus_TxStatus_IsValid(int value);
const ChainTxStatus_TxStatus ChainTxStatus_TxStatus_TxStatus_MIN = ChainTxStatus_TxStatus_UNDEFINED;
const ChainTxStatus_TxStatus ChainTxStatus_TxStatus_TxStatus_MAX = ChainTxStatus_TxStatus_FAILURE;
const int ChainTxStatus_TxStatus_TxStatus_ARRAYSIZE = ChainTxStatus_TxStatus_TxStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChainTxStatus_TxStatus_descriptor();
inline const ::std::string& ChainTxStatus_TxStatus_Name(ChainTxStatus_TxStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChainTxStatus_TxStatus_descriptor(), value);
}
inline bool ChainTxStatus_TxStatus_Parse(
    const ::std::string& name, ChainTxStatus_TxStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChainTxStatus_TxStatus>(
    ChainTxStatus_TxStatus_descriptor(), name, value);
}
enum PbftMessageType {
  PBFT_TYPE_PREPREPARE = 0,
  PBFT_TYPE_PREPARE = 1,
  PBFT_TYPE_COMMIT = 2,
  PBFT_TYPE_CHECKPOINT = 3,
  PBFT_TYPE_VIEWCHANGE = 4,
  PBFT_TYPE_NEWVIEW = 5
};
bool PbftMessageType_IsValid(int value);
const PbftMessageType PbftMessageType_MIN = PBFT_TYPE_PREPREPARE;
const PbftMessageType PbftMessageType_MAX = PBFT_TYPE_NEWVIEW;
const int PbftMessageType_ARRAYSIZE = PbftMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PbftMessageType_descriptor();
inline const ::std::string& PbftMessageType_Name(PbftMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PbftMessageType_descriptor(), value);
}
inline bool PbftMessageType_Parse(
    const ::std::string& name, PbftMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PbftMessageType>(
    PbftMessageType_descriptor(), name, value);
}
enum PbftValueType {
  PBFT_VALUE_TX = 0,
  PBFT_VALUE_TXSET = 1
};
bool PbftValueType_IsValid(int value);
const PbftValueType PbftValueType_MIN = PBFT_VALUE_TX;
const PbftValueType PbftValueType_MAX = PBFT_VALUE_TXSET;
const int PbftValueType_ARRAYSIZE = PbftValueType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PbftValueType_descriptor();
inline const ::std::string& PbftValueType_Name(PbftValueType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PbftValueType_descriptor(), value);
}
inline bool PbftValueType_Parse(
    const ::std::string& name, PbftValueType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PbftValueType>(
    PbftValueType_descriptor(), name, value);
}
enum ChainMessageType {
  CHAIN_HELLO = 10,
  CHAIN_TX_STATUS = 11,
  CHAIN_PEER_ONLINE = 12,
  CHAIN_PEER_OFFLINE = 13,
  CHAIN_PEER_MESSAGE = 14,
  CHAIN_SUBMITTRANSACTION = 15
};
bool ChainMessageType_IsValid(int value);
const ChainMessageType ChainMessageType_MIN = CHAIN_HELLO;
const ChainMessageType ChainMessageType_MAX = CHAIN_SUBMITTRANSACTION;
const int ChainMessageType_ARRAYSIZE = ChainMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChainMessageType_descriptor();
inline const ::std::string& ChainMessageType_Name(ChainMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChainMessageType_descriptor(), value);
}
inline bool ChainMessageType_Parse(
    const ::std::string& name, ChainMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChainMessageType>(
    ChainMessageType_descriptor(), name, value);
}
enum ERRORCODE {
  ERRCODE_SUCCESS = 0,
  ERRCODE_INTERNAL_ERROR = 1,
  ERRCODE_INVALID_PARAMETER = 2,
  ERRCODE_ALREADY_EXIST = 3,
  ERRCODE_NOT_EXIST = 4,
  ERRCODE_TX_TIMEOUT = 5,
  ERRCODE_INVALID_PUBKEY = 90,
  ERRCODE_INVALID_PRIKEY = 91,
  ERRCODE_ASSET_INVALID = 92,
  ERRCODE_INVALID_SIGNATURE = 93,
  ERRCODE_INVALID_ADDRESS = 94,
  ERRCODE_TIME_NOT_IN_RANGE = 95,
  ERRCODE_NO_NETWORK_CONSENSUS = 96,
  ERRCODE_MISSING_OPERATIONS = 97,
  ERRCODE_LAGER_OPERATIONS = 98,
  ERRCODE_BAD_SEQUENCE = 99,
  ERRCODE_ACCOUNT_LOW_RESERVE = 100,
  ERRCODE_ACCOUNT_SOURCEDEST_EQUAL = 101,
  ERRCODE_ACCOUNT_DEST_EXIST = 102,
  ERRCODE_ACCOUNT_NOT_EXIST = 103,
  ERRCODE_ACCOUNT_ASSET_LOW_RESERVE = 104,
  ERRCODE_ACCOUNT_ASSET_AMOUNT_TOO_LARGE = 105,
  ERRCODE_SEQNUMBER_NOT_MATCH = 110,
  ERRCODE_FEE_NOT_ENOUGH = 111,
  ERRCODE_TIMEBOUND_TOO_EARLY = 112,
  ERRCODE_TIMEBOUND_TOO_LATE = 113,
  ERRCODE_OUT_OF_TXCACHE = 114,
  ERRCODE_WEIGHT_NOT_VALID = 120,
  ERRCODE_INPUT_NOT_EXIST = 130,
  ERRCODE_INPUT_INVALID = 131,
  ERRCODE_NOT_SUPPLY = 132,
  ERRCODE_INVALID_DATAVERSION = 144
};
bool ERRORCODE_IsValid(int value);
const ERRORCODE ERRORCODE_MIN = ERRCODE_SUCCESS;
const ERRORCODE ERRORCODE_MAX = ERRCODE_INVALID_DATAVERSION;
const int ERRORCODE_ARRAYSIZE = ERRORCODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* ERRORCODE_descriptor();
inline const ::std::string& ERRORCODE_Name(ERRORCODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    ERRORCODE_descriptor(), value);
}
inline bool ERRORCODE_Parse(
    const ::std::string& name, ERRORCODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ERRORCODE>(
    ERRORCODE_descriptor(), name, value);
}
// ===================================================================

class Hello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Hello) */ {
 public:
  Hello();
  virtual ~Hello();

  Hello(const Hello& from);

  inline Hello& operator=(const Hello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hello& default_instance();

  static inline const Hello* internal_default_instance() {
    return reinterpret_cast<const Hello*>(
               &_Hello_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Hello* other);

  // implements Message ----------------------------------------------

  inline Hello* New() const PROTOBUF_FINAL { return New(NULL); }

  Hello* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Hello& from);
  void MergeFrom(const Hello& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Hello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string bubiVersion = 3;
  bool has_bubiversion() const;
  void clear_bubiversion();
  static const int kBubiVersionFieldNumber = 3;
  const ::std::string& bubiversion() const;
  void set_bubiversion(const ::std::string& value);
  #if LANG_CXX11
  void set_bubiversion(::std::string&& value);
  #endif
  void set_bubiversion(const char* value);
  void set_bubiversion(const char* value, size_t size);
  ::std::string* mutable_bubiversion();
  ::std::string* release_bubiversion();
  void set_allocated_bubiversion(::std::string* bubiversion);

  // required string nodeId = 5;
  bool has_nodeid() const;
  void clear_nodeid();
  static const int kNodeIdFieldNumber = 5;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  #if LANG_CXX11
  void set_nodeid(::std::string&& value);
  #endif
  void set_nodeid(const char* value);
  void set_nodeid(const char* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // required string network_type = 6;
  bool has_network_type() const;
  void clear_network_type();
  static const int kNetworkTypeFieldNumber = 6;
  const ::std::string& network_type() const;
  void set_network_type(const ::std::string& value);
  #if LANG_CXX11
  void set_network_type(::std::string&& value);
  #endif
  void set_network_type(const char* value);
  void set_network_type(const char* value, size_t size);
  ::std::string* mutable_network_type();
  ::std::string* release_network_type();
  void set_allocated_network_type(::std::string* network_type);

  // required uint32 ledger_version = 1;
  bool has_ledger_version() const;
  void clear_ledger_version();
  static const int kLedgerVersionFieldNumber = 1;
  ::google::protobuf::uint32 ledger_version() const;
  void set_ledger_version(::google::protobuf::uint32 value);

  // required uint32 overlayVersion = 2;
  bool has_overlayversion() const;
  void clear_overlayversion();
  static const int kOverlayVersionFieldNumber = 2;
  ::google::protobuf::uint32 overlayversion() const;
  void set_overlayversion(::google::protobuf::uint32 value);

  // required int32 listeningPort = 4;
  bool has_listeningport() const;
  void clear_listeningport();
  static const int kListeningPortFieldNumber = 4;
  ::google::protobuf::int32 listeningport() const;
  void set_listeningport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.Hello)
 private:
  void set_has_ledger_version();
  void clear_has_ledger_version();
  void set_has_overlayversion();
  void clear_has_overlayversion();
  void set_has_bubiversion();
  void clear_has_bubiversion();
  void set_has_listeningport();
  void clear_has_listeningport();
  void set_has_nodeid();
  void clear_has_nodeid();
  void set_has_network_type();
  void clear_has_network_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr bubiversion_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  ::google::protobuf::internal::ArenaStringPtr network_type_;
  ::google::protobuf::uint32 ledger_version_;
  ::google::protobuf::uint32 overlayversion_;
  ::google::protobuf::int32 listeningport_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Ping) */ {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  inline Ping* New() const PROTOBUF_FINAL { return New(NULL); }

  Ping* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 nonce = 1;
  bool has_nonce() const;
  void clear_nonce();
  static const int kNonceFieldNumber = 1;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protocol.Ping)
 private:
  void set_has_nonce();
  void clear_has_nonce();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 nonce_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pong : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Pong) */ {
 public:
  Pong();
  virtual ~Pong();

  Pong(const Pong& from);

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pong& default_instance();

  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
               &_Pong_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Pong* other);

  // implements Message ----------------------------------------------

  inline Pong* New() const PROTOBUF_FINAL { return New(NULL); }

  Pong* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pong& from);
  void MergeFrom(const Pong& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pong* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 nonce = 1;
  bool has_nonce() const;
  void clear_nonce();
  static const int kNonceFieldNumber = 1;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protocol.Pong)
 private:
  void set_has_nonce();
  void clear_has_nonce();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 nonce_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Peers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Peers) */ {
 public:
  Peers();
  virtual ~Peers();

  Peers(const Peers& from);

  inline Peers& operator=(const Peers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Peers& default_instance();

  static inline const Peers* internal_default_instance() {
    return reinterpret_cast<const Peers*>(
               &_Peers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Peers* other);

  // implements Message ----------------------------------------------

  inline Peers* New() const PROTOBUF_FINAL { return New(NULL); }

  Peers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Peers& from);
  void MergeFrom(const Peers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Peers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Peer peers = 2;
  int peers_size() const;
  void clear_peers();
  static const int kPeersFieldNumber = 2;
  const ::protocol::Peer& peers(int index) const;
  ::protocol::Peer* mutable_peers(int index);
  ::protocol::Peer* add_peers();
  ::google::protobuf::RepeatedPtrField< ::protocol::Peer >*
      mutable_peers();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Peer >&
      peers() const;

  // @@protoc_insertion_point(class_scope:protocol.Peers)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Peer > peers_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Peer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Peer) */ {
 public:
  Peer();
  virtual ~Peer();

  Peer(const Peer& from);

  inline Peer& operator=(const Peer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Peer& default_instance();

  static inline const Peer* internal_default_instance() {
    return reinterpret_cast<const Peer*>(
               &_Peer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Peer* other);

  // implements Message ----------------------------------------------

  inline Peer* New() const PROTOBUF_FINAL { return New(NULL); }

  Peer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Peer& from);
  void MergeFrom(const Peer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Peer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // required int32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // required int32 num_failures = 3;
  bool has_num_failures() const;
  void clear_num_failures();
  static const int kNumFailuresFieldNumber = 3;
  ::google::protobuf::int32 num_failures() const;
  void set_num_failures(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.Peer)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_port();
  void clear_has_port();
  void set_has_num_failures();
  void clear_has_num_failures();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 num_failures_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountThreshold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.AccountThreshold) */ {
 public:
  AccountThreshold();
  virtual ~AccountThreshold();

  AccountThreshold(const AccountThreshold& from);

  inline AccountThreshold& operator=(const AccountThreshold& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountThreshold& default_instance();

  static inline const AccountThreshold* internal_default_instance() {
    return reinterpret_cast<const AccountThreshold*>(
               &_AccountThreshold_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(AccountThreshold* other);

  // implements Message ----------------------------------------------

  inline AccountThreshold* New() const PROTOBUF_FINAL { return New(NULL); }

  AccountThreshold* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccountThreshold& from);
  void MergeFrom(const AccountThreshold& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccountThreshold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 master_weight = 1;
  bool has_master_weight() const;
  void clear_master_weight();
  static const int kMasterWeightFieldNumber = 1;
  ::google::protobuf::uint32 master_weight() const;
  void set_master_weight(::google::protobuf::uint32 value);

  // required uint32 low_threshold = 2;
  bool has_low_threshold() const;
  void clear_low_threshold();
  static const int kLowThresholdFieldNumber = 2;
  ::google::protobuf::uint32 low_threshold() const;
  void set_low_threshold(::google::protobuf::uint32 value);

  // required uint32 med_threshold = 3;
  bool has_med_threshold() const;
  void clear_med_threshold();
  static const int kMedThresholdFieldNumber = 3;
  ::google::protobuf::uint32 med_threshold() const;
  void set_med_threshold(::google::protobuf::uint32 value);

  // required uint32 high_threshold = 4;
  bool has_high_threshold() const;
  void clear_high_threshold();
  static const int kHighThresholdFieldNumber = 4;
  ::google::protobuf::uint32 high_threshold() const;
  void set_high_threshold(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.AccountThreshold)
 private:
  void set_has_master_weight();
  void clear_has_master_weight();
  void set_has_low_threshold();
  void clear_has_low_threshold();
  void set_has_med_threshold();
  void clear_has_med_threshold();
  void set_has_high_threshold();
  void clear_has_high_threshold();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 master_weight_;
  ::google::protobuf::uint32 low_threshold_;
  ::google::protobuf::uint32 med_threshold_;
  ::google::protobuf::uint32 high_threshold_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Signer) */ {
 public:
  Signer();
  virtual ~Signer();

  Signer(const Signer& from);

  inline Signer& operator=(const Signer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signer& default_instance();

  static inline const Signer* internal_default_instance() {
    return reinterpret_cast<const Signer*>(
               &_Signer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Signer* other);

  // implements Message ----------------------------------------------

  inline Signer* New() const PROTOBUF_FINAL { return New(NULL); }

  Signer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Signer& from);
  void MergeFrom(const Signer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Signer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // required uint32 weight = 2;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 2;
  ::google::protobuf::uint32 weight() const;
  void set_weight(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.Signer)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_weight();
  void clear_has_weight();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint32 weight_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Account) */ {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Account* other);

  // implements Message ----------------------------------------------

  inline Account* New() const PROTOBUF_FINAL { return New(NULL); }

  Account* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Account_Limit Limit;
  static const Limit SIGNER =
    Account_Limit_SIGNER;
  static inline bool Limit_IsValid(int value) {
    return Account_Limit_IsValid(value);
  }
  static const Limit Limit_MIN =
    Account_Limit_Limit_MIN;
  static const Limit Limit_MAX =
    Account_Limit_Limit_MAX;
  static const int Limit_ARRAYSIZE =
    Account_Limit_Limit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Limit_descriptor() {
    return Account_Limit_descriptor();
  }
  static inline const ::std::string& Limit_Name(Limit value) {
    return Account_Limit_Name(value);
  }
  static inline bool Limit_Parse(const ::std::string& name,
      Limit* value) {
    return Account_Limit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .protocol.Asset assets = 5;
  int assets_size() const;
  void clear_assets();
  static const int kAssetsFieldNumber = 5;
  const ::protocol::Asset& assets(int index) const;
  ::protocol::Asset* mutable_assets(int index);
  ::protocol::Asset* add_assets();
  ::google::protobuf::RepeatedPtrField< ::protocol::Asset >*
      mutable_assets();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Asset >&
      assets() const;

  // repeated .protocol.Signer signers = 8;
  int signers_size() const;
  void clear_signers();
  static const int kSignersFieldNumber = 8;
  const ::protocol::Signer& signers(int index) const;
  ::protocol::Signer* mutable_signers(int index);
  ::protocol::Signer* add_signers();
  ::google::protobuf::RepeatedPtrField< ::protocol::Signer >*
      mutable_signers();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Signer >&
      signers() const;

  // repeated .protocol.UniqueAsset unique_asset = 11;
  int unique_asset_size() const;
  void clear_unique_asset();
  static const int kUniqueAssetFieldNumber = 11;
  const ::protocol::UniqueAsset& unique_asset(int index) const;
  ::protocol::UniqueAsset* mutable_unique_asset(int index);
  ::protocol::UniqueAsset* add_unique_asset();
  ::google::protobuf::RepeatedPtrField< ::protocol::UniqueAsset >*
      mutable_unique_asset();
  const ::google::protobuf::RepeatedPtrField< ::protocol::UniqueAsset >&
      unique_asset() const;

  // required bytes previous_tx_hash = 3;
  bool has_previous_tx_hash() const;
  void clear_previous_tx_hash();
  static const int kPreviousTxHashFieldNumber = 3;
  const ::std::string& previous_tx_hash() const;
  void set_previous_tx_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_previous_tx_hash(::std::string&& value);
  #endif
  void set_previous_tx_hash(const char* value);
  void set_previous_tx_hash(const void* value, size_t size);
  ::std::string* mutable_previous_tx_hash();
  ::std::string* release_previous_tx_hash();
  void set_allocated_previous_tx_hash(::std::string* previous_tx_hash);

  // required string account_address = 4;
  bool has_account_address() const;
  void clear_account_address();
  static const int kAccountAddressFieldNumber = 4;
  const ::std::string& account_address() const;
  void set_account_address(const ::std::string& value);
  #if LANG_CXX11
  void set_account_address(::std::string&& value);
  #endif
  void set_account_address(const char* value);
  void set_account_address(const char* value, size_t size);
  ::std::string* mutable_account_address();
  ::std::string* release_account_address();
  void set_allocated_account_address(::std::string* account_address);

  // required bytes metadata = 9;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 9;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // required .protocol.AccountThreshold thresholds = 7;
  bool has_thresholds() const;
  void clear_thresholds();
  static const int kThresholdsFieldNumber = 7;
  const ::protocol::AccountThreshold& thresholds() const;
  ::protocol::AccountThreshold* mutable_thresholds();
  ::protocol::AccountThreshold* release_thresholds();
  void set_allocated_thresholds(::protocol::AccountThreshold* thresholds);

  // required int64 account_balance = 1;
  bool has_account_balance() const;
  void clear_account_balance();
  static const int kAccountBalanceFieldNumber = 1;
  ::google::protobuf::int64 account_balance() const;
  void set_account_balance(::google::protobuf::int64 value);

  // required int64 previous_ledger_seq = 2;
  bool has_previous_ledger_seq() const;
  void clear_previous_ledger_seq();
  static const int kPreviousLedgerSeqFieldNumber = 2;
  ::google::protobuf::int64 previous_ledger_seq() const;
  void set_previous_ledger_seq(::google::protobuf::int64 value);

  // required int64 tx_seq = 6;
  bool has_tx_seq() const;
  void clear_tx_seq();
  static const int kTxSeqFieldNumber = 6;
  ::google::protobuf::int64 tx_seq() const;
  void set_tx_seq(::google::protobuf::int64 value);

  // optional int64 metadata_version = 10;
  bool has_metadata_version() const;
  void clear_metadata_version();
  static const int kMetadataVersionFieldNumber = 10;
  ::google::protobuf::int64 metadata_version() const;
  void set_metadata_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Account)
 private:
  void set_has_account_balance();
  void clear_has_account_balance();
  void set_has_previous_ledger_seq();
  void clear_has_previous_ledger_seq();
  void set_has_previous_tx_hash();
  void clear_has_previous_tx_hash();
  void set_has_account_address();
  void clear_has_account_address();
  void set_has_tx_seq();
  void clear_has_tx_seq();
  void set_has_thresholds();
  void clear_has_thresholds();
  void set_has_metadata();
  void clear_has_metadata();
  void set_has_metadata_version();
  void clear_has_metadata_version();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Asset > assets_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Signer > signers_;
  ::google::protobuf::RepeatedPtrField< ::protocol::UniqueAsset > unique_asset_;
  ::google::protobuf::internal::ArenaStringPtr previous_tx_hash_;
  ::google::protobuf::internal::ArenaStringPtr account_address_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::protocol::AccountThreshold* thresholds_;
  ::google::protobuf::int64 account_balance_;
  ::google::protobuf::int64 previous_ledger_seq_;
  ::google::protobuf::int64 tx_seq_;
  ::google::protobuf::int64 metadata_version_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpgradeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.UpgradeRequest) */ {
 public:
  UpgradeRequest();
  virtual ~UpgradeRequest();

  UpgradeRequest(const UpgradeRequest& from);

  inline UpgradeRequest& operator=(const UpgradeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeRequest& default_instance();

  static inline const UpgradeRequest* internal_default_instance() {
    return reinterpret_cast<const UpgradeRequest*>(
               &_UpgradeRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(UpgradeRequest* other);

  // implements Message ----------------------------------------------

  inline UpgradeRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UpgradeRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpgradeRequest& from);
  void MergeFrom(const UpgradeRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpgradeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string add_validator = 4;
  bool has_add_validator() const;
  void clear_add_validator();
  static const int kAddValidatorFieldNumber = 4;
  const ::std::string& add_validator() const;
  void set_add_validator(const ::std::string& value);
  #if LANG_CXX11
  void set_add_validator(::std::string&& value);
  #endif
  void set_add_validator(const char* value);
  void set_add_validator(const char* value, size_t size);
  ::std::string* mutable_add_validator();
  ::std::string* release_add_validator();
  void set_allocated_add_validator(::std::string* add_validator);

  // required uint64 time = 2;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // required uint32 ledger_version = 3;
  bool has_ledger_version() const;
  void clear_ledger_version();
  static const int kLedgerVersionFieldNumber = 3;
  ::google::protobuf::uint32 ledger_version() const;
  void set_ledger_version(::google::protobuf::uint32 value);

  // optional uint32 new_ledger_version = 5;
  bool has_new_ledger_version() const;
  void clear_new_ledger_version();
  static const int kNewLedgerVersionFieldNumber = 5;
  ::google::protobuf::uint32 new_ledger_version() const;
  void set_new_ledger_version(::google::protobuf::uint32 value);

  // required uint64 start_time = 6;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 6;
  ::google::protobuf::uint64 start_time() const;
  void set_start_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protocol.UpgradeRequest)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_time();
  void clear_has_time();
  void set_has_ledger_version();
  void clear_has_ledger_version();
  void set_has_add_validator();
  void clear_has_add_validator();
  void set_has_new_ledger_version();
  void clear_has_new_ledger_version();
  void set_has_start_time();
  void clear_has_start_time();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr add_validator_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 ledger_version_;
  ::google::protobuf::uint32 new_ledger_version_;
  ::google::protobuf::uint64 start_time_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpgradeRequestEnv : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.UpgradeRequestEnv) */ {
 public:
  UpgradeRequestEnv();
  virtual ~UpgradeRequestEnv();

  UpgradeRequestEnv(const UpgradeRequestEnv& from);

  inline UpgradeRequestEnv& operator=(const UpgradeRequestEnv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeRequestEnv& default_instance();

  static inline const UpgradeRequestEnv* internal_default_instance() {
    return reinterpret_cast<const UpgradeRequestEnv*>(
               &_UpgradeRequestEnv_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(UpgradeRequestEnv* other);

  // implements Message ----------------------------------------------

  inline UpgradeRequestEnv* New() const PROTOBUF_FINAL { return New(NULL); }

  UpgradeRequestEnv* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpgradeRequestEnv& from);
  void MergeFrom(const UpgradeRequestEnv& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpgradeRequestEnv* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.UpgradeRequest request = 1;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 1;
  const ::protocol::UpgradeRequest& request() const;
  ::protocol::UpgradeRequest* mutable_request();
  ::protocol::UpgradeRequest* release_request();
  void set_allocated_request(::protocol::UpgradeRequest* request);

  // required .protocol.Signature signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::protocol::Signature& signature() const;
  ::protocol::Signature* mutable_signature();
  ::protocol::Signature* release_signature();
  void set_allocated_signature(::protocol::Signature* signature);

  // @@protoc_insertion_point(class_scope:protocol.UpgradeRequestEnv)
 private:
  void set_has_request();
  void clear_has_request();
  void set_has_signature();
  void clear_has_signature();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::UpgradeRequest* request_;
  ::protocol::Signature* signature_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LedgerUpgrade : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.LedgerUpgrade) */ {
 public:
  LedgerUpgrade();
  virtual ~LedgerUpgrade();

  LedgerUpgrade(const LedgerUpgrade& from);

  inline LedgerUpgrade& operator=(const LedgerUpgrade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LedgerUpgrade& default_instance();

  static inline const LedgerUpgrade* internal_default_instance() {
    return reinterpret_cast<const LedgerUpgrade*>(
               &_LedgerUpgrade_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(LedgerUpgrade* other);

  // implements Message ----------------------------------------------

  inline LedgerUpgrade* New() const PROTOBUF_FINAL { return New(NULL); }

  LedgerUpgrade* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LedgerUpgrade& from);
  void MergeFrom(const LedgerUpgrade& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LedgerUpgrade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 new_ledger_version = 1;
  bool has_new_ledger_version() const;
  void clear_new_ledger_version();
  static const int kNewLedgerVersionFieldNumber = 1;
  ::google::protobuf::uint32 new_ledger_version() const;
  void set_new_ledger_version(::google::protobuf::uint32 value);

  // optional uint32 new_base_fee = 2;
  bool has_new_base_fee() const;
  void clear_new_base_fee();
  static const int kNewBaseFeeFieldNumber = 2;
  ::google::protobuf::uint32 new_base_fee() const;
  void set_new_base_fee(::google::protobuf::uint32 value);

  // optional uint32 new_base_reserve = 3;
  bool has_new_base_reserve() const;
  void clear_new_base_reserve();
  static const int kNewBaseReserveFieldNumber = 3;
  ::google::protobuf::uint32 new_base_reserve() const;
  void set_new_base_reserve(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.LedgerUpgrade)
 private:
  void set_has_new_ledger_version();
  void clear_has_new_ledger_version();
  void set_has_new_base_fee();
  void clear_has_new_base_fee();
  void set_has_new_base_reserve();
  void clear_has_new_base_reserve();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 new_ledger_version_;
  ::google::protobuf::uint32 new_base_fee_;
  ::google::protobuf::uint32 new_base_reserve_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Value : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Value) */ {
 public:
  Value();
  virtual ~Value();

  Value(const Value& from);

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Value& default_instance();

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Value* other);

  // implements Message ----------------------------------------------

  inline Value* New() const PROTOBUF_FINAL { return New(NULL); }

  Value* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Value* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes hash_set = 1;
  bool has_hash_set() const;
  void clear_hash_set();
  static const int kHashSetFieldNumber = 1;
  const ::std::string& hash_set() const;
  void set_hash_set(const ::std::string& value);
  #if LANG_CXX11
  void set_hash_set(::std::string&& value);
  #endif
  void set_hash_set(const char* value);
  void set_hash_set(const void* value, size_t size);
  ::std::string* mutable_hash_set();
  ::std::string* release_hash_set();
  void set_allocated_hash_set(::std::string* hash_set);

  // optional .protocol.LedgerUpgrade ledger_upgrade = 3;
  bool has_ledger_upgrade() const;
  void clear_ledger_upgrade();
  static const int kLedgerUpgradeFieldNumber = 3;
  const ::protocol::LedgerUpgrade& ledger_upgrade() const;
  ::protocol::LedgerUpgrade* mutable_ledger_upgrade();
  ::protocol::LedgerUpgrade* release_ledger_upgrade();
  void set_allocated_ledger_upgrade(::protocol::LedgerUpgrade* ledger_upgrade);

  // required uint64 close_time = 2;
  bool has_close_time() const;
  void clear_close_time();
  static const int kCloseTimeFieldNumber = 2;
  ::google::protobuf::uint64 close_time() const;
  void set_close_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protocol.Value)
 private:
  void set_has_hash_set();
  void clear_has_hash_set();
  void set_has_close_time();
  void clear_has_close_time();
  void set_has_ledger_upgrade();
  void clear_has_ledger_upgrade();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hash_set_;
  ::protocol::LedgerUpgrade* ledger_upgrade_;
  ::google::protobuf::uint64 close_time_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LedgerHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.LedgerHeader) */ {
 public:
  LedgerHeader();
  virtual ~LedgerHeader();

  LedgerHeader(const LedgerHeader& from);

  inline LedgerHeader& operator=(const LedgerHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LedgerHeader& default_instance();

  static inline const LedgerHeader* internal_default_instance() {
    return reinterpret_cast<const LedgerHeader*>(
               &_LedgerHeader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(LedgerHeader* other);

  // implements Message ----------------------------------------------

  inline LedgerHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  LedgerHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LedgerHeader& from);
  void MergeFrom(const LedgerHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LedgerHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes parent_hash = 1;
  bool has_parent_hash() const;
  void clear_parent_hash();
  static const int kParentHashFieldNumber = 1;
  const ::std::string& parent_hash() const;
  void set_parent_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_hash(::std::string&& value);
  #endif
  void set_parent_hash(const char* value);
  void set_parent_hash(const void* value, size_t size);
  ::std::string* mutable_parent_hash();
  ::std::string* release_parent_hash();
  void set_allocated_parent_hash(::std::string* parent_hash);

  // required bytes transaction_tree_hash = 2;
  bool has_transaction_tree_hash() const;
  void clear_transaction_tree_hash();
  static const int kTransactionTreeHashFieldNumber = 2;
  const ::std::string& transaction_tree_hash() const;
  void set_transaction_tree_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_transaction_tree_hash(::std::string&& value);
  #endif
  void set_transaction_tree_hash(const char* value);
  void set_transaction_tree_hash(const void* value, size_t size);
  ::std::string* mutable_transaction_tree_hash();
  ::std::string* release_transaction_tree_hash();
  void set_allocated_transaction_tree_hash(::std::string* transaction_tree_hash);

  // required bytes account_tree_hash = 3;
  bool has_account_tree_hash() const;
  void clear_account_tree_hash();
  static const int kAccountTreeHashFieldNumber = 3;
  const ::std::string& account_tree_hash() const;
  void set_account_tree_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_account_tree_hash(::std::string&& value);
  #endif
  void set_account_tree_hash(const char* value);
  void set_account_tree_hash(const void* value, size_t size);
  ::std::string* mutable_account_tree_hash();
  ::std::string* release_account_tree_hash();
  void set_allocated_account_tree_hash(::std::string* account_tree_hash);

  // required bytes hash = 6;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 6;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // required .protocol.Value consensus_value = 5;
  bool has_consensus_value() const;
  void clear_consensus_value();
  static const int kConsensusValueFieldNumber = 5;
  const ::protocol::Value& consensus_value() const;
  ::protocol::Value* mutable_consensus_value();
  ::protocol::Value* release_consensus_value();
  void set_allocated_consensus_value(::protocol::Value* consensus_value);

  // required int64 ledger_sequence = 4;
  bool has_ledger_sequence() const;
  void clear_ledger_sequence();
  static const int kLedgerSequenceFieldNumber = 4;
  ::google::protobuf::int64 ledger_sequence() const;
  void set_ledger_sequence(::google::protobuf::int64 value);

  // required uint32 base_fee = 7;
  bool has_base_fee() const;
  void clear_base_fee();
  static const int kBaseFeeFieldNumber = 7;
  ::google::protobuf::uint32 base_fee() const;
  void set_base_fee(::google::protobuf::uint32 value);

  // required uint32 base_reserve = 8;
  bool has_base_reserve() const;
  void clear_base_reserve();
  static const int kBaseReserveFieldNumber = 8;
  ::google::protobuf::uint32 base_reserve() const;
  void set_base_reserve(::google::protobuf::uint32 value);

  // required int64 tx_count = 10;
  bool has_tx_count() const;
  void clear_tx_count();
  static const int kTxCountFieldNumber = 10;
  ::google::protobuf::int64 tx_count() const;
  void set_tx_count(::google::protobuf::int64 value);

  // required uint32 ledger_version = 9;
  bool has_ledger_version() const;
  void clear_ledger_version();
  static const int kLedgerVersionFieldNumber = 9;
  ::google::protobuf::uint32 ledger_version() const;
  void set_ledger_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.LedgerHeader)
 private:
  void set_has_parent_hash();
  void clear_has_parent_hash();
  void set_has_transaction_tree_hash();
  void clear_has_transaction_tree_hash();
  void set_has_account_tree_hash();
  void clear_has_account_tree_hash();
  void set_has_ledger_sequence();
  void clear_has_ledger_sequence();
  void set_has_consensus_value();
  void clear_has_consensus_value();
  void set_has_hash();
  void clear_has_hash();
  void set_has_base_fee();
  void clear_has_base_fee();
  void set_has_base_reserve();
  void clear_has_base_reserve();
  void set_has_ledger_version();
  void clear_has_ledger_version();
  void set_has_tx_count();
  void clear_has_tx_count();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr parent_hash_;
  ::google::protobuf::internal::ArenaStringPtr transaction_tree_hash_;
  ::google::protobuf::internal::ArenaStringPtr account_tree_hash_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::protocol::Value* consensus_value_;
  ::google::protobuf::int64 ledger_sequence_;
  ::google::protobuf::uint32 base_fee_;
  ::google::protobuf::uint32 base_reserve_;
  ::google::protobuf::int64 tx_count_;
  ::google::protobuf::uint32 ledger_version_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLedgers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.GetLedgers) */ {
 public:
  GetLedgers();
  virtual ~GetLedgers();

  GetLedgers(const GetLedgers& from);

  inline GetLedgers& operator=(const GetLedgers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLedgers& default_instance();

  static inline const GetLedgers* internal_default_instance() {
    return reinterpret_cast<const GetLedgers*>(
               &_GetLedgers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(GetLedgers* other);

  // implements Message ----------------------------------------------

  inline GetLedgers* New() const PROTOBUF_FINAL { return New(NULL); }

  GetLedgers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetLedgers& from);
  void MergeFrom(const GetLedgers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetLedgers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 ledger_seq = 1;
  bool has_ledger_seq() const;
  void clear_ledger_seq();
  static const int kLedgerSeqFieldNumber = 1;
  ::google::protobuf::int64 ledger_seq() const;
  void set_ledger_seq(::google::protobuf::int64 value);

  // optional int64 ledger_num = 2;
  bool has_ledger_num() const;
  void clear_ledger_num();
  static const int kLedgerNumFieldNumber = 2;
  ::google::protobuf::int64 ledger_num() const;
  void set_ledger_num(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.GetLedgers)
 private:
  void set_has_ledger_seq();
  void clear_has_ledger_seq();
  void set_has_ledger_num();
  void clear_has_ledger_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 ledger_seq_;
  ::google::protobuf::int64 ledger_num_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ledger : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Ledger) */ {
 public:
  Ledger();
  virtual ~Ledger();

  Ledger(const Ledger& from);

  inline Ledger& operator=(const Ledger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ledger& default_instance();

  static inline const Ledger* internal_default_instance() {
    return reinterpret_cast<const Ledger*>(
               &_Ledger_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(Ledger* other);

  // implements Message ----------------------------------------------

  inline Ledger* New() const PROTOBUF_FINAL { return New(NULL); }

  Ledger* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ledger& from);
  void MergeFrom(const Ledger& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ledger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.TransactionEnv transaction_envs = 2;
  int transaction_envs_size() const;
  void clear_transaction_envs();
  static const int kTransactionEnvsFieldNumber = 2;
  const ::protocol::TransactionEnv& transaction_envs(int index) const;
  ::protocol::TransactionEnv* mutable_transaction_envs(int index);
  ::protocol::TransactionEnv* add_transaction_envs();
  ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >*
      mutable_transaction_envs();
  const ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >&
      transaction_envs() const;

  // required .protocol.LedgerHeader ledger_header = 1;
  bool has_ledger_header() const;
  void clear_ledger_header();
  static const int kLedgerHeaderFieldNumber = 1;
  const ::protocol::LedgerHeader& ledger_header() const;
  ::protocol::LedgerHeader* mutable_ledger_header();
  ::protocol::LedgerHeader* release_ledger_header();
  void set_allocated_ledger_header(::protocol::LedgerHeader* ledger_header);

  // @@protoc_insertion_point(class_scope:protocol.Ledger)
 private:
  void set_has_ledger_header();
  void clear_has_ledger_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv > transaction_envs_;
  ::protocol::LedgerHeader* ledger_header_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Ledgers : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Ledgers) */ {
 public:
  Ledgers();
  virtual ~Ledgers();

  Ledgers(const Ledgers& from);

  inline Ledgers& operator=(const Ledgers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ledgers& default_instance();

  static inline const Ledgers* internal_default_instance() {
    return reinterpret_cast<const Ledgers*>(
               &_Ledgers_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(Ledgers* other);

  // implements Message ----------------------------------------------

  inline Ledgers* New() const PROTOBUF_FINAL { return New(NULL); }

  Ledgers* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Ledgers& from);
  void MergeFrom(const Ledgers& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Ledgers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Ledgers_SyncCode SyncCode;
  static const SyncCode OK =
    Ledgers_SyncCode_OK;
  static const SyncCode OUT_OF_SYNC =
    Ledgers_SyncCode_OUT_OF_SYNC;
  static const SyncCode OUT_OF_LEDGERS =
    Ledgers_SyncCode_OUT_OF_LEDGERS;
  static const SyncCode BUSY =
    Ledgers_SyncCode_BUSY;
  static const SyncCode REFUSE =
    Ledgers_SyncCode_REFUSE;
  static const SyncCode INTERNAL =
    Ledgers_SyncCode_INTERNAL;
  static inline bool SyncCode_IsValid(int value) {
    return Ledgers_SyncCode_IsValid(value);
  }
  static const SyncCode SyncCode_MIN =
    Ledgers_SyncCode_SyncCode_MIN;
  static const SyncCode SyncCode_MAX =
    Ledgers_SyncCode_SyncCode_MAX;
  static const int SyncCode_ARRAYSIZE =
    Ledgers_SyncCode_SyncCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SyncCode_descriptor() {
    return Ledgers_SyncCode_descriptor();
  }
  static inline const ::std::string& SyncCode_Name(SyncCode value) {
    return Ledgers_SyncCode_Name(value);
  }
  static inline bool SyncCode_Parse(const ::std::string& name,
      SyncCode* value) {
    return Ledgers_SyncCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .protocol.Ledger ledger = 1;
  int ledger_size() const;
  void clear_ledger();
  static const int kLedgerFieldNumber = 1;
  const ::protocol::Ledger& ledger(int index) const;
  ::protocol::Ledger* mutable_ledger(int index);
  ::protocol::Ledger* add_ledger();
  ::google::protobuf::RepeatedPtrField< ::protocol::Ledger >*
      mutable_ledger();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Ledger >&
      ledger() const;

  // optional .protocol.Ledgers.SyncCode sync_code = 2;
  bool has_sync_code() const;
  void clear_sync_code();
  static const int kSyncCodeFieldNumber = 2;
  ::protocol::Ledgers_SyncCode sync_code() const;
  void set_sync_code(::protocol::Ledgers_SyncCode value);

  // optional int32 max_ledgers = 3;
  bool has_max_ledgers() const;
  void clear_max_ledgers();
  static const int kMaxLedgersFieldNumber = 3;
  ::google::protobuf::int32 max_ledgers() const;
  void set_max_ledgers(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.Ledgers)
 private:
  void set_has_sync_code();
  void clear_has_sync_code();
  void set_has_max_ledgers();
  void clear_has_max_ledgers();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Ledger > ledger_;
  int sync_code_;
  ::google::protobuf::int32 max_ledgers_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseTimeRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.CloseTimeRange) */ {
 public:
  CloseTimeRange();
  virtual ~CloseTimeRange();

  CloseTimeRange(const CloseTimeRange& from);

  inline CloseTimeRange& operator=(const CloseTimeRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseTimeRange& default_instance();

  static inline const CloseTimeRange* internal_default_instance() {
    return reinterpret_cast<const CloseTimeRange*>(
               &_CloseTimeRange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(CloseTimeRange* other);

  // implements Message ----------------------------------------------

  inline CloseTimeRange* New() const PROTOBUF_FINAL { return New(NULL); }

  CloseTimeRange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloseTimeRange& from);
  void MergeFrom(const CloseTimeRange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloseTimeRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 minTime = 1;
  bool has_mintime() const;
  void clear_mintime();
  static const int kMinTimeFieldNumber = 1;
  ::google::protobuf::int64 mintime() const;
  void set_mintime(::google::protobuf::int64 value);

  // required int64 maxTime = 2;
  bool has_maxtime() const;
  void clear_maxtime();
  static const int kMaxTimeFieldNumber = 2;
  ::google::protobuf::int64 maxtime() const;
  void set_maxtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.CloseTimeRange)
 private:
  void set_has_mintime();
  void clear_has_mintime();
  void set_has_maxtime();
  void clear_has_maxtime();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 mintime_;
  ::google::protobuf::int64 maxtime_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssetProperty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.AssetProperty) */ {
 public:
  AssetProperty();
  virtual ~AssetProperty();

  AssetProperty(const AssetProperty& from);

  inline AssetProperty& operator=(const AssetProperty& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssetProperty& default_instance();

  static inline const AssetProperty* internal_default_instance() {
    return reinterpret_cast<const AssetProperty*>(
               &_AssetProperty_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(AssetProperty* other);

  // implements Message ----------------------------------------------

  inline AssetProperty* New() const PROTOBUF_FINAL { return New(NULL); }

  AssetProperty* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AssetProperty& from);
  void MergeFrom(const AssetProperty& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AssetProperty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AssetProperty_Type Type;
  static const Type NATIVE =
    AssetProperty_Type_NATIVE;
  static const Type IOU =
    AssetProperty_Type_IOU;
  static const Type UNIQUE =
    AssetProperty_Type_UNIQUE;
  static inline bool Type_IsValid(int value) {
    return AssetProperty_Type_IsValid(value);
  }
  static const Type Type_MIN =
    AssetProperty_Type_Type_MIN;
  static const Type Type_MAX =
    AssetProperty_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    AssetProperty_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return AssetProperty_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return AssetProperty_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return AssetProperty_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string issuer = 2;
  bool has_issuer() const;
  void clear_issuer();
  static const int kIssuerFieldNumber = 2;
  const ::std::string& issuer() const;
  void set_issuer(const ::std::string& value);
  #if LANG_CXX11
  void set_issuer(::std::string&& value);
  #endif
  void set_issuer(const char* value);
  void set_issuer(const char* value, size_t size);
  ::std::string* mutable_issuer();
  ::std::string* release_issuer();
  void set_allocated_issuer(::std::string* issuer);

  // required string code = 3;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 3;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // required .protocol.AssetProperty.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::protocol::AssetProperty_Type type() const;
  void set_type(::protocol::AssetProperty_Type value);

  // @@protoc_insertion_point(class_scope:protocol.AssetProperty)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_issuer();
  void clear_has_issuer();
  void set_has_code();
  void clear_has_code();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr issuer_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  int type_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Detail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Detail) */ {
 public:
  Detail();
  virtual ~Detail();

  Detail(const Detail& from);

  inline Detail& operator=(const Detail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Detail& default_instance();

  static inline const Detail* internal_default_instance() {
    return reinterpret_cast<const Detail*>(
               &_Detail_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(Detail* other);

  // implements Message ----------------------------------------------

  inline Detail* New() const PROTOBUF_FINAL { return New(NULL); }

  Detail* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Detail& from);
  void MergeFrom(const Detail& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Detail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ext = 4;
  bool has_ext() const;
  void clear_ext();
  static const int kExtFieldNumber = 4;
  const ::std::string& ext() const;
  void set_ext(const ::std::string& value);
  #if LANG_CXX11
  void set_ext(::std::string&& value);
  #endif
  void set_ext(const char* value);
  void set_ext(const char* value, size_t size);
  ::std::string* mutable_ext();
  ::std::string* release_ext();
  void set_allocated_ext(::std::string* ext);

  // required int64 amount = 1;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 1;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // required int64 start = 2;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 2;
  ::google::protobuf::int64 start() const;
  void set_start(::google::protobuf::int64 value);

  // required int64 length = 3;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 3;
  ::google::protobuf::int64 length() const;
  void set_length(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Detail)
 private:
  void set_has_amount();
  void clear_has_amount();
  void set_has_start();
  void clear_has_start();
  void set_has_length();
  void clear_has_length();
  void set_has_ext();
  void clear_has_ext();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ext_;
  ::google::protobuf::int64 amount_;
  ::google::protobuf::int64 start_;
  ::google::protobuf::int64 length_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Asset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Asset) */ {
 public:
  Asset();
  virtual ~Asset();

  Asset(const Asset& from);

  inline Asset& operator=(const Asset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Asset& default_instance();

  static inline const Asset* internal_default_instance() {
    return reinterpret_cast<const Asset*>(
               &_Asset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(Asset* other);

  // implements Message ----------------------------------------------

  inline Asset* New() const PROTOBUF_FINAL { return New(NULL); }

  Asset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Asset& from);
  void MergeFrom(const Asset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Asset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Detail details = 3;
  int details_size() const;
  void clear_details();
  static const int kDetailsFieldNumber = 3;
  const ::protocol::Detail& details(int index) const;
  ::protocol::Detail* mutable_details(int index);
  ::protocol::Detail* add_details();
  ::google::protobuf::RepeatedPtrField< ::protocol::Detail >*
      mutable_details();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Detail >&
      details() const;

  // required .protocol.AssetProperty property = 1;
  bool has_property() const;
  void clear_property();
  static const int kPropertyFieldNumber = 1;
  const ::protocol::AssetProperty& property() const;
  ::protocol::AssetProperty* mutable_property();
  ::protocol::AssetProperty* release_property();
  void set_allocated_property(::protocol::AssetProperty* property);

  // required int64 amount = 2;
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int64 amount() const;
  void set_amount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Asset)
 private:
  void set_has_property();
  void clear_has_property();
  void set_has_amount();
  void clear_has_amount();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Detail > details_;
  ::protocol::AssetProperty* property_;
  ::google::protobuf::int64 amount_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationCreateAccount : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationCreateAccount) */ {
 public:
  OperationCreateAccount();
  virtual ~OperationCreateAccount();

  OperationCreateAccount(const OperationCreateAccount& from);

  inline OperationCreateAccount& operator=(const OperationCreateAccount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationCreateAccount& default_instance();

  static inline const OperationCreateAccount* internal_default_instance() {
    return reinterpret_cast<const OperationCreateAccount*>(
               &_OperationCreateAccount_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(OperationCreateAccount* other);

  // implements Message ----------------------------------------------

  inline OperationCreateAccount* New() const PROTOBUF_FINAL { return New(NULL); }

  OperationCreateAccount* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationCreateAccount& from);
  void MergeFrom(const OperationCreateAccount& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationCreateAccount* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Signer signers = 4;
  int signers_size() const;
  void clear_signers();
  static const int kSignersFieldNumber = 4;
  const ::protocol::Signer& signers(int index) const;
  ::protocol::Signer* mutable_signers(int index);
  ::protocol::Signer* add_signers();
  ::google::protobuf::RepeatedPtrField< ::protocol::Signer >*
      mutable_signers();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Signer >&
      signers() const;

  // required string dest_address = 1;
  bool has_dest_address() const;
  void clear_dest_address();
  static const int kDestAddressFieldNumber = 1;
  const ::std::string& dest_address() const;
  void set_dest_address(const ::std::string& value);
  #if LANG_CXX11
  void set_dest_address(::std::string&& value);
  #endif
  void set_dest_address(const char* value);
  void set_dest_address(const char* value, size_t size);
  ::std::string* mutable_dest_address();
  ::std::string* release_dest_address();
  void set_allocated_dest_address(::std::string* dest_address);

  // optional bytes account_metadata = 5;
  bool has_account_metadata() const;
  void clear_account_metadata();
  static const int kAccountMetadataFieldNumber = 5;
  const ::std::string& account_metadata() const;
  void set_account_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_account_metadata(::std::string&& value);
  #endif
  void set_account_metadata(const char* value);
  void set_account_metadata(const void* value, size_t size);
  ::std::string* mutable_account_metadata();
  ::std::string* release_account_metadata();
  void set_allocated_account_metadata(::std::string* account_metadata);

  // optional .protocol.AccountThreshold thresholds = 3;
  bool has_thresholds() const;
  void clear_thresholds();
  static const int kThresholdsFieldNumber = 3;
  const ::protocol::AccountThreshold& thresholds() const;
  ::protocol::AccountThreshold* mutable_thresholds();
  ::protocol::AccountThreshold* release_thresholds();
  void set_allocated_thresholds(::protocol::AccountThreshold* thresholds);

  // required int64 init_balance = 2;
  bool has_init_balance() const;
  void clear_init_balance();
  static const int kInitBalanceFieldNumber = 2;
  ::google::protobuf::int64 init_balance() const;
  void set_init_balance(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.OperationCreateAccount)
 private:
  void set_has_dest_address();
  void clear_has_dest_address();
  void set_has_init_balance();
  void clear_has_init_balance();
  void set_has_thresholds();
  void clear_has_thresholds();
  void set_has_account_metadata();
  void clear_has_account_metadata();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Signer > signers_;
  ::google::protobuf::internal::ArenaStringPtr dest_address_;
  ::google::protobuf::internal::ArenaStringPtr account_metadata_;
  ::protocol::AccountThreshold* thresholds_;
  ::google::protobuf::int64 init_balance_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationPayment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationPayment) */ {
 public:
  OperationPayment();
  virtual ~OperationPayment();

  OperationPayment(const OperationPayment& from);

  inline OperationPayment& operator=(const OperationPayment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationPayment& default_instance();

  static inline const OperationPayment* internal_default_instance() {
    return reinterpret_cast<const OperationPayment*>(
               &_OperationPayment_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(OperationPayment* other);

  // implements Message ----------------------------------------------

  inline OperationPayment* New() const PROTOBUF_FINAL { return New(NULL); }

  OperationPayment* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationPayment& from);
  void MergeFrom(const OperationPayment& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationPayment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string destAddress = 1;
  bool has_destaddress() const;
  void clear_destaddress();
  static const int kDestAddressFieldNumber = 1;
  const ::std::string& destaddress() const;
  void set_destaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_destaddress(::std::string&& value);
  #endif
  void set_destaddress(const char* value);
  void set_destaddress(const char* value, size_t size);
  ::std::string* mutable_destaddress();
  ::std::string* release_destaddress();
  void set_allocated_destaddress(::std::string* destaddress);

  // required .protocol.Asset asset = 2;
  bool has_asset() const;
  void clear_asset();
  static const int kAssetFieldNumber = 2;
  const ::protocol::Asset& asset() const;
  ::protocol::Asset* mutable_asset();
  ::protocol::Asset* release_asset();
  void set_allocated_asset(::protocol::Asset* asset);

  // @@protoc_insertion_point(class_scope:protocol.OperationPayment)
 private:
  void set_has_destaddress();
  void clear_has_destaddress();
  void set_has_asset();
  void clear_has_asset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr destaddress_;
  ::protocol::Asset* asset_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationInitPayment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationInitPayment) */ {
 public:
  OperationInitPayment();
  virtual ~OperationInitPayment();

  OperationInitPayment(const OperationInitPayment& from);

  inline OperationInitPayment& operator=(const OperationInitPayment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationInitPayment& default_instance();

  static inline const OperationInitPayment* internal_default_instance() {
    return reinterpret_cast<const OperationInitPayment*>(
               &_OperationInitPayment_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(OperationInitPayment* other);

  // implements Message ----------------------------------------------

  inline OperationInitPayment* New() const PROTOBUF_FINAL { return New(NULL); }

  OperationInitPayment* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationInitPayment& from);
  void MergeFrom(const OperationInitPayment& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationInitPayment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string destAddress = 1;
  bool has_destaddress() const;
  void clear_destaddress();
  static const int kDestAddressFieldNumber = 1;
  const ::std::string& destaddress() const;
  void set_destaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_destaddress(::std::string&& value);
  #endif
  void set_destaddress(const char* value);
  void set_destaddress(const char* value, size_t size);
  ::std::string* mutable_destaddress();
  ::std::string* release_destaddress();
  void set_allocated_destaddress(::std::string* destaddress);

  // required .protocol.Asset asset = 2;
  bool has_asset() const;
  void clear_asset();
  static const int kAssetFieldNumber = 2;
  const ::protocol::Asset& asset() const;
  ::protocol::Asset* mutable_asset();
  ::protocol::Asset* release_asset();
  void set_allocated_asset(::protocol::Asset* asset);

  // @@protoc_insertion_point(class_scope:protocol.OperationInitPayment)
 private:
  void set_has_destaddress();
  void clear_has_destaddress();
  void set_has_asset();
  void clear_has_asset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr destaddress_;
  ::protocol::Asset* asset_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationIssueAsset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationIssueAsset) */ {
 public:
  OperationIssueAsset();
  virtual ~OperationIssueAsset();

  OperationIssueAsset(const OperationIssueAsset& from);

  inline OperationIssueAsset& operator=(const OperationIssueAsset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationIssueAsset& default_instance();

  static inline const OperationIssueAsset* internal_default_instance() {
    return reinterpret_cast<const OperationIssueAsset*>(
               &_OperationIssueAsset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(OperationIssueAsset* other);

  // implements Message ----------------------------------------------

  inline OperationIssueAsset* New() const PROTOBUF_FINAL { return New(NULL); }

  OperationIssueAsset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationIssueAsset& from);
  void MergeFrom(const OperationIssueAsset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationIssueAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.Asset asset = 1;
  bool has_asset() const;
  void clear_asset();
  static const int kAssetFieldNumber = 1;
  const ::protocol::Asset& asset() const;
  ::protocol::Asset* mutable_asset();
  ::protocol::Asset* release_asset();
  void set_allocated_asset(::protocol::Asset* asset);

  // @@protoc_insertion_point(class_scope:protocol.OperationIssueAsset)
 private:
  void set_has_asset();
  void clear_has_asset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::Asset* asset_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UniqueAsset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.UniqueAsset) */ {
 public:
  UniqueAsset();
  virtual ~UniqueAsset();

  UniqueAsset(const UniqueAsset& from);

  inline UniqueAsset& operator=(const UniqueAsset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UniqueAsset& default_instance();

  static inline const UniqueAsset* internal_default_instance() {
    return reinterpret_cast<const UniqueAsset*>(
               &_UniqueAsset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(UniqueAsset* other);

  // implements Message ----------------------------------------------

  inline UniqueAsset* New() const PROTOBUF_FINAL { return New(NULL); }

  UniqueAsset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UniqueAsset& from);
  void MergeFrom(const UniqueAsset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UniqueAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes detailed = 2;
  bool has_detailed() const;
  void clear_detailed();
  static const int kDetailedFieldNumber = 2;
  const ::std::string& detailed() const;
  void set_detailed(const ::std::string& value);
  #if LANG_CXX11
  void set_detailed(::std::string&& value);
  #endif
  void set_detailed(const char* value);
  void set_detailed(const void* value, size_t size);
  ::std::string* mutable_detailed();
  ::std::string* release_detailed();
  void set_allocated_detailed(::std::string* detailed);

  // required .protocol.AssetProperty property = 1;
  bool has_property() const;
  void clear_property();
  static const int kPropertyFieldNumber = 1;
  const ::protocol::AssetProperty& property() const;
  ::protocol::AssetProperty* mutable_property();
  ::protocol::AssetProperty* release_property();
  void set_allocated_property(::protocol::AssetProperty* property);

  // @@protoc_insertion_point(class_scope:protocol.UniqueAsset)
 private:
  void set_has_property();
  void clear_has_property();
  void set_has_detailed();
  void clear_has_detailed();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr detailed_;
  ::protocol::AssetProperty* property_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationPaymentUniqueAsset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationPaymentUniqueAsset) */ {
 public:
  OperationPaymentUniqueAsset();
  virtual ~OperationPaymentUniqueAsset();

  OperationPaymentUniqueAsset(const OperationPaymentUniqueAsset& from);

  inline OperationPaymentUniqueAsset& operator=(const OperationPaymentUniqueAsset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationPaymentUniqueAsset& default_instance();

  static inline const OperationPaymentUniqueAsset* internal_default_instance() {
    return reinterpret_cast<const OperationPaymentUniqueAsset*>(
               &_OperationPaymentUniqueAsset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(OperationPaymentUniqueAsset* other);

  // implements Message ----------------------------------------------

  inline OperationPaymentUniqueAsset* New() const PROTOBUF_FINAL { return New(NULL); }

  OperationPaymentUniqueAsset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationPaymentUniqueAsset& from);
  void MergeFrom(const OperationPaymentUniqueAsset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationPaymentUniqueAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string destAddress = 1;
  bool has_destaddress() const;
  void clear_destaddress();
  static const int kDestAddressFieldNumber = 1;
  const ::std::string& destaddress() const;
  void set_destaddress(const ::std::string& value);
  #if LANG_CXX11
  void set_destaddress(::std::string&& value);
  #endif
  void set_destaddress(const char* value);
  void set_destaddress(const char* value, size_t size);
  ::std::string* mutable_destaddress();
  ::std::string* release_destaddress();
  void set_allocated_destaddress(::std::string* destaddress);

  // required .protocol.AssetProperty asset_pro = 2;
  bool has_asset_pro() const;
  void clear_asset_pro();
  static const int kAssetProFieldNumber = 2;
  const ::protocol::AssetProperty& asset_pro() const;
  ::protocol::AssetProperty* mutable_asset_pro();
  ::protocol::AssetProperty* release_asset_pro();
  void set_allocated_asset_pro(::protocol::AssetProperty* asset_pro);

  // @@protoc_insertion_point(class_scope:protocol.OperationPaymentUniqueAsset)
 private:
  void set_has_destaddress();
  void clear_has_destaddress();
  void set_has_asset_pro();
  void clear_has_asset_pro();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr destaddress_;
  ::protocol::AssetProperty* asset_pro_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationRecord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationRecord) */ {
 public:
  OperationRecord();
  virtual ~OperationRecord();

  OperationRecord(const OperationRecord& from);

  inline OperationRecord& operator=(const OperationRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationRecord& default_instance();

  static inline const OperationRecord* internal_default_instance() {
    return reinterpret_cast<const OperationRecord*>(
               &_OperationRecord_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(OperationRecord* other);

  // implements Message ----------------------------------------------

  inline OperationRecord* New() const PROTOBUF_FINAL { return New(NULL); }

  OperationRecord* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationRecord& from);
  void MergeFrom(const OperationRecord& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationRecord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // required string id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required bytes ext = 3;
  bool has_ext() const;
  void clear_ext();
  static const int kExtFieldNumber = 3;
  const ::std::string& ext() const;
  void set_ext(const ::std::string& value);
  #if LANG_CXX11
  void set_ext(::std::string&& value);
  #endif
  void set_ext(const char* value);
  void set_ext(const void* value, size_t size);
  ::std::string* mutable_ext();
  ::std::string* release_ext();
  void set_allocated_ext(::std::string* ext);

  // @@protoc_insertion_point(class_scope:protocol.OperationRecord)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_id();
  void clear_has_id();
  void set_has_ext();
  void clear_has_ext();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr ext_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationIssueUniqueAsset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationIssueUniqueAsset) */ {
 public:
  OperationIssueUniqueAsset();
  virtual ~OperationIssueUniqueAsset();

  OperationIssueUniqueAsset(const OperationIssueUniqueAsset& from);

  inline OperationIssueUniqueAsset& operator=(const OperationIssueUniqueAsset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationIssueUniqueAsset& default_instance();

  static inline const OperationIssueUniqueAsset* internal_default_instance() {
    return reinterpret_cast<const OperationIssueUniqueAsset*>(
               &_OperationIssueUniqueAsset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(OperationIssueUniqueAsset* other);

  // implements Message ----------------------------------------------

  inline OperationIssueUniqueAsset* New() const PROTOBUF_FINAL { return New(NULL); }

  OperationIssueUniqueAsset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationIssueUniqueAsset& from);
  void MergeFrom(const OperationIssueUniqueAsset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationIssueUniqueAsset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.UniqueAsset asset = 1;
  bool has_asset() const;
  void clear_asset();
  static const int kAssetFieldNumber = 1;
  const ::protocol::UniqueAsset& asset() const;
  ::protocol::UniqueAsset* mutable_asset();
  ::protocol::UniqueAsset* release_asset();
  void set_allocated_asset(::protocol::UniqueAsset* asset);

  // @@protoc_insertion_point(class_scope:protocol.OperationIssueUniqueAsset)
 private:
  void set_has_asset();
  void clear_has_asset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::UniqueAsset* asset_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationSetOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationSetOptions) */ {
 public:
  OperationSetOptions();
  virtual ~OperationSetOptions();

  OperationSetOptions(const OperationSetOptions& from);

  inline OperationSetOptions& operator=(const OperationSetOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationSetOptions& default_instance();

  static inline const OperationSetOptions* internal_default_instance() {
    return reinterpret_cast<const OperationSetOptions*>(
               &_OperationSetOptions_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(OperationSetOptions* other);

  // implements Message ----------------------------------------------

  inline OperationSetOptions* New() const PROTOBUF_FINAL { return New(NULL); }

  OperationSetOptions* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationSetOptions& from);
  void MergeFrom(const OperationSetOptions& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationSetOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Signer signers = 5;
  int signers_size() const;
  void clear_signers();
  static const int kSignersFieldNumber = 5;
  const ::protocol::Signer& signers(int index) const;
  ::protocol::Signer* mutable_signers(int index);
  ::protocol::Signer* add_signers();
  ::google::protobuf::RepeatedPtrField< ::protocol::Signer >*
      mutable_signers();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Signer >&
      signers() const;

  // optional bytes account_metadata = 6;
  bool has_account_metadata() const;
  void clear_account_metadata();
  static const int kAccountMetadataFieldNumber = 6;
  const ::std::string& account_metadata() const;
  void set_account_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_account_metadata(::std::string&& value);
  #endif
  void set_account_metadata(const char* value);
  void set_account_metadata(const void* value, size_t size);
  ::std::string* mutable_account_metadata();
  ::std::string* release_account_metadata();
  void set_allocated_account_metadata(::std::string* account_metadata);

  // optional uint32 master_weight = 1;
  bool has_master_weight() const;
  void clear_master_weight();
  static const int kMasterWeightFieldNumber = 1;
  ::google::protobuf::uint32 master_weight() const;
  void set_master_weight(::google::protobuf::uint32 value);

  // optional uint32 low_threshold = 2;
  bool has_low_threshold() const;
  void clear_low_threshold();
  static const int kLowThresholdFieldNumber = 2;
  ::google::protobuf::uint32 low_threshold() const;
  void set_low_threshold(::google::protobuf::uint32 value);

  // optional uint32 med_threshold = 3;
  bool has_med_threshold() const;
  void clear_med_threshold();
  static const int kMedThresholdFieldNumber = 3;
  ::google::protobuf::uint32 med_threshold() const;
  void set_med_threshold(::google::protobuf::uint32 value);

  // optional uint32 high_threshold = 4;
  bool has_high_threshold() const;
  void clear_high_threshold();
  static const int kHighThresholdFieldNumber = 4;
  ::google::protobuf::uint32 high_threshold() const;
  void set_high_threshold(::google::protobuf::uint32 value);

  // optional int64 account_metadata_version = 7;
  bool has_account_metadata_version() const;
  void clear_account_metadata_version();
  static const int kAccountMetadataVersionFieldNumber = 7;
  ::google::protobuf::int64 account_metadata_version() const;
  void set_account_metadata_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.OperationSetOptions)
 private:
  void set_has_master_weight();
  void clear_has_master_weight();
  void set_has_low_threshold();
  void clear_has_low_threshold();
  void set_has_med_threshold();
  void clear_has_med_threshold();
  void set_has_high_threshold();
  void clear_has_high_threshold();
  void set_has_account_metadata();
  void clear_has_account_metadata();
  void set_has_account_metadata_version();
  void clear_has_account_metadata_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Signer > signers_;
  ::google::protobuf::internal::ArenaStringPtr account_metadata_;
  ::google::protobuf::uint32 master_weight_;
  ::google::protobuf::uint32 low_threshold_;
  ::google::protobuf::uint32 med_threshold_;
  ::google::protobuf::uint32 high_threshold_;
  ::google::protobuf::int64 account_metadata_version_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Input) */ {
 public:
  Input();
  virtual ~Input();

  Input(const Input& from);

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input& default_instance();

  static inline const Input* internal_default_instance() {
    return reinterpret_cast<const Input*>(
               &_Input_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(Input* other);

  // implements Message ----------------------------------------------

  inline Input* New() const PROTOBUF_FINAL { return New(NULL); }

  Input* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Input& from);
  void MergeFrom(const Input& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes hash = 1;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional bytes metadata = 3;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // required int64 index = 2;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int64 index() const;
  void set_index(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.Input)
 private:
  void set_has_hash();
  void clear_has_hash();
  void set_has_index();
  void clear_has_index();
  void set_has_metadata();
  void clear_has_metadata();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::google::protobuf::int64 index_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Output) */ {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();

  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(Output* other);

  // implements Message ----------------------------------------------

  inline Output* New() const PROTOBUF_FINAL { return New(NULL); }

  Output* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional bytes metadata = 2;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // @@protoc_insertion_point(class_scope:protocol.Output)
 private:
  void set_has_address();
  void clear_has_address();
  void set_has_metadata();
  void clear_has_metadata();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationProduction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationProduction) */ {
 public:
  OperationProduction();
  virtual ~OperationProduction();

  OperationProduction(const OperationProduction& from);

  inline OperationProduction& operator=(const OperationProduction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationProduction& default_instance();

  static inline const OperationProduction* internal_default_instance() {
    return reinterpret_cast<const OperationProduction*>(
               &_OperationProduction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(OperationProduction* other);

  // implements Message ----------------------------------------------

  inline OperationProduction* New() const PROTOBUF_FINAL { return New(NULL); }

  OperationProduction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationProduction& from);
  void MergeFrom(const OperationProduction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationProduction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Input inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  const ::protocol::Input& inputs(int index) const;
  ::protocol::Input* mutable_inputs(int index);
  ::protocol::Input* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::protocol::Input >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Input >&
      inputs() const;

  // repeated .protocol.Output outputs = 2;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  const ::protocol::Output& outputs(int index) const;
  ::protocol::Output* mutable_outputs(int index);
  ::protocol::Output* add_outputs();
  ::google::protobuf::RepeatedPtrField< ::protocol::Output >*
      mutable_outputs();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Output >&
      outputs() const;

  // @@protoc_insertion_point(class_scope:protocol.OperationProduction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Input > inputs_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Output > outputs_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperationManageOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.OperationManageOrder) */ {
 public:
  OperationManageOrder();
  virtual ~OperationManageOrder();

  OperationManageOrder(const OperationManageOrder& from);

  inline OperationManageOrder& operator=(const OperationManageOrder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationManageOrder& default_instance();

  static inline const OperationManageOrder* internal_default_instance() {
    return reinterpret_cast<const OperationManageOrder*>(
               &_OperationManageOrder_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(OperationManageOrder* other);

  // implements Message ----------------------------------------------

  inline OperationManageOrder* New() const PROTOBUF_FINAL { return New(NULL); }

  OperationManageOrder* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OperationManageOrder& from);
  void MergeFrom(const OperationManageOrder& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OperationManageOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protocol.OperationManageOrder)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Operation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Operation) */ {
 public:
  Operation();
  virtual ~Operation();

  Operation(const Operation& from);

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation& default_instance();

  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(Operation* other);

  // implements Message ----------------------------------------------

  inline Operation* New() const PROTOBUF_FINAL { return New(NULL); }

  Operation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Operation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Operation_Type Type;
  static const Type CREATE_ACCOUNT =
    Operation_Type_CREATE_ACCOUNT;
  static const Type PAYMENT =
    Operation_Type_PAYMENT;
  static const Type ISSUE_ASSET =
    Operation_Type_ISSUE_ASSET;
  static const Type SET_OPTIONS =
    Operation_Type_SET_OPTIONS;
  static const Type INIT_PAYMENT =
    Operation_Type_INIT_PAYMENT;
  static const Type PRODUCTION =
    Operation_Type_PRODUCTION;
  static const Type ISSUE_UNIQUE_ASSET =
    Operation_Type_ISSUE_UNIQUE_ASSET;
  static const Type PAYMENT_UNIQUE_ASSET =
    Operation_Type_PAYMENT_UNIQUE_ASSET;
  static const Type RECORD =
    Operation_Type_RECORD;
  static inline bool Type_IsValid(int value) {
    return Operation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Operation_Type_Type_MIN;
  static const Type Type_MAX =
    Operation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Operation_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Operation_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Operation_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Operation_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string source_address = 2;
  bool has_source_address() const;
  void clear_source_address();
  static const int kSourceAddressFieldNumber = 2;
  const ::std::string& source_address() const;
  void set_source_address(const ::std::string& value);
  #if LANG_CXX11
  void set_source_address(::std::string&& value);
  #endif
  void set_source_address(const char* value);
  void set_source_address(const char* value, size_t size);
  ::std::string* mutable_source_address();
  ::std::string* release_source_address();
  void set_allocated_source_address(::std::string* source_address);

  // optional bytes metadata = 10;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 10;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // optional .protocol.OperationCreateAccount create_account = 3;
  bool has_create_account() const;
  void clear_create_account();
  static const int kCreateAccountFieldNumber = 3;
  const ::protocol::OperationCreateAccount& create_account() const;
  ::protocol::OperationCreateAccount* mutable_create_account();
  ::protocol::OperationCreateAccount* release_create_account();
  void set_allocated_create_account(::protocol::OperationCreateAccount* create_account);

  // optional .protocol.OperationPayment payment = 4;
  bool has_payment() const;
  void clear_payment();
  static const int kPaymentFieldNumber = 4;
  const ::protocol::OperationPayment& payment() const;
  ::protocol::OperationPayment* mutable_payment();
  ::protocol::OperationPayment* release_payment();
  void set_allocated_payment(::protocol::OperationPayment* payment);

  // optional .protocol.OperationIssueAsset issue_asset = 5;
  bool has_issue_asset() const;
  void clear_issue_asset();
  static const int kIssueAssetFieldNumber = 5;
  const ::protocol::OperationIssueAsset& issue_asset() const;
  ::protocol::OperationIssueAsset* mutable_issue_asset();
  ::protocol::OperationIssueAsset* release_issue_asset();
  void set_allocated_issue_asset(::protocol::OperationIssueAsset* issue_asset);

  // optional .protocol.OperationSetOptions setoptions = 6;
  bool has_setoptions() const;
  void clear_setoptions();
  static const int kSetoptionsFieldNumber = 6;
  const ::protocol::OperationSetOptions& setoptions() const;
  ::protocol::OperationSetOptions* mutable_setoptions();
  ::protocol::OperationSetOptions* release_setoptions();
  void set_allocated_setoptions(::protocol::OperationSetOptions* setoptions);

  // optional .protocol.OperationManageOrder manage_order = 7;
  bool has_manage_order() const;
  void clear_manage_order();
  static const int kManageOrderFieldNumber = 7;
  const ::protocol::OperationManageOrder& manage_order() const;
  ::protocol::OperationManageOrder* mutable_manage_order();
  ::protocol::OperationManageOrder* release_manage_order();
  void set_allocated_manage_order(::protocol::OperationManageOrder* manage_order);

  // optional .protocol.OperationInitPayment init_payment = 8;
  bool has_init_payment() const;
  void clear_init_payment();
  static const int kInitPaymentFieldNumber = 8;
  const ::protocol::OperationInitPayment& init_payment() const;
  ::protocol::OperationInitPayment* mutable_init_payment();
  ::protocol::OperationInitPayment* release_init_payment();
  void set_allocated_init_payment(::protocol::OperationInitPayment* init_payment);

  // optional .protocol.OperationProduction production = 9;
  bool has_production() const;
  void clear_production();
  static const int kProductionFieldNumber = 9;
  const ::protocol::OperationProduction& production() const;
  ::protocol::OperationProduction* mutable_production();
  ::protocol::OperationProduction* release_production();
  void set_allocated_production(::protocol::OperationProduction* production);

  // optional .protocol.OperationRecord record = 11;
  bool has_record() const;
  void clear_record();
  static const int kRecordFieldNumber = 11;
  const ::protocol::OperationRecord& record() const;
  ::protocol::OperationRecord* mutable_record();
  ::protocol::OperationRecord* release_record();
  void set_allocated_record(::protocol::OperationRecord* record);

  // optional .protocol.OperationIssueUniqueAsset issue_unique_asset = 12;
  bool has_issue_unique_asset() const;
  void clear_issue_unique_asset();
  static const int kIssueUniqueAssetFieldNumber = 12;
  const ::protocol::OperationIssueUniqueAsset& issue_unique_asset() const;
  ::protocol::OperationIssueUniqueAsset* mutable_issue_unique_asset();
  ::protocol::OperationIssueUniqueAsset* release_issue_unique_asset();
  void set_allocated_issue_unique_asset(::protocol::OperationIssueUniqueAsset* issue_unique_asset);

  // optional .protocol.OperationPaymentUniqueAsset payment_unique_asset = 13;
  bool has_payment_unique_asset() const;
  void clear_payment_unique_asset();
  static const int kPaymentUniqueAssetFieldNumber = 13;
  const ::protocol::OperationPaymentUniqueAsset& payment_unique_asset() const;
  ::protocol::OperationPaymentUniqueAsset* mutable_payment_unique_asset();
  ::protocol::OperationPaymentUniqueAsset* release_payment_unique_asset();
  void set_allocated_payment_unique_asset(::protocol::OperationPaymentUniqueAsset* payment_unique_asset);

  // required .protocol.Operation.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::protocol::Operation_Type type() const;
  void set_type(::protocol::Operation_Type value);

  // @@protoc_insertion_point(class_scope:protocol.Operation)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_source_address();
  void clear_has_source_address();
  void set_has_create_account();
  void clear_has_create_account();
  void set_has_payment();
  void clear_has_payment();
  void set_has_issue_asset();
  void clear_has_issue_asset();
  void set_has_setoptions();
  void clear_has_setoptions();
  void set_has_manage_order();
  void clear_has_manage_order();
  void set_has_init_payment();
  void clear_has_init_payment();
  void set_has_production();
  void clear_has_production();
  void set_has_metadata();
  void clear_has_metadata();
  void set_has_record();
  void clear_has_record();
  void set_has_issue_unique_asset();
  void clear_has_issue_unique_asset();
  void set_has_payment_unique_asset();
  void clear_has_payment_unique_asset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr source_address_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::protocol::OperationCreateAccount* create_account_;
  ::protocol::OperationPayment* payment_;
  ::protocol::OperationIssueAsset* issue_asset_;
  ::protocol::OperationSetOptions* setoptions_;
  ::protocol::OperationManageOrder* manage_order_;
  ::protocol::OperationInitPayment* init_payment_;
  ::protocol::OperationProduction* production_;
  ::protocol::OperationRecord* record_;
  ::protocol::OperationIssueUniqueAsset* issue_unique_asset_;
  ::protocol::OperationPaymentUniqueAsset* payment_unique_asset_;
  int type_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(Transaction* other);

  // implements Message ----------------------------------------------

  inline Transaction* New() const PROTOBUF_FINAL { return New(NULL); }

  Transaction* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Transaction_Limit Limit;
  static const Limit OPERATIONS =
    Transaction_Limit_OPERATIONS;
  static inline bool Limit_IsValid(int value) {
    return Transaction_Limit_IsValid(value);
  }
  static const Limit Limit_MIN =
    Transaction_Limit_Limit_MIN;
  static const Limit Limit_MAX =
    Transaction_Limit_Limit_MAX;
  static const int Limit_ARRAYSIZE =
    Transaction_Limit_Limit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Limit_descriptor() {
    return Transaction_Limit_descriptor();
  }
  static inline const ::std::string& Limit_Name(Limit value) {
    return Transaction_Limit_Name(value);
  }
  static inline bool Limit_Parse(const ::std::string& name,
      Limit* value) {
    return Transaction_Limit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .protocol.Operation operations = 5;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 5;
  const ::protocol::Operation& operations(int index) const;
  ::protocol::Operation* mutable_operations(int index);
  ::protocol::Operation* add_operations();
  ::google::protobuf::RepeatedPtrField< ::protocol::Operation >*
      mutable_operations();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Operation >&
      operations() const;

  // required string source_address = 1;
  bool has_source_address() const;
  void clear_source_address();
  static const int kSourceAddressFieldNumber = 1;
  const ::std::string& source_address() const;
  void set_source_address(const ::std::string& value);
  #if LANG_CXX11
  void set_source_address(::std::string&& value);
  #endif
  void set_source_address(const char* value);
  void set_source_address(const char* value, size_t size);
  ::std::string* mutable_source_address();
  ::std::string* release_source_address();
  void set_allocated_source_address(::std::string* source_address);

  // optional bytes metadata = 6;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 6;
  const ::std::string& metadata() const;
  void set_metadata(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata(::std::string&& value);
  #endif
  void set_metadata(const char* value);
  void set_metadata(const void* value, size_t size);
  ::std::string* mutable_metadata();
  ::std::string* release_metadata();
  void set_allocated_metadata(::std::string* metadata);

  // optional .protocol.CloseTimeRange close_time_range = 4;
  bool has_close_time_range() const;
  void clear_close_time_range();
  static const int kCloseTimeRangeFieldNumber = 4;
  const ::protocol::CloseTimeRange& close_time_range() const;
  ::protocol::CloseTimeRange* mutable_close_time_range();
  ::protocol::CloseTimeRange* release_close_time_range();
  void set_allocated_close_time_range(::protocol::CloseTimeRange* close_time_range);

  // required int64 sequence_number = 3;
  bool has_sequence_number() const;
  void clear_sequence_number();
  static const int kSequenceNumberFieldNumber = 3;
  ::google::protobuf::int64 sequence_number() const;
  void set_sequence_number(::google::protobuf::int64 value);

  // required uint32 fee = 2;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 2;
  ::google::protobuf::uint32 fee() const;
  void set_fee(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.Transaction)
 private:
  void set_has_source_address();
  void clear_has_source_address();
  void set_has_fee();
  void clear_has_fee();
  void set_has_sequence_number();
  void clear_has_sequence_number();
  void set_has_close_time_range();
  void clear_has_close_time_range();
  void set_has_metadata();
  void clear_has_metadata();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Operation > operations_;
  ::google::protobuf::internal::ArenaStringPtr source_address_;
  ::google::protobuf::internal::ArenaStringPtr metadata_;
  ::protocol::CloseTimeRange* close_time_range_;
  ::google::protobuf::int64 sequence_number_;
  ::google::protobuf::uint32 fee_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Signature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Signature) */ {
 public:
  Signature();
  virtual ~Signature();

  Signature(const Signature& from);

  inline Signature& operator=(const Signature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Signature& default_instance();

  static inline const Signature* internal_default_instance() {
    return reinterpret_cast<const Signature*>(
               &_Signature_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(Signature* other);

  // implements Message ----------------------------------------------

  inline Signature* New() const PROTOBUF_FINAL { return New(NULL); }

  Signature* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Signature& from);
  void MergeFrom(const Signature& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Signature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string public_key = 1;
  bool has_public_key() const;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // required bytes sign_data = 2;
  bool has_sign_data() const;
  void clear_sign_data();
  static const int kSignDataFieldNumber = 2;
  const ::std::string& sign_data() const;
  void set_sign_data(const ::std::string& value);
  #if LANG_CXX11
  void set_sign_data(::std::string&& value);
  #endif
  void set_sign_data(const char* value);
  void set_sign_data(const void* value, size_t size);
  ::std::string* mutable_sign_data();
  ::std::string* release_sign_data();
  void set_allocated_sign_data(::std::string* sign_data);

  // @@protoc_insertion_point(class_scope:protocol.Signature)
 private:
  void set_has_public_key();
  void clear_has_public_key();
  void set_has_sign_data();
  void clear_has_sign_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr sign_data_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransactionEnv : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionEnv) */ {
 public:
  TransactionEnv();
  virtual ~TransactionEnv();

  TransactionEnv(const TransactionEnv& from);

  inline TransactionEnv& operator=(const TransactionEnv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionEnv& default_instance();

  static inline const TransactionEnv* internal_default_instance() {
    return reinterpret_cast<const TransactionEnv*>(
               &_TransactionEnv_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(TransactionEnv* other);

  // implements Message ----------------------------------------------

  inline TransactionEnv* New() const PROTOBUF_FINAL { return New(NULL); }

  TransactionEnv* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransactionEnv& from);
  void MergeFrom(const TransactionEnv& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransactionEnv* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef TransactionEnv_Limit Limit;
  static const Limit SIGNATURE =
    TransactionEnv_Limit_SIGNATURE;
  static inline bool Limit_IsValid(int value) {
    return TransactionEnv_Limit_IsValid(value);
  }
  static const Limit Limit_MIN =
    TransactionEnv_Limit_Limit_MIN;
  static const Limit Limit_MAX =
    TransactionEnv_Limit_Limit_MAX;
  static const int Limit_ARRAYSIZE =
    TransactionEnv_Limit_Limit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Limit_descriptor() {
    return TransactionEnv_Limit_descriptor();
  }
  static inline const ::std::string& Limit_Name(Limit value) {
    return TransactionEnv_Limit_Name(value);
  }
  static inline bool Limit_Parse(const ::std::string& name,
      Limit* value) {
    return TransactionEnv_Limit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .protocol.Signature signatures = 2;
  int signatures_size() const;
  void clear_signatures();
  static const int kSignaturesFieldNumber = 2;
  const ::protocol::Signature& signatures(int index) const;
  ::protocol::Signature* mutable_signatures(int index);
  ::protocol::Signature* add_signatures();
  ::google::protobuf::RepeatedPtrField< ::protocol::Signature >*
      mutable_signatures();
  const ::google::protobuf::RepeatedPtrField< ::protocol::Signature >&
      signatures() const;

  // required .protocol.Transaction transaction = 1;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 1;
  const ::protocol::Transaction& transaction() const;
  ::protocol::Transaction* mutable_transaction();
  ::protocol::Transaction* release_transaction();
  void set_allocated_transaction(::protocol::Transaction* transaction);

  // @@protoc_insertion_point(class_scope:protocol.TransactionEnv)
 private:
  void set_has_transaction();
  void clear_has_transaction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Signature > signatures_;
  ::protocol::Transaction* transaction_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransactionEnvWrapper : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionEnvWrapper) */ {
 public:
  TransactionEnvWrapper();
  virtual ~TransactionEnvWrapper();

  TransactionEnvWrapper(const TransactionEnvWrapper& from);

  inline TransactionEnvWrapper& operator=(const TransactionEnvWrapper& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionEnvWrapper& default_instance();

  static inline const TransactionEnvWrapper* internal_default_instance() {
    return reinterpret_cast<const TransactionEnvWrapper*>(
               &_TransactionEnvWrapper_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(TransactionEnvWrapper* other);

  // implements Message ----------------------------------------------

  inline TransactionEnvWrapper* New() const PROTOBUF_FINAL { return New(NULL); }

  TransactionEnvWrapper* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransactionEnvWrapper& from);
  void MergeFrom(const TransactionEnvWrapper& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransactionEnvWrapper* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.TransactionEnv transaction_env = 1;
  bool has_transaction_env() const;
  void clear_transaction_env();
  static const int kTransactionEnvFieldNumber = 1;
  const ::protocol::TransactionEnv& transaction_env() const;
  ::protocol::TransactionEnv* mutable_transaction_env();
  ::protocol::TransactionEnv* release_transaction_env();
  void set_allocated_transaction_env(::protocol::TransactionEnv* transaction_env);

  // optional int64 suggest_ledger_seq = 2;
  bool has_suggest_ledger_seq() const;
  void clear_suggest_ledger_seq();
  static const int kSuggestLedgerSeqFieldNumber = 2;
  ::google::protobuf::int64 suggest_ledger_seq() const;
  void set_suggest_ledger_seq(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.TransactionEnvWrapper)
 private:
  void set_has_transaction_env();
  void clear_has_transaction_env();
  void set_has_suggest_ledger_seq();
  void clear_has_suggest_ledger_seq();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::TransactionEnv* transaction_env_;
  ::google::protobuf::int64 suggest_ledger_seq_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransactionEnvStore : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TransactionEnvStore) */ {
 public:
  TransactionEnvStore();
  virtual ~TransactionEnvStore();

  TransactionEnvStore(const TransactionEnvStore& from);

  inline TransactionEnvStore& operator=(const TransactionEnvStore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionEnvStore& default_instance();

  static inline const TransactionEnvStore* internal_default_instance() {
    return reinterpret_cast<const TransactionEnvStore*>(
               &_TransactionEnvStore_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(TransactionEnvStore* other);

  // implements Message ----------------------------------------------

  inline TransactionEnvStore* New() const PROTOBUF_FINAL { return New(NULL); }

  TransactionEnvStore* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TransactionEnvStore& from);
  void MergeFrom(const TransactionEnvStore& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TransactionEnvStore* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes error_desc = 3;
  bool has_error_desc() const;
  void clear_error_desc();
  static const int kErrorDescFieldNumber = 3;
  const ::std::string& error_desc() const;
  void set_error_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_error_desc(::std::string&& value);
  #endif
  void set_error_desc(const char* value);
  void set_error_desc(const void* value, size_t size);
  ::std::string* mutable_error_desc();
  ::std::string* release_error_desc();
  void set_allocated_error_desc(::std::string* error_desc);

  // required .protocol.TransactionEnv transaction_env = 1;
  bool has_transaction_env() const;
  void clear_transaction_env();
  static const int kTransactionEnvFieldNumber = 1;
  const ::protocol::TransactionEnv& transaction_env() const;
  ::protocol::TransactionEnv* mutable_transaction_env();
  ::protocol::TransactionEnv* release_transaction_env();
  void set_allocated_transaction_env(::protocol::TransactionEnv* transaction_env);

  // optional int64 ledger_seq = 4;
  bool has_ledger_seq() const;
  void clear_ledger_seq();
  static const int kLedgerSeqFieldNumber = 4;
  ::google::protobuf::int64 ledger_seq() const;
  void set_ledger_seq(::google::protobuf::int64 value);

  // optional int64 close_time = 5;
  bool has_close_time() const;
  void clear_close_time();
  static const int kCloseTimeFieldNumber = 5;
  ::google::protobuf::int64 close_time() const;
  void set_close_time(::google::protobuf::int64 value);

  // optional int32 error_code = 2;
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.TransactionEnvStore)
 private:
  void set_has_transaction_env();
  void clear_has_transaction_env();
  void set_has_error_code();
  void clear_has_error_code();
  void set_has_error_desc();
  void clear_has_error_desc();
  void set_has_ledger_seq();
  void clear_has_ledger_seq();
  void set_has_close_time();
  void clear_has_close_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_desc_;
  ::protocol::TransactionEnv* transaction_env_;
  ::google::protobuf::int64 ledger_seq_;
  ::google::protobuf::int64 close_time_;
  ::google::protobuf::int32 error_code_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SlaveVerifyRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.SlaveVerifyRequest) */ {
 public:
  SlaveVerifyRequest();
  virtual ~SlaveVerifyRequest();

  SlaveVerifyRequest(const SlaveVerifyRequest& from);

  inline SlaveVerifyRequest& operator=(const SlaveVerifyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveVerifyRequest& default_instance();

  static inline const SlaveVerifyRequest* internal_default_instance() {
    return reinterpret_cast<const SlaveVerifyRequest*>(
               &_SlaveVerifyRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(SlaveVerifyRequest* other);

  // implements Message ----------------------------------------------

  inline SlaveVerifyRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SlaveVerifyRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SlaveVerifyRequest& from);
  void MergeFrom(const SlaveVerifyRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SlaveVerifyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes peer_message = 1;
  bool has_peer_message() const;
  void clear_peer_message();
  static const int kPeerMessageFieldNumber = 1;
  const ::std::string& peer_message() const;
  void set_peer_message(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_message(::std::string&& value);
  #endif
  void set_peer_message(const char* value);
  void set_peer_message(const void* value, size_t size);
  ::std::string* mutable_peer_message();
  ::std::string* release_peer_message();
  void set_allocated_peer_message(::std::string* peer_message);

  // optional bytes txset_hash = 3;
  bool has_txset_hash() const;
  void clear_txset_hash();
  static const int kTxsetHashFieldNumber = 3;
  const ::std::string& txset_hash() const;
  void set_txset_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_txset_hash(::std::string&& value);
  #endif
  void set_txset_hash(const char* value);
  void set_txset_hash(const void* value, size_t size);
  ::std::string* mutable_txset_hash();
  ::std::string* release_txset_hash();
  void set_allocated_txset_hash(::std::string* txset_hash);

  // required int64 peer_id = 2;
  bool has_peer_id() const;
  void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  ::google::protobuf::int64 peer_id() const;
  void set_peer_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.SlaveVerifyRequest)
 private:
  void set_has_peer_message();
  void clear_has_peer_message();
  void set_has_peer_id();
  void clear_has_peer_id();
  void set_has_txset_hash();
  void clear_has_txset_hash();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr peer_message_;
  ::google::protobuf::internal::ArenaStringPtr txset_hash_;
  ::google::protobuf::int64 peer_id_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SlaveVerifyResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.SlaveVerifyResponse) */ {
 public:
  SlaveVerifyResponse();
  virtual ~SlaveVerifyResponse();

  SlaveVerifyResponse(const SlaveVerifyResponse& from);

  inline SlaveVerifyResponse& operator=(const SlaveVerifyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SlaveVerifyResponse& default_instance();

  static inline const SlaveVerifyResponse* internal_default_instance() {
    return reinterpret_cast<const SlaveVerifyResponse*>(
               &_SlaveVerifyResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(SlaveVerifyResponse* other);

  // implements Message ----------------------------------------------

  inline SlaveVerifyResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SlaveVerifyResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SlaveVerifyResponse& from);
  void MergeFrom(const SlaveVerifyResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SlaveVerifyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string address = 7;
  int address_size() const;
  void clear_address();
  static const int kAddressFieldNumber = 7;
  const ::std::string& address(int index) const;
  ::std::string* mutable_address(int index);
  void set_address(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_address(int index, ::std::string&& value);
  #endif
  void set_address(int index, const char* value);
  void set_address(int index, const char* value, size_t size);
  ::std::string* add_address();
  void add_address(const ::std::string& value);
  #if LANG_CXX11
  void add_address(::std::string&& value);
  #endif
  void add_address(const char* value);
  void add_address(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& address() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_address();

  // required bytes peer_message = 1;
  bool has_peer_message() const;
  void clear_peer_message();
  static const int kPeerMessageFieldNumber = 1;
  const ::std::string& peer_message() const;
  void set_peer_message(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_message(::std::string&& value);
  #endif
  void set_peer_message(const char* value);
  void set_peer_message(const void* value, size_t size);
  ::std::string* mutable_peer_message();
  ::std::string* release_peer_message();
  void set_allocated_peer_message(::std::string* peer_message);

  // optional bytes txset_hash = 3;
  bool has_txset_hash() const;
  void clear_txset_hash();
  static const int kTxsetHashFieldNumber = 3;
  const ::std::string& txset_hash() const;
  void set_txset_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_txset_hash(::std::string&& value);
  #endif
  void set_txset_hash(const char* value);
  void set_txset_hash(const void* value, size_t size);
  ::std::string* mutable_txset_hash();
  ::std::string* release_txset_hash();
  void set_allocated_txset_hash(::std::string* txset_hash);

  // required bytes peer_message_hash = 4;
  bool has_peer_message_hash() const;
  void clear_peer_message_hash();
  static const int kPeerMessageHashFieldNumber = 4;
  const ::std::string& peer_message_hash() const;
  void set_peer_message_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_message_hash(::std::string&& value);
  #endif
  void set_peer_message_hash(const char* value);
  void set_peer_message_hash(const void* value, size_t size);
  ::std::string* mutable_peer_message_hash();
  ::std::string* release_peer_message_hash();
  void set_allocated_peer_message_hash(::std::string* peer_message_hash);

  // required bytes transaction_hash = 5;
  bool has_transaction_hash() const;
  void clear_transaction_hash();
  static const int kTransactionHashFieldNumber = 5;
  const ::std::string& transaction_hash() const;
  void set_transaction_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_transaction_hash(::std::string&& value);
  #endif
  void set_transaction_hash(const char* value);
  void set_transaction_hash(const void* value, size_t size);
  ::std::string* mutable_transaction_hash();
  ::std::string* release_transaction_hash();
  void set_allocated_transaction_hash(::std::string* transaction_hash);

  // required bytes transaction_env_hash = 6;
  bool has_transaction_env_hash() const;
  void clear_transaction_env_hash();
  static const int kTransactionEnvHashFieldNumber = 6;
  const ::std::string& transaction_env_hash() const;
  void set_transaction_env_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_transaction_env_hash(::std::string&& value);
  #endif
  void set_transaction_env_hash(const char* value);
  void set_transaction_env_hash(const void* value, size_t size);
  ::std::string* mutable_transaction_env_hash();
  ::std::string* release_transaction_env_hash();
  void set_allocated_transaction_env_hash(::std::string* transaction_env_hash);

  // optional int64 peer_id = 2;
  bool has_peer_id() const;
  void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  ::google::protobuf::int64 peer_id() const;
  void set_peer_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.SlaveVerifyResponse)
 private:
  void set_has_peer_message();
  void clear_has_peer_message();
  void set_has_peer_id();
  void clear_has_peer_id();
  void set_has_txset_hash();
  void clear_has_txset_hash();
  void set_has_peer_message_hash();
  void clear_has_peer_message_hash();
  void set_has_transaction_hash();
  void clear_has_transaction_hash();
  void set_has_transaction_env_hash();
  void clear_has_transaction_env_hash();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> address_;
  ::google::protobuf::internal::ArenaStringPtr peer_message_;
  ::google::protobuf::internal::ArenaStringPtr txset_hash_;
  ::google::protobuf::internal::ArenaStringPtr peer_message_hash_;
  ::google::protobuf::internal::ArenaStringPtr transaction_hash_;
  ::google::protobuf::internal::ArenaStringPtr transaction_env_hash_;
  ::google::protobuf::int64 peer_id_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTxHashSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.GetTxHashSet) */ {
 public:
  GetTxHashSet();
  virtual ~GetTxHashSet();

  GetTxHashSet(const GetTxHashSet& from);

  inline GetTxHashSet& operator=(const GetTxHashSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTxHashSet& default_instance();

  static inline const GetTxHashSet* internal_default_instance() {
    return reinterpret_cast<const GetTxHashSet*>(
               &_GetTxHashSet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(GetTxHashSet* other);

  // implements Message ----------------------------------------------

  inline GetTxHashSet* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTxHashSet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTxHashSet& from);
  void MergeFrom(const GetTxHashSet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTxHashSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes hash = 1;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:protocol.GetTxHashSet)
 private:
  void set_has_hash();
  void clear_has_hash();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxHashSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TxHashSet) */ {
 public:
  TxHashSet();
  virtual ~TxHashSet();

  TxHashSet(const TxHashSet& from);

  inline TxHashSet& operator=(const TxHashSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxHashSet& default_instance();

  static inline const TxHashSet* internal_default_instance() {
    return reinterpret_cast<const TxHashSet*>(
               &_TxHashSet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(TxHashSet* other);

  // implements Message ----------------------------------------------

  inline TxHashSet* New() const PROTOBUF_FINAL { return New(NULL); }

  TxHashSet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxHashSet& from);
  void MergeFrom(const TxHashSet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxHashSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes hashs = 3;
  int hashs_size() const;
  void clear_hashs();
  static const int kHashsFieldNumber = 3;
  const ::std::string& hashs(int index) const;
  ::std::string* mutable_hashs(int index);
  void set_hashs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_hashs(int index, ::std::string&& value);
  #endif
  void set_hashs(int index, const char* value);
  void set_hashs(int index, const void* value, size_t size);
  ::std::string* add_hashs();
  void add_hashs(const ::std::string& value);
  #if LANG_CXX11
  void add_hashs(::std::string&& value);
  #endif
  void add_hashs(const char* value);
  void add_hashs(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& hashs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hashs();

  // required bytes hash = 1;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // required bytes previous_ledger_hash = 2;
  bool has_previous_ledger_hash() const;
  void clear_previous_ledger_hash();
  static const int kPreviousLedgerHashFieldNumber = 2;
  const ::std::string& previous_ledger_hash() const;
  void set_previous_ledger_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_previous_ledger_hash(::std::string&& value);
  #endif
  void set_previous_ledger_hash(const char* value);
  void set_previous_ledger_hash(const void* value, size_t size);
  ::std::string* mutable_previous_ledger_hash();
  ::std::string* release_previous_ledger_hash();
  void set_allocated_previous_ledger_hash(::std::string* previous_ledger_hash);

  // @@protoc_insertion_point(class_scope:protocol.TxHashSet)
 private:
  void set_has_hash();
  void clear_has_hash();
  void set_has_previous_ledger_hash();
  void clear_has_previous_ledger_hash();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hashs_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr previous_ledger_hash_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetQuorumset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.GetQuorumset) */ {
 public:
  GetQuorumset();
  virtual ~GetQuorumset();

  GetQuorumset(const GetQuorumset& from);

  inline GetQuorumset& operator=(const GetQuorumset& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetQuorumset& default_instance();

  static inline const GetQuorumset* internal_default_instance() {
    return reinterpret_cast<const GetQuorumset*>(
               &_GetQuorumset_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(GetQuorumset* other);

  // implements Message ----------------------------------------------

  inline GetQuorumset* New() const PROTOBUF_FINAL { return New(NULL); }

  GetQuorumset* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetQuorumset& from);
  void MergeFrom(const GetQuorumset& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetQuorumset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes hash = 1;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:protocol.GetQuorumset)
 private:
  void set_has_hash();
  void clear_has_hash();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTxSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.GetTxSet) */ {
 public:
  GetTxSet();
  virtual ~GetTxSet();

  GetTxSet(const GetTxSet& from);

  inline GetTxSet& operator=(const GetTxSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTxSet& default_instance();

  static inline const GetTxSet* internal_default_instance() {
    return reinterpret_cast<const GetTxSet*>(
               &_GetTxSet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(GetTxSet* other);

  // implements Message ----------------------------------------------

  inline GetTxSet* New() const PROTOBUF_FINAL { return New(NULL); }

  GetTxSet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetTxSet& from);
  void MergeFrom(const GetTxSet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetTxSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes hashs = 2;
  int hashs_size() const;
  void clear_hashs();
  static const int kHashsFieldNumber = 2;
  const ::std::string& hashs(int index) const;
  ::std::string* mutable_hashs(int index);
  void set_hashs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_hashs(int index, ::std::string&& value);
  #endif
  void set_hashs(int index, const char* value);
  void set_hashs(int index, const void* value, size_t size);
  ::std::string* add_hashs();
  void add_hashs(const ::std::string& value);
  #if LANG_CXX11
  void add_hashs(::std::string&& value);
  #endif
  void add_hashs(const char* value);
  void add_hashs(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& hashs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hashs();

  // required bytes hash = 1;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:protocol.GetTxSet)
 private:
  void set_has_hash();
  void clear_has_hash();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hashs_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.TxSet) */ {
 public:
  TxSet();
  virtual ~TxSet();

  TxSet(const TxSet& from);

  inline TxSet& operator=(const TxSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxSet& default_instance();

  static inline const TxSet* internal_default_instance() {
    return reinterpret_cast<const TxSet*>(
               &_TxSet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(TxSet* other);

  // implements Message ----------------------------------------------

  inline TxSet* New() const PROTOBUF_FINAL { return New(NULL); }

  TxSet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TxSet& from);
  void MergeFrom(const TxSet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TxSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.TransactionEnv tran_envs = 3;
  int tran_envs_size() const;
  void clear_tran_envs();
  static const int kTranEnvsFieldNumber = 3;
  const ::protocol::TransactionEnv& tran_envs(int index) const;
  ::protocol::TransactionEnv* mutable_tran_envs(int index);
  ::protocol::TransactionEnv* add_tran_envs();
  ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >*
      mutable_tran_envs();
  const ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >&
      tran_envs() const;

  // required bytes hash = 1;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // required bytes previous_ledger_hash = 2;
  bool has_previous_ledger_hash() const;
  void clear_previous_ledger_hash();
  static const int kPreviousLedgerHashFieldNumber = 2;
  const ::std::string& previous_ledger_hash() const;
  void set_previous_ledger_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_previous_ledger_hash(::std::string&& value);
  #endif
  void set_previous_ledger_hash(const char* value);
  void set_previous_ledger_hash(const void* value, size_t size);
  ::std::string* mutable_previous_ledger_hash();
  ::std::string* release_previous_ledger_hash();
  void set_allocated_previous_ledger_hash(::std::string* previous_ledger_hash);

  // @@protoc_insertion_point(class_scope:protocol.TxSet)
 private:
  void set_has_hash();
  void clear_has_hash();
  void set_has_previous_ledger_hash();
  void clear_has_previous_ledger_hash();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv > tran_envs_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr previous_ledger_hash_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DontHave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.DontHave) */ {
 public:
  DontHave();
  virtual ~DontHave();

  DontHave(const DontHave& from);

  inline DontHave& operator=(const DontHave& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DontHave& default_instance();

  static inline const DontHave* internal_default_instance() {
    return reinterpret_cast<const DontHave*>(
               &_DontHave_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(DontHave* other);

  // implements Message ----------------------------------------------

  inline DontHave* New() const PROTOBUF_FINAL { return New(NULL); }

  DontHave* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DontHave& from);
  void MergeFrom(const DontHave& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DontHave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes hash = 2;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.DontHave)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_hash();
  void clear_has_hash();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::int32 type_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Hash : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Hash) */ {
 public:
  Hash();
  virtual ~Hash();

  Hash(const Hash& from);

  inline Hash& operator=(const Hash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hash& default_instance();

  static inline const Hash* internal_default_instance() {
    return reinterpret_cast<const Hash*>(
               &_Hash_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(Hash* other);

  // implements Message ----------------------------------------------

  inline Hash* New() const PROTOBUF_FINAL { return New(NULL); }

  Hash* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Hash& from);
  void MergeFrom(const Hash& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Hash* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes hash = 2;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:protocol.Hash)
 private:
  void set_has_hash();
  void clear_has_hash();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PbftPrePrepare : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.PbftPrePrepare) */ {
 public:
  PbftPrePrepare();
  virtual ~PbftPrePrepare();

  PbftPrePrepare(const PbftPrePrepare& from);

  inline PbftPrePrepare& operator=(const PbftPrePrepare& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbftPrePrepare& default_instance();

  static inline const PbftPrePrepare* internal_default_instance() {
    return reinterpret_cast<const PbftPrePrepare*>(
               &_PbftPrePrepare_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(PbftPrePrepare* other);

  // implements Message ----------------------------------------------

  inline PbftPrePrepare* New() const PROTOBUF_FINAL { return New(NULL); }

  PbftPrePrepare* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbftPrePrepare& from);
  void MergeFrom(const PbftPrePrepare& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbftPrePrepare* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes value_digest = 5;
  bool has_value_digest() const;
  void clear_value_digest();
  static const int kValueDigestFieldNumber = 5;
  const ::std::string& value_digest() const;
  void set_value_digest(const ::std::string& value);
  #if LANG_CXX11
  void set_value_digest(::std::string&& value);
  #endif
  void set_value_digest(const char* value);
  void set_value_digest(const void* value, size_t size);
  ::std::string* mutable_value_digest();
  ::std::string* release_value_digest();
  void set_allocated_value_digest(::std::string* value_digest);

  // required .protocol.Value value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  const ::protocol::Value& value() const;
  ::protocol::Value* mutable_value();
  ::protocol::Value* release_value();
  void set_allocated_value(::protocol::Value* value);

  // required int64 view_number = 1;
  bool has_view_number() const;
  void clear_view_number();
  static const int kViewNumberFieldNumber = 1;
  ::google::protobuf::int64 view_number() const;
  void set_view_number(::google::protobuf::int64 value);

  // required int64 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // required int64 replica_id = 3;
  bool has_replica_id() const;
  void clear_replica_id();
  static const int kReplicaIdFieldNumber = 3;
  ::google::protobuf::int64 replica_id() const;
  void set_replica_id(::google::protobuf::int64 value);

  // required int64 block_seq = 6;
  bool has_block_seq() const;
  void clear_block_seq();
  static const int kBlockSeqFieldNumber = 6;
  ::google::protobuf::int64 block_seq() const;
  void set_block_seq(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.PbftPrePrepare)
 private:
  void set_has_view_number();
  void clear_has_view_number();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_replica_id();
  void clear_has_replica_id();
  void set_has_value();
  void clear_has_value();
  void set_has_value_digest();
  void clear_has_value_digest();
  void set_has_block_seq();
  void clear_has_block_seq();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_digest_;
  ::protocol::Value* value_;
  ::google::protobuf::int64 view_number_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::int64 replica_id_;
  ::google::protobuf::int64 block_seq_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PbftPrepare : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.PbftPrepare) */ {
 public:
  PbftPrepare();
  virtual ~PbftPrepare();

  PbftPrepare(const PbftPrepare& from);

  inline PbftPrepare& operator=(const PbftPrepare& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbftPrepare& default_instance();

  static inline const PbftPrepare* internal_default_instance() {
    return reinterpret_cast<const PbftPrepare*>(
               &_PbftPrepare_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(PbftPrepare* other);

  // implements Message ----------------------------------------------

  inline PbftPrepare* New() const PROTOBUF_FINAL { return New(NULL); }

  PbftPrepare* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbftPrepare& from);
  void MergeFrom(const PbftPrepare& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbftPrepare* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes value_digest = 4;
  bool has_value_digest() const;
  void clear_value_digest();
  static const int kValueDigestFieldNumber = 4;
  const ::std::string& value_digest() const;
  void set_value_digest(const ::std::string& value);
  #if LANG_CXX11
  void set_value_digest(::std::string&& value);
  #endif
  void set_value_digest(const char* value);
  void set_value_digest(const void* value, size_t size);
  ::std::string* mutable_value_digest();
  ::std::string* release_value_digest();
  void set_allocated_value_digest(::std::string* value_digest);

  // required int64 view_number = 1;
  bool has_view_number() const;
  void clear_view_number();
  static const int kViewNumberFieldNumber = 1;
  ::google::protobuf::int64 view_number() const;
  void set_view_number(::google::protobuf::int64 value);

  // required int64 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // required int64 replica_id = 3;
  bool has_replica_id() const;
  void clear_replica_id();
  static const int kReplicaIdFieldNumber = 3;
  ::google::protobuf::int64 replica_id() const;
  void set_replica_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.PbftPrepare)
 private:
  void set_has_view_number();
  void clear_has_view_number();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_replica_id();
  void clear_has_replica_id();
  void set_has_value_digest();
  void clear_has_value_digest();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_digest_;
  ::google::protobuf::int64 view_number_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::int64 replica_id_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PbftCommit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.PbftCommit) */ {
 public:
  PbftCommit();
  virtual ~PbftCommit();

  PbftCommit(const PbftCommit& from);

  inline PbftCommit& operator=(const PbftCommit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbftCommit& default_instance();

  static inline const PbftCommit* internal_default_instance() {
    return reinterpret_cast<const PbftCommit*>(
               &_PbftCommit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(PbftCommit* other);

  // implements Message ----------------------------------------------

  inline PbftCommit* New() const PROTOBUF_FINAL { return New(NULL); }

  PbftCommit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbftCommit& from);
  void MergeFrom(const PbftCommit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbftCommit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes value_digest = 4;
  bool has_value_digest() const;
  void clear_value_digest();
  static const int kValueDigestFieldNumber = 4;
  const ::std::string& value_digest() const;
  void set_value_digest(const ::std::string& value);
  #if LANG_CXX11
  void set_value_digest(::std::string&& value);
  #endif
  void set_value_digest(const char* value);
  void set_value_digest(const void* value, size_t size);
  ::std::string* mutable_value_digest();
  ::std::string* release_value_digest();
  void set_allocated_value_digest(::std::string* value_digest);

  // required int64 view_number = 1;
  bool has_view_number() const;
  void clear_view_number();
  static const int kViewNumberFieldNumber = 1;
  ::google::protobuf::int64 view_number() const;
  void set_view_number(::google::protobuf::int64 value);

  // required int64 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // required int64 replica_id = 3;
  bool has_replica_id() const;
  void clear_replica_id();
  static const int kReplicaIdFieldNumber = 3;
  ::google::protobuf::int64 replica_id() const;
  void set_replica_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.PbftCommit)
 private:
  void set_has_view_number();
  void clear_has_view_number();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_replica_id();
  void clear_has_replica_id();
  void set_has_value_digest();
  void clear_has_value_digest();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_digest_;
  ::google::protobuf::int64 view_number_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::int64 replica_id_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PbftCheckPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.PbftCheckPoint) */ {
 public:
  PbftCheckPoint();
  virtual ~PbftCheckPoint();

  PbftCheckPoint(const PbftCheckPoint& from);

  inline PbftCheckPoint& operator=(const PbftCheckPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbftCheckPoint& default_instance();

  static inline const PbftCheckPoint* internal_default_instance() {
    return reinterpret_cast<const PbftCheckPoint*>(
               &_PbftCheckPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(PbftCheckPoint* other);

  // implements Message ----------------------------------------------

  inline PbftCheckPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  PbftCheckPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbftCheckPoint& from);
  void MergeFrom(const PbftCheckPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbftCheckPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes state_digest = 3;
  bool has_state_digest() const;
  void clear_state_digest();
  static const int kStateDigestFieldNumber = 3;
  const ::std::string& state_digest() const;
  void set_state_digest(const ::std::string& value);
  #if LANG_CXX11
  void set_state_digest(::std::string&& value);
  #endif
  void set_state_digest(const char* value);
  void set_state_digest(const void* value, size_t size);
  ::std::string* mutable_state_digest();
  ::std::string* release_state_digest();
  void set_allocated_state_digest(::std::string* state_digest);

  // required int64 sequence = 1;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // required int64 replica_id = 2;
  bool has_replica_id() const;
  void clear_replica_id();
  static const int kReplicaIdFieldNumber = 2;
  ::google::protobuf::int64 replica_id() const;
  void set_replica_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.PbftCheckPoint)
 private:
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_replica_id();
  void clear_has_replica_id();
  void set_has_state_digest();
  void clear_has_state_digest();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr state_digest_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::int64 replica_id_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PbftPreparedSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.PbftPreparedSet) */ {
 public:
  PbftPreparedSet();
  virtual ~PbftPreparedSet();

  PbftPreparedSet(const PbftPreparedSet& from);

  inline PbftPreparedSet& operator=(const PbftPreparedSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbftPreparedSet& default_instance();

  static inline const PbftPreparedSet* internal_default_instance() {
    return reinterpret_cast<const PbftPreparedSet*>(
               &_PbftPreparedSet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(PbftPreparedSet* other);

  // implements Message ----------------------------------------------

  inline PbftPreparedSet* New() const PROTOBUF_FINAL { return New(NULL); }

  PbftPreparedSet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbftPreparedSet& from);
  void MergeFrom(const PbftPreparedSet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbftPreparedSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.PbftEnv prepare = 2;
  int prepare_size() const;
  void clear_prepare();
  static const int kPrepareFieldNumber = 2;
  const ::protocol::PbftEnv& prepare(int index) const;
  ::protocol::PbftEnv* mutable_prepare(int index);
  ::protocol::PbftEnv* add_prepare();
  ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >*
      mutable_prepare();
  const ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >&
      prepare() const;

  // required .protocol.PbftEnv pre_prepare = 1;
  bool has_pre_prepare() const;
  void clear_pre_prepare();
  static const int kPrePrepareFieldNumber = 1;
  const ::protocol::PbftEnv& pre_prepare() const;
  ::protocol::PbftEnv* mutable_pre_prepare();
  ::protocol::PbftEnv* release_pre_prepare();
  void set_allocated_pre_prepare(::protocol::PbftEnv* pre_prepare);

  // @@protoc_insertion_point(class_scope:protocol.PbftPreparedSet)
 private:
  void set_has_pre_prepare();
  void clear_has_pre_prepare();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv > prepare_;
  ::protocol::PbftEnv* pre_prepare_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PbftViewChange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.PbftViewChange) */ {
 public:
  PbftViewChange();
  virtual ~PbftViewChange();

  PbftViewChange(const PbftViewChange& from);

  inline PbftViewChange& operator=(const PbftViewChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbftViewChange& default_instance();

  static inline const PbftViewChange* internal_default_instance() {
    return reinterpret_cast<const PbftViewChange*>(
               &_PbftViewChange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(PbftViewChange* other);

  // implements Message ----------------------------------------------

  inline PbftViewChange* New() const PROTOBUF_FINAL { return New(NULL); }

  PbftViewChange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbftViewChange& from);
  void MergeFrom(const PbftViewChange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbftViewChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.PbftEnv checkpoints = 3;
  int checkpoints_size() const;
  void clear_checkpoints();
  static const int kCheckpointsFieldNumber = 3;
  const ::protocol::PbftEnv& checkpoints(int index) const;
  ::protocol::PbftEnv* mutable_checkpoints(int index);
  ::protocol::PbftEnv* add_checkpoints();
  ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >*
      mutable_checkpoints();
  const ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >&
      checkpoints() const;

  // repeated .protocol.PbftPreparedSet prepared_set = 4;
  int prepared_set_size() const;
  void clear_prepared_set();
  static const int kPreparedSetFieldNumber = 4;
  const ::protocol::PbftPreparedSet& prepared_set(int index) const;
  ::protocol::PbftPreparedSet* mutable_prepared_set(int index);
  ::protocol::PbftPreparedSet* add_prepared_set();
  ::google::protobuf::RepeatedPtrField< ::protocol::PbftPreparedSet >*
      mutable_prepared_set();
  const ::google::protobuf::RepeatedPtrField< ::protocol::PbftPreparedSet >&
      prepared_set() const;

  // required int64 view_number = 1;
  bool has_view_number() const;
  void clear_view_number();
  static const int kViewNumberFieldNumber = 1;
  ::google::protobuf::int64 view_number() const;
  void set_view_number(::google::protobuf::int64 value);

  // required int64 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // required int64 replica_id = 5;
  bool has_replica_id() const;
  void clear_replica_id();
  static const int kReplicaIdFieldNumber = 5;
  ::google::protobuf::int64 replica_id() const;
  void set_replica_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.PbftViewChange)
 private:
  void set_has_view_number();
  void clear_has_view_number();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_replica_id();
  void clear_has_replica_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv > checkpoints_;
  ::google::protobuf::RepeatedPtrField< ::protocol::PbftPreparedSet > prepared_set_;
  ::google::protobuf::int64 view_number_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::int64 replica_id_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PbftNewView : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.PbftNewView) */ {
 public:
  PbftNewView();
  virtual ~PbftNewView();

  PbftNewView(const PbftNewView& from);

  inline PbftNewView& operator=(const PbftNewView& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbftNewView& default_instance();

  static inline const PbftNewView* internal_default_instance() {
    return reinterpret_cast<const PbftNewView*>(
               &_PbftNewView_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(PbftNewView* other);

  // implements Message ----------------------------------------------

  inline PbftNewView* New() const PROTOBUF_FINAL { return New(NULL); }

  PbftNewView* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbftNewView& from);
  void MergeFrom(const PbftNewView& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbftNewView* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.PbftEnv view_changes = 4;
  int view_changes_size() const;
  void clear_view_changes();
  static const int kViewChangesFieldNumber = 4;
  const ::protocol::PbftEnv& view_changes(int index) const;
  ::protocol::PbftEnv* mutable_view_changes(int index);
  ::protocol::PbftEnv* add_view_changes();
  ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >*
      mutable_view_changes();
  const ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >&
      view_changes() const;

  // repeated .protocol.PbftEnv pre_prepares = 5;
  int pre_prepares_size() const;
  void clear_pre_prepares();
  static const int kPrePreparesFieldNumber = 5;
  const ::protocol::PbftEnv& pre_prepares(int index) const;
  ::protocol::PbftEnv* mutable_pre_prepares(int index);
  ::protocol::PbftEnv* add_pre_prepares();
  ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >*
      mutable_pre_prepares();
  const ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >&
      pre_prepares() const;

  // required int64 view_number = 1;
  bool has_view_number() const;
  void clear_view_number();
  static const int kViewNumberFieldNumber = 1;
  ::google::protobuf::int64 view_number() const;
  void set_view_number(::google::protobuf::int64 value);

  // required int64 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // required int64 replica_id = 3;
  bool has_replica_id() const;
  void clear_replica_id();
  static const int kReplicaIdFieldNumber = 3;
  ::google::protobuf::int64 replica_id() const;
  void set_replica_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.PbftNewView)
 private:
  void set_has_view_number();
  void clear_has_view_number();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_replica_id();
  void clear_has_replica_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv > view_changes_;
  ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv > pre_prepares_;
  ::google::protobuf::int64 view_number_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::int64 replica_id_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pbft : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Pbft) */ {
 public:
  Pbft();
  virtual ~Pbft();

  Pbft(const Pbft& from);

  inline Pbft& operator=(const Pbft& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pbft& default_instance();

  static inline const Pbft* internal_default_instance() {
    return reinterpret_cast<const Pbft*>(
               &_Pbft_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(Pbft* other);

  // implements Message ----------------------------------------------

  inline Pbft* New() const PROTOBUF_FINAL { return New(NULL); }

  Pbft* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Pbft& from);
  void MergeFrom(const Pbft& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Pbft* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes validator_hash = 2;
  bool has_validator_hash() const;
  void clear_validator_hash();
  static const int kValidatorHashFieldNumber = 2;
  const ::std::string& validator_hash() const;
  void set_validator_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_validator_hash(::std::string&& value);
  #endif
  void set_validator_hash(const char* value);
  void set_validator_hash(const void* value, size_t size);
  ::std::string* mutable_validator_hash();
  ::std::string* release_validator_hash();
  void set_allocated_validator_hash(::std::string* validator_hash);

  // optional .protocol.PbftPrePrepare pre_prepare = 4;
  bool has_pre_prepare() const;
  void clear_pre_prepare();
  static const int kPrePrepareFieldNumber = 4;
  const ::protocol::PbftPrePrepare& pre_prepare() const;
  ::protocol::PbftPrePrepare* mutable_pre_prepare();
  ::protocol::PbftPrePrepare* release_pre_prepare();
  void set_allocated_pre_prepare(::protocol::PbftPrePrepare* pre_prepare);

  // optional .protocol.PbftPrepare prepare = 5;
  bool has_prepare() const;
  void clear_prepare();
  static const int kPrepareFieldNumber = 5;
  const ::protocol::PbftPrepare& prepare() const;
  ::protocol::PbftPrepare* mutable_prepare();
  ::protocol::PbftPrepare* release_prepare();
  void set_allocated_prepare(::protocol::PbftPrepare* prepare);

  // optional .protocol.PbftCommit commit = 6;
  bool has_commit() const;
  void clear_commit();
  static const int kCommitFieldNumber = 6;
  const ::protocol::PbftCommit& commit() const;
  ::protocol::PbftCommit* mutable_commit();
  ::protocol::PbftCommit* release_commit();
  void set_allocated_commit(::protocol::PbftCommit* commit);

  // optional .protocol.PbftCheckPoint checkpoint = 7;
  bool has_checkpoint() const;
  void clear_checkpoint();
  static const int kCheckpointFieldNumber = 7;
  const ::protocol::PbftCheckPoint& checkpoint() const;
  ::protocol::PbftCheckPoint* mutable_checkpoint();
  ::protocol::PbftCheckPoint* release_checkpoint();
  void set_allocated_checkpoint(::protocol::PbftCheckPoint* checkpoint);

  // optional .protocol.PbftViewChange view_change = 8;
  bool has_view_change() const;
  void clear_view_change();
  static const int kViewChangeFieldNumber = 8;
  const ::protocol::PbftViewChange& view_change() const;
  ::protocol::PbftViewChange* mutable_view_change();
  ::protocol::PbftViewChange* release_view_change();
  void set_allocated_view_change(::protocol::PbftViewChange* view_change);

  // optional .protocol.PbftNewView new_view = 9;
  bool has_new_view() const;
  void clear_new_view();
  static const int kNewViewFieldNumber = 9;
  const ::protocol::PbftNewView& new_view() const;
  ::protocol::PbftNewView* mutable_new_view();
  ::protocol::PbftNewView* release_new_view();
  void set_allocated_new_view(::protocol::PbftNewView* new_view);

  // required uint32 round_number = 1;
  bool has_round_number() const;
  void clear_round_number();
  static const int kRoundNumberFieldNumber = 1;
  ::google::protobuf::uint32 round_number() const;
  void set_round_number(::google::protobuf::uint32 value);

  // required .protocol.PbftMessageType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::protocol::PbftMessageType type() const;
  void set_type(::protocol::PbftMessageType value);

  // @@protoc_insertion_point(class_scope:protocol.Pbft)
 private:
  void set_has_round_number();
  void clear_has_round_number();
  void set_has_validator_hash();
  void clear_has_validator_hash();
  void set_has_type();
  void clear_has_type();
  void set_has_pre_prepare();
  void clear_has_pre_prepare();
  void set_has_prepare();
  void clear_has_prepare();
  void set_has_commit();
  void clear_has_commit();
  void set_has_checkpoint();
  void clear_has_checkpoint();
  void set_has_view_change();
  void clear_has_view_change();
  void set_has_new_view();
  void clear_has_new_view();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr validator_hash_;
  ::protocol::PbftPrePrepare* pre_prepare_;
  ::protocol::PbftPrepare* prepare_;
  ::protocol::PbftCommit* commit_;
  ::protocol::PbftCheckPoint* checkpoint_;
  ::protocol::PbftViewChange* view_change_;
  ::protocol::PbftNewView* new_view_;
  ::google::protobuf::uint32 round_number_;
  int type_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PbftEnv : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.PbftEnv) */ {
 public:
  PbftEnv();
  virtual ~PbftEnv();

  PbftEnv(const PbftEnv& from);

  inline PbftEnv& operator=(const PbftEnv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PbftEnv& default_instance();

  static inline const PbftEnv* internal_default_instance() {
    return reinterpret_cast<const PbftEnv*>(
               &_PbftEnv_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(PbftEnv* other);

  // implements Message ----------------------------------------------

  inline PbftEnv* New() const PROTOBUF_FINAL { return New(NULL); }

  PbftEnv* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PbftEnv& from);
  void MergeFrom(const PbftEnv& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PbftEnv* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.Pbft pbft = 1;
  bool has_pbft() const;
  void clear_pbft();
  static const int kPbftFieldNumber = 1;
  const ::protocol::Pbft& pbft() const;
  ::protocol::Pbft* mutable_pbft();
  ::protocol::Pbft* release_pbft();
  void set_allocated_pbft(::protocol::Pbft* pbft);

  // required .protocol.Signature signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::protocol::Signature& signature() const;
  ::protocol::Signature* mutable_signature();
  ::protocol::Signature* release_signature();
  void set_allocated_signature(::protocol::Signature* signature);

  // @@protoc_insertion_point(class_scope:protocol.PbftEnv)
 private:
  void set_has_pbft();
  void clear_has_pbft();
  void set_has_signature();
  void clear_has_signature();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::Pbft* pbft_;
  ::protocol::Signature* signature_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EntryList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.EntryList) */ {
 public:
  EntryList();
  virtual ~EntryList();

  EntryList(const EntryList& from);

  inline EntryList& operator=(const EntryList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntryList& default_instance();

  static inline const EntryList* internal_default_instance() {
    return reinterpret_cast<const EntryList*>(
               &_EntryList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(EntryList* other);

  // implements Message ----------------------------------------------

  inline EntryList* New() const PROTOBUF_FINAL { return New(NULL); }

  EntryList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EntryList& from);
  void MergeFrom(const EntryList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EntryList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes entry = 1;
  int entry_size() const;
  void clear_entry();
  static const int kEntryFieldNumber = 1;
  const ::std::string& entry(int index) const;
  ::std::string* mutable_entry(int index);
  void set_entry(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_entry(int index, ::std::string&& value);
  #endif
  void set_entry(int index, const char* value);
  void set_entry(int index, const void* value, size_t size);
  ::std::string* add_entry();
  void add_entry(const ::std::string& value);
  #if LANG_CXX11
  void add_entry(::std::string&& value);
  #endif
  void add_entry(const char* value);
  void add_entry(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& entry() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_entry();

  // @@protoc_insertion_point(class_scope:protocol.EntryList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> entry_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WsMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.WsMessage) */ {
 public:
  WsMessage();
  virtual ~WsMessage();

  WsMessage(const WsMessage& from);

  inline WsMessage& operator=(const WsMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WsMessage& default_instance();

  static inline const WsMessage* internal_default_instance() {
    return reinterpret_cast<const WsMessage*>(
               &_WsMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(WsMessage* other);

  // implements Message ----------------------------------------------

  inline WsMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  WsMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WsMessage& from);
  void MergeFrom(const WsMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WsMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 4;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required int64 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int64 type() const;
  void set_type(::google::protobuf::int64 value);

  // required int64 sequence = 3;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // required bool request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  bool request() const;
  void set_request(bool value);

  // @@protoc_insertion_point(class_scope:protocol.WsMessage)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_request();
  void clear_has_request();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int64 type_;
  ::google::protobuf::int64 sequence_;
  bool request_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeepOnline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.KeepOnline) */ {
 public:
  KeepOnline();
  virtual ~KeepOnline();

  KeepOnline(const KeepOnline& from);

  inline KeepOnline& operator=(const KeepOnline& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeepOnline& default_instance();

  static inline const KeepOnline* internal_default_instance() {
    return reinterpret_cast<const KeepOnline*>(
               &_KeepOnline_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(KeepOnline* other);

  // implements Message ----------------------------------------------

  inline KeepOnline* New() const PROTOBUF_FINAL { return New(NULL); }

  KeepOnline* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeepOnline& from);
  void MergeFrom(const KeepOnline& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeepOnline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string src_peer_addr = 1;
  bool has_src_peer_addr() const;
  void clear_src_peer_addr();
  static const int kSrcPeerAddrFieldNumber = 1;
  const ::std::string& src_peer_addr() const;
  void set_src_peer_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_src_peer_addr(::std::string&& value);
  #endif
  void set_src_peer_addr(const char* value);
  void set_src_peer_addr(const char* value, size_t size);
  ::std::string* mutable_src_peer_addr();
  ::std::string* release_src_peer_addr();
  void set_allocated_src_peer_addr(::std::string* src_peer_addr);

  // required int64 payload_seq = 2;
  bool has_payload_seq() const;
  void clear_payload_seq();
  static const int kPayloadSeqFieldNumber = 2;
  ::google::protobuf::int64 payload_seq() const;
  void set_payload_seq(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.KeepOnline)
 private:
  void set_has_src_peer_addr();
  void clear_has_src_peer_addr();
  void set_has_payload_seq();
  void clear_has_payload_seq();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_peer_addr_;
  ::google::protobuf::int64 payload_seq_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeepOnlineEnv : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.KeepOnlineEnv) */ {
 public:
  KeepOnlineEnv();
  virtual ~KeepOnlineEnv();

  KeepOnlineEnv(const KeepOnlineEnv& from);

  inline KeepOnlineEnv& operator=(const KeepOnlineEnv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeepOnlineEnv& default_instance();

  static inline const KeepOnlineEnv* internal_default_instance() {
    return reinterpret_cast<const KeepOnlineEnv*>(
               &_KeepOnlineEnv_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(KeepOnlineEnv* other);

  // implements Message ----------------------------------------------

  inline KeepOnlineEnv* New() const PROTOBUF_FINAL { return New(NULL); }

  KeepOnlineEnv* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeepOnlineEnv& from);
  void MergeFrom(const KeepOnlineEnv& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeepOnlineEnv* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.KeepOnline keeponline = 1;
  bool has_keeponline() const;
  void clear_keeponline();
  static const int kKeeponlineFieldNumber = 1;
  const ::protocol::KeepOnline& keeponline() const;
  ::protocol::KeepOnline* mutable_keeponline();
  ::protocol::KeepOnline* release_keeponline();
  void set_allocated_keeponline(::protocol::KeepOnline* keeponline);

  // required .protocol.Signature signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::protocol::Signature& signature() const;
  ::protocol::Signature* mutable_signature();
  ::protocol::Signature* release_signature();
  void set_allocated_signature(::protocol::Signature* signature);

  // @@protoc_insertion_point(class_scope:protocol.KeepOnlineEnv)
 private:
  void set_has_keeponline();
  void clear_has_keeponline();
  void set_has_signature();
  void clear_has_signature();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::KeepOnline* keeponline_;
  ::protocol::Signature* signature_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PayLoad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.PayLoad) */ {
 public:
  PayLoad();
  virtual ~PayLoad();

  PayLoad(const PayLoad& from);

  inline PayLoad& operator=(const PayLoad& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayLoad& default_instance();

  static inline const PayLoad* internal_default_instance() {
    return reinterpret_cast<const PayLoad*>(
               &_PayLoad_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void Swap(PayLoad* other);

  // implements Message ----------------------------------------------

  inline PayLoad* New() const PROTOBUF_FINAL { return New(NULL); }

  PayLoad* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PayLoad& from);
  void MergeFrom(const PayLoad& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PayLoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string des_peer_addrs = 2;
  int des_peer_addrs_size() const;
  void clear_des_peer_addrs();
  static const int kDesPeerAddrsFieldNumber = 2;
  const ::std::string& des_peer_addrs(int index) const;
  ::std::string* mutable_des_peer_addrs(int index);
  void set_des_peer_addrs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_des_peer_addrs(int index, ::std::string&& value);
  #endif
  void set_des_peer_addrs(int index, const char* value);
  void set_des_peer_addrs(int index, const char* value, size_t size);
  ::std::string* add_des_peer_addrs();
  void add_des_peer_addrs(const ::std::string& value);
  #if LANG_CXX11
  void add_des_peer_addrs(::std::string&& value);
  #endif
  void add_des_peer_addrs(const char* value);
  void add_des_peer_addrs(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& des_peer_addrs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_des_peer_addrs();

  // required string src_peer_addr = 1;
  bool has_src_peer_addr() const;
  void clear_src_peer_addr();
  static const int kSrcPeerAddrFieldNumber = 1;
  const ::std::string& src_peer_addr() const;
  void set_src_peer_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_src_peer_addr(::std::string&& value);
  #endif
  void set_src_peer_addr(const char* value);
  void set_src_peer_addr(const char* value, size_t size);
  ::std::string* mutable_src_peer_addr();
  ::std::string* release_src_peer_addr();
  void set_allocated_src_peer_addr(::std::string* src_peer_addr);

  // required bytes data = 5;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required int64 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.PayLoad)
 private:
  void set_has_src_peer_addr();
  void clear_has_src_peer_addr();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> des_peer_addrs_;
  ::google::protobuf::internal::ArenaStringPtr src_peer_addr_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int64 timestamp_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PayLoadEnv : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.PayLoadEnv) */ {
 public:
  PayLoadEnv();
  virtual ~PayLoadEnv();

  PayLoadEnv(const PayLoadEnv& from);

  inline PayLoadEnv& operator=(const PayLoadEnv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PayLoadEnv& default_instance();

  static inline const PayLoadEnv* internal_default_instance() {
    return reinterpret_cast<const PayLoadEnv*>(
               &_PayLoadEnv_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    62;

  void Swap(PayLoadEnv* other);

  // implements Message ----------------------------------------------

  inline PayLoadEnv* New() const PROTOBUF_FINAL { return New(NULL); }

  PayLoadEnv* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PayLoadEnv& from);
  void MergeFrom(const PayLoadEnv& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PayLoadEnv* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.PayLoad payload = 1;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 1;
  const ::protocol::PayLoad& payload() const;
  ::protocol::PayLoad* mutable_payload();
  ::protocol::PayLoad* release_payload();
  void set_allocated_payload(::protocol::PayLoad* payload);

  // required .protocol.Signature signature = 2;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 2;
  const ::protocol::Signature& signature() const;
  ::protocol::Signature* mutable_signature();
  ::protocol::Signature* release_signature();
  void set_allocated_signature(::protocol::Signature* signature);

  // @@protoc_insertion_point(class_scope:protocol.PayLoadEnv)
 private:
  void set_has_payload();
  void clear_has_payload();
  void set_has_signature();
  void clear_has_signature();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::PayLoad* payload_;
  ::protocol::Signature* signature_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChainHello : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainHello) */ {
 public:
  ChainHello();
  virtual ~ChainHello();

  ChainHello(const ChainHello& from);

  inline ChainHello& operator=(const ChainHello& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainHello& default_instance();

  static inline const ChainHello* internal_default_instance() {
    return reinterpret_cast<const ChainHello*>(
               &_ChainHello_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    63;

  void Swap(ChainHello* other);

  // implements Message ----------------------------------------------

  inline ChainHello* New() const PROTOBUF_FINAL { return New(NULL); }

  ChainHello* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChainHello& from);
  void MergeFrom(const ChainHello& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChainHello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.ChainMessageType api_list = 1;
  int api_list_size() const;
  void clear_api_list();
  static const int kApiListFieldNumber = 1;
  ::protocol::ChainMessageType api_list(int index) const;
  void set_api_list(int index, ::protocol::ChainMessageType value);
  void add_api_list(::protocol::ChainMessageType value);
  const ::google::protobuf::RepeatedField<int>& api_list() const;
  ::google::protobuf::RepeatedField<int>* mutable_api_list();

  // required int64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.ChainHello)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> api_list_;
  ::google::protobuf::int64 timestamp_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChainStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainStatus) */ {
 public:
  ChainStatus();
  virtual ~ChainStatus();

  ChainStatus(const ChainStatus& from);

  inline ChainStatus& operator=(const ChainStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainStatus& default_instance();

  static inline const ChainStatus* internal_default_instance() {
    return reinterpret_cast<const ChainStatus*>(
               &_ChainStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    64;

  void Swap(ChainStatus* other);

  // implements Message ----------------------------------------------

  inline ChainStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  ChainStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChainStatus& from);
  void MergeFrom(const ChainStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChainStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string self_addr = 1;
  bool has_self_addr() const;
  void clear_self_addr();
  static const int kSelfAddrFieldNumber = 1;
  const ::std::string& self_addr() const;
  void set_self_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_self_addr(::std::string&& value);
  #endif
  void set_self_addr(const char* value);
  void set_self_addr(const char* value, size_t size);
  ::std::string* mutable_self_addr();
  ::std::string* release_self_addr();
  void set_allocated_self_addr(::std::string* self_addr);

  // required string bubi_version = 3;
  bool has_bubi_version() const;
  void clear_bubi_version();
  static const int kBubiVersionFieldNumber = 3;
  const ::std::string& bubi_version() const;
  void set_bubi_version(const ::std::string& value);
  #if LANG_CXX11
  void set_bubi_version(::std::string&& value);
  #endif
  void set_bubi_version(const char* value);
  void set_bubi_version(const char* value, size_t size);
  ::std::string* mutable_bubi_version();
  ::std::string* release_bubi_version();
  void set_allocated_bubi_version(::std::string* bubi_version);

  // required int64 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // required uint32 ledger_version = 2;
  bool has_ledger_version() const;
  void clear_ledger_version();
  static const int kLedgerVersionFieldNumber = 2;
  ::google::protobuf::uint32 ledger_version() const;
  void set_ledger_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.ChainStatus)
 private:
  void set_has_self_addr();
  void clear_has_self_addr();
  void set_has_ledger_version();
  void clear_has_ledger_version();
  void set_has_bubi_version();
  void clear_has_bubi_version();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr self_addr_;
  ::google::protobuf::internal::ArenaStringPtr bubi_version_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::uint32 ledger_version_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChainPeerOnline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainPeerOnline) */ {
 public:
  ChainPeerOnline();
  virtual ~ChainPeerOnline();

  ChainPeerOnline(const ChainPeerOnline& from);

  inline ChainPeerOnline& operator=(const ChainPeerOnline& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainPeerOnline& default_instance();

  static inline const ChainPeerOnline* internal_default_instance() {
    return reinterpret_cast<const ChainPeerOnline*>(
               &_ChainPeerOnline_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    65;

  void Swap(ChainPeerOnline* other);

  // implements Message ----------------------------------------------

  inline ChainPeerOnline* New() const PROTOBUF_FINAL { return New(NULL); }

  ChainPeerOnline* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChainPeerOnline& from);
  void MergeFrom(const ChainPeerOnline& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChainPeerOnline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string peer_addr = 1;
  bool has_peer_addr() const;
  void clear_peer_addr();
  static const int kPeerAddrFieldNumber = 1;
  const ::std::string& peer_addr() const;
  void set_peer_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_addr(::std::string&& value);
  #endif
  void set_peer_addr(const char* value);
  void set_peer_addr(const char* value, size_t size);
  ::std::string* mutable_peer_addr();
  ::std::string* release_peer_addr();
  void set_allocated_peer_addr(::std::string* peer_addr);

  // required string peer_ip = 2;
  bool has_peer_ip() const;
  void clear_peer_ip();
  static const int kPeerIpFieldNumber = 2;
  const ::std::string& peer_ip() const;
  void set_peer_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_ip(::std::string&& value);
  #endif
  void set_peer_ip(const char* value);
  void set_peer_ip(const char* value, size_t size);
  ::std::string* mutable_peer_ip();
  ::std::string* release_peer_ip();
  void set_allocated_peer_ip(::std::string* peer_ip);

  // required int64 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // required int32 peer_port = 3;
  bool has_peer_port() const;
  void clear_peer_port();
  static const int kPeerPortFieldNumber = 3;
  ::google::protobuf::int32 peer_port() const;
  void set_peer_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.ChainPeerOnline)
 private:
  void set_has_peer_addr();
  void clear_has_peer_addr();
  void set_has_peer_ip();
  void clear_has_peer_ip();
  void set_has_peer_port();
  void clear_has_peer_port();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr peer_addr_;
  ::google::protobuf::internal::ArenaStringPtr peer_ip_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int32 peer_port_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChainPeerOffline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainPeerOffline) */ {
 public:
  ChainPeerOffline();
  virtual ~ChainPeerOffline();

  ChainPeerOffline(const ChainPeerOffline& from);

  inline ChainPeerOffline& operator=(const ChainPeerOffline& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainPeerOffline& default_instance();

  static inline const ChainPeerOffline* internal_default_instance() {
    return reinterpret_cast<const ChainPeerOffline*>(
               &_ChainPeerOffline_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    66;

  void Swap(ChainPeerOffline* other);

  // implements Message ----------------------------------------------

  inline ChainPeerOffline* New() const PROTOBUF_FINAL { return New(NULL); }

  ChainPeerOffline* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChainPeerOffline& from);
  void MergeFrom(const ChainPeerOffline& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChainPeerOffline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string peer_addr = 1;
  bool has_peer_addr() const;
  void clear_peer_addr();
  static const int kPeerAddrFieldNumber = 1;
  const ::std::string& peer_addr() const;
  void set_peer_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_peer_addr(::std::string&& value);
  #endif
  void set_peer_addr(const char* value);
  void set_peer_addr(const char* value, size_t size);
  ::std::string* mutable_peer_addr();
  ::std::string* release_peer_addr();
  void set_allocated_peer_addr(::std::string* peer_addr);

  // required int64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.ChainPeerOffline)
 private:
  void set_has_peer_addr();
  void clear_has_peer_addr();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr peer_addr_;
  ::google::protobuf::int64 timestamp_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChainPeerMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainPeerMessage) */ {
 public:
  ChainPeerMessage();
  virtual ~ChainPeerMessage();

  ChainPeerMessage(const ChainPeerMessage& from);

  inline ChainPeerMessage& operator=(const ChainPeerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainPeerMessage& default_instance();

  static inline const ChainPeerMessage* internal_default_instance() {
    return reinterpret_cast<const ChainPeerMessage*>(
               &_ChainPeerMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    67;

  void Swap(ChainPeerMessage* other);

  // implements Message ----------------------------------------------

  inline ChainPeerMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  ChainPeerMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChainPeerMessage& from);
  void MergeFrom(const ChainPeerMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChainPeerMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string des_peer_addrs = 2;
  int des_peer_addrs_size() const;
  void clear_des_peer_addrs();
  static const int kDesPeerAddrsFieldNumber = 2;
  const ::std::string& des_peer_addrs(int index) const;
  ::std::string* mutable_des_peer_addrs(int index);
  void set_des_peer_addrs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_des_peer_addrs(int index, ::std::string&& value);
  #endif
  void set_des_peer_addrs(int index, const char* value);
  void set_des_peer_addrs(int index, const char* value, size_t size);
  ::std::string* add_des_peer_addrs();
  void add_des_peer_addrs(const ::std::string& value);
  #if LANG_CXX11
  void add_des_peer_addrs(::std::string&& value);
  #endif
  void add_des_peer_addrs(const char* value);
  void add_des_peer_addrs(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& des_peer_addrs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_des_peer_addrs();

  // required string src_peer_addr = 1;
  bool has_src_peer_addr() const;
  void clear_src_peer_addr();
  static const int kSrcPeerAddrFieldNumber = 1;
  const ::std::string& src_peer_addr() const;
  void set_src_peer_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_src_peer_addr(::std::string&& value);
  #endif
  void set_src_peer_addr(const char* value);
  void set_src_peer_addr(const char* value, size_t size);
  ::std::string* mutable_src_peer_addr();
  ::std::string* release_src_peer_addr();
  void set_allocated_src_peer_addr(::std::string* src_peer_addr);

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:protocol.ChainPeerMessage)
 private:
  void set_has_src_peer_addr();
  void clear_has_src_peer_addr();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> des_peer_addrs_;
  ::google::protobuf::internal::ArenaStringPtr src_peer_addr_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ChainTxStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ChainTxStatus) */ {
 public:
  ChainTxStatus();
  virtual ~ChainTxStatus();

  ChainTxStatus(const ChainTxStatus& from);

  inline ChainTxStatus& operator=(const ChainTxStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChainTxStatus& default_instance();

  static inline const ChainTxStatus* internal_default_instance() {
    return reinterpret_cast<const ChainTxStatus*>(
               &_ChainTxStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    68;

  void Swap(ChainTxStatus* other);

  // implements Message ----------------------------------------------

  inline ChainTxStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  ChainTxStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChainTxStatus& from);
  void MergeFrom(const ChainTxStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChainTxStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ChainTxStatus_TxStatus TxStatus;
  static const TxStatus UNDEFINED =
    ChainTxStatus_TxStatus_UNDEFINED;
  static const TxStatus CONFIRMED =
    ChainTxStatus_TxStatus_CONFIRMED;
  static const TxStatus PENDING =
    ChainTxStatus_TxStatus_PENDING;
  static const TxStatus COMPLETE =
    ChainTxStatus_TxStatus_COMPLETE;
  static const TxStatus FAILURE =
    ChainTxStatus_TxStatus_FAILURE;
  static inline bool TxStatus_IsValid(int value) {
    return ChainTxStatus_TxStatus_IsValid(value);
  }
  static const TxStatus TxStatus_MIN =
    ChainTxStatus_TxStatus_TxStatus_MIN;
  static const TxStatus TxStatus_MAX =
    ChainTxStatus_TxStatus_TxStatus_MAX;
  static const int TxStatus_ARRAYSIZE =
    ChainTxStatus_TxStatus_TxStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TxStatus_descriptor() {
    return ChainTxStatus_TxStatus_descriptor();
  }
  static inline const ::std::string& TxStatus_Name(TxStatus value) {
    return ChainTxStatus_TxStatus_Name(value);
  }
  static inline bool TxStatus_Parse(const ::std::string& name,
      TxStatus* value) {
    return ChainTxStatus_TxStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string tx_hash = 2;
  bool has_tx_hash() const;
  void clear_tx_hash();
  static const int kTxHashFieldNumber = 2;
  const ::std::string& tx_hash() const;
  void set_tx_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_hash(::std::string&& value);
  #endif
  void set_tx_hash(const char* value);
  void set_tx_hash(const char* value, size_t size);
  ::std::string* mutable_tx_hash();
  ::std::string* release_tx_hash();
  void set_allocated_tx_hash(::std::string* tx_hash);

  // required string source_address = 3;
  bool has_source_address() const;
  void clear_source_address();
  static const int kSourceAddressFieldNumber = 3;
  const ::std::string& source_address() const;
  void set_source_address(const ::std::string& value);
  #if LANG_CXX11
  void set_source_address(::std::string&& value);
  #endif
  void set_source_address(const char* value);
  void set_source_address(const char* value, size_t size);
  ::std::string* mutable_source_address();
  ::std::string* release_source_address();
  void set_allocated_source_address(::std::string* source_address);

  // optional string error_desc = 8;
  bool has_error_desc() const;
  void clear_error_desc();
  static const int kErrorDescFieldNumber = 8;
  const ::std::string& error_desc() const;
  void set_error_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_error_desc(::std::string&& value);
  #endif
  void set_error_desc(const char* value);
  void set_error_desc(const char* value, size_t size);
  ::std::string* mutable_error_desc();
  ::std::string* release_error_desc();
  void set_allocated_error_desc(::std::string* error_desc);

  // optional int64 source_account_seq = 4;
  bool has_source_account_seq() const;
  void clear_source_account_seq();
  static const int kSourceAccountSeqFieldNumber = 4;
  ::google::protobuf::int64 source_account_seq() const;
  void set_source_account_seq(::google::protobuf::int64 value);

  // required .protocol.ChainTxStatus.TxStatus status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::protocol::ChainTxStatus_TxStatus status() const;
  void set_status(::protocol::ChainTxStatus_TxStatus value);

  // optional .protocol.ERRORCODE error_code = 7;
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 7;
  ::protocol::ERRORCODE error_code() const;
  void set_error_code(::protocol::ERRORCODE value);

  // optional int64 ledger_seq = 5;
  bool has_ledger_seq() const;
  void clear_ledger_seq();
  static const int kLedgerSeqFieldNumber = 5;
  ::google::protobuf::int64 ledger_seq() const;
  void set_ledger_seq(::google::protobuf::int64 value);

  // optional int64 new_account_seq = 6;
  bool has_new_account_seq() const;
  void clear_new_account_seq();
  static const int kNewAccountSeqFieldNumber = 6;
  ::google::protobuf::int64 new_account_seq() const;
  void set_new_account_seq(::google::protobuf::int64 value);

  // required int64 timestamp = 9;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 9;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.ChainTxStatus)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_tx_hash();
  void clear_has_tx_hash();
  void set_has_source_address();
  void clear_has_source_address();
  void set_has_source_account_seq();
  void clear_has_source_account_seq();
  void set_has_ledger_seq();
  void clear_has_ledger_seq();
  void set_has_new_account_seq();
  void clear_has_new_account_seq();
  void set_has_error_code();
  void clear_has_error_code();
  void set_has_error_desc();
  void clear_has_error_desc();
  void set_has_timestamp();
  void clear_has_timestamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tx_hash_;
  ::google::protobuf::internal::ArenaStringPtr source_address_;
  ::google::protobuf::internal::ArenaStringPtr error_desc_;
  ::google::protobuf::int64 source_account_seq_;
  int status_;
  int error_code_;
  ::google::protobuf::int64 ledger_seq_;
  ::google::protobuf::int64 new_account_seq_;
  ::google::protobuf::int64 timestamp_;
  friend struct protobuf_message_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Hello

// required uint32 ledger_version = 1;
inline bool Hello::has_ledger_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Hello::set_has_ledger_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Hello::clear_has_ledger_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Hello::clear_ledger_version() {
  ledger_version_ = 0u;
  clear_has_ledger_version();
}
inline ::google::protobuf::uint32 Hello::ledger_version() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.ledger_version)
  return ledger_version_;
}
inline void Hello::set_ledger_version(::google::protobuf::uint32 value) {
  set_has_ledger_version();
  ledger_version_ = value;
  // @@protoc_insertion_point(field_set:protocol.Hello.ledger_version)
}

// required uint32 overlayVersion = 2;
inline bool Hello::has_overlayversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Hello::set_has_overlayversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Hello::clear_has_overlayversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Hello::clear_overlayversion() {
  overlayversion_ = 0u;
  clear_has_overlayversion();
}
inline ::google::protobuf::uint32 Hello::overlayversion() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.overlayVersion)
  return overlayversion_;
}
inline void Hello::set_overlayversion(::google::protobuf::uint32 value) {
  set_has_overlayversion();
  overlayversion_ = value;
  // @@protoc_insertion_point(field_set:protocol.Hello.overlayVersion)
}

// required string bubiVersion = 3;
inline bool Hello::has_bubiversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hello::set_has_bubiversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hello::clear_has_bubiversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hello::clear_bubiversion() {
  bubiversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bubiversion();
}
inline const ::std::string& Hello::bubiversion() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.bubiVersion)
  return bubiversion_.GetNoArena();
}
inline void Hello::set_bubiversion(const ::std::string& value) {
  set_has_bubiversion();
  bubiversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Hello.bubiVersion)
}
#if LANG_CXX11
inline void Hello::set_bubiversion(::std::string&& value) {
  set_has_bubiversion();
  bubiversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Hello.bubiVersion)
}
#endif
inline void Hello::set_bubiversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bubiversion();
  bubiversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Hello.bubiVersion)
}
inline void Hello::set_bubiversion(const char* value, size_t size) {
  set_has_bubiversion();
  bubiversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Hello.bubiVersion)
}
inline ::std::string* Hello::mutable_bubiversion() {
  set_has_bubiversion();
  // @@protoc_insertion_point(field_mutable:protocol.Hello.bubiVersion)
  return bubiversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hello::release_bubiversion() {
  // @@protoc_insertion_point(field_release:protocol.Hello.bubiVersion)
  clear_has_bubiversion();
  return bubiversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_allocated_bubiversion(::std::string* bubiversion) {
  if (bubiversion != NULL) {
    set_has_bubiversion();
  } else {
    clear_has_bubiversion();
  }
  bubiversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bubiversion);
  // @@protoc_insertion_point(field_set_allocated:protocol.Hello.bubiVersion)
}

// required int32 listeningPort = 4;
inline bool Hello::has_listeningport() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Hello::set_has_listeningport() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Hello::clear_has_listeningport() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Hello::clear_listeningport() {
  listeningport_ = 0;
  clear_has_listeningport();
}
inline ::google::protobuf::int32 Hello::listeningport() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.listeningPort)
  return listeningport_;
}
inline void Hello::set_listeningport(::google::protobuf::int32 value) {
  set_has_listeningport();
  listeningport_ = value;
  // @@protoc_insertion_point(field_set:protocol.Hello.listeningPort)
}

// required string nodeId = 5;
inline bool Hello::has_nodeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Hello::set_has_nodeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Hello::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Hello::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nodeid();
}
inline const ::std::string& Hello::nodeid() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.nodeId)
  return nodeid_.GetNoArena();
}
inline void Hello::set_nodeid(const ::std::string& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Hello.nodeId)
}
#if LANG_CXX11
inline void Hello::set_nodeid(::std::string&& value) {
  set_has_nodeid();
  nodeid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Hello.nodeId)
}
#endif
inline void Hello::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Hello.nodeId)
}
inline void Hello::set_nodeid(const char* value, size_t size) {
  set_has_nodeid();
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Hello.nodeId)
}
inline ::std::string* Hello::mutable_nodeid() {
  set_has_nodeid();
  // @@protoc_insertion_point(field_mutable:protocol.Hello.nodeId)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hello::release_nodeid() {
  // @@protoc_insertion_point(field_release:protocol.Hello.nodeId)
  clear_has_nodeid();
  return nodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    set_has_nodeid();
  } else {
    clear_has_nodeid();
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:protocol.Hello.nodeId)
}

// required string network_type = 6;
inline bool Hello::has_network_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Hello::set_has_network_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Hello::clear_has_network_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Hello::clear_network_type() {
  network_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_network_type();
}
inline const ::std::string& Hello::network_type() const {
  // @@protoc_insertion_point(field_get:protocol.Hello.network_type)
  return network_type_.GetNoArena();
}
inline void Hello::set_network_type(const ::std::string& value) {
  set_has_network_type();
  network_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Hello.network_type)
}
#if LANG_CXX11
inline void Hello::set_network_type(::std::string&& value) {
  set_has_network_type();
  network_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Hello.network_type)
}
#endif
inline void Hello::set_network_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_network_type();
  network_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Hello.network_type)
}
inline void Hello::set_network_type(const char* value, size_t size) {
  set_has_network_type();
  network_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Hello.network_type)
}
inline ::std::string* Hello::mutable_network_type() {
  set_has_network_type();
  // @@protoc_insertion_point(field_mutable:protocol.Hello.network_type)
  return network_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hello::release_network_type() {
  // @@protoc_insertion_point(field_release:protocol.Hello.network_type)
  clear_has_network_type();
  return network_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hello::set_allocated_network_type(::std::string* network_type) {
  if (network_type != NULL) {
    set_has_network_type();
  } else {
    clear_has_network_type();
  }
  network_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), network_type);
  // @@protoc_insertion_point(field_set_allocated:protocol.Hello.network_type)
}

// -------------------------------------------------------------------

// Ping

// required uint64 nonce = 1;
inline bool Ping::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_nonce() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
  clear_has_nonce();
}
inline ::google::protobuf::uint64 Ping::nonce() const {
  // @@protoc_insertion_point(field_get:protocol.Ping.nonce)
  return nonce_;
}
inline void Ping::set_nonce(::google::protobuf::uint64 value) {
  set_has_nonce();
  nonce_ = value;
  // @@protoc_insertion_point(field_set:protocol.Ping.nonce)
}

// -------------------------------------------------------------------

// Pong

// required uint64 nonce = 1;
inline bool Pong::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pong::set_has_nonce() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pong::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pong::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
  clear_has_nonce();
}
inline ::google::protobuf::uint64 Pong::nonce() const {
  // @@protoc_insertion_point(field_get:protocol.Pong.nonce)
  return nonce_;
}
inline void Pong::set_nonce(::google::protobuf::uint64 value) {
  set_has_nonce();
  nonce_ = value;
  // @@protoc_insertion_point(field_set:protocol.Pong.nonce)
}

// -------------------------------------------------------------------

// Peers

// repeated .protocol.Peer peers = 2;
inline int Peers::peers_size() const {
  return peers_.size();
}
inline void Peers::clear_peers() {
  peers_.Clear();
}
inline const ::protocol::Peer& Peers::peers(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Peers.peers)
  return peers_.Get(index);
}
inline ::protocol::Peer* Peers::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Peers.peers)
  return peers_.Mutable(index);
}
inline ::protocol::Peer* Peers::add_peers() {
  // @@protoc_insertion_point(field_add:protocol.Peers.peers)
  return peers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Peer >*
Peers::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Peers.peers)
  return &peers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Peer >&
Peers::peers() const {
  // @@protoc_insertion_point(field_list:protocol.Peers.peers)
  return peers_;
}

// -------------------------------------------------------------------

// Peer

// required string ip = 1;
inline bool Peer::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Peer::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Peer::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Peer::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& Peer::ip() const {
  // @@protoc_insertion_point(field_get:protocol.Peer.ip)
  return ip_.GetNoArena();
}
inline void Peer::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Peer.ip)
}
#if LANG_CXX11
inline void Peer::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Peer.ip)
}
#endif
inline void Peer::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Peer.ip)
}
inline void Peer::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Peer.ip)
}
inline ::std::string* Peer::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:protocol.Peer.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Peer::release_ip() {
  // @@protoc_insertion_point(field_release:protocol.Peer.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Peer::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:protocol.Peer.ip)
}

// required int32 port = 2;
inline bool Peer::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Peer::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Peer::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Peer::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Peer::port() const {
  // @@protoc_insertion_point(field_get:protocol.Peer.port)
  return port_;
}
inline void Peer::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:protocol.Peer.port)
}

// required int32 num_failures = 3;
inline bool Peer::has_num_failures() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Peer::set_has_num_failures() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Peer::clear_has_num_failures() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Peer::clear_num_failures() {
  num_failures_ = 0;
  clear_has_num_failures();
}
inline ::google::protobuf::int32 Peer::num_failures() const {
  // @@protoc_insertion_point(field_get:protocol.Peer.num_failures)
  return num_failures_;
}
inline void Peer::set_num_failures(::google::protobuf::int32 value) {
  set_has_num_failures();
  num_failures_ = value;
  // @@protoc_insertion_point(field_set:protocol.Peer.num_failures)
}

// -------------------------------------------------------------------

// AccountThreshold

// required uint32 master_weight = 1;
inline bool AccountThreshold::has_master_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountThreshold::set_has_master_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountThreshold::clear_has_master_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountThreshold::clear_master_weight() {
  master_weight_ = 0u;
  clear_has_master_weight();
}
inline ::google::protobuf::uint32 AccountThreshold::master_weight() const {
  // @@protoc_insertion_point(field_get:protocol.AccountThreshold.master_weight)
  return master_weight_;
}
inline void AccountThreshold::set_master_weight(::google::protobuf::uint32 value) {
  set_has_master_weight();
  master_weight_ = value;
  // @@protoc_insertion_point(field_set:protocol.AccountThreshold.master_weight)
}

// required uint32 low_threshold = 2;
inline bool AccountThreshold::has_low_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountThreshold::set_has_low_threshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountThreshold::clear_has_low_threshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountThreshold::clear_low_threshold() {
  low_threshold_ = 0u;
  clear_has_low_threshold();
}
inline ::google::protobuf::uint32 AccountThreshold::low_threshold() const {
  // @@protoc_insertion_point(field_get:protocol.AccountThreshold.low_threshold)
  return low_threshold_;
}
inline void AccountThreshold::set_low_threshold(::google::protobuf::uint32 value) {
  set_has_low_threshold();
  low_threshold_ = value;
  // @@protoc_insertion_point(field_set:protocol.AccountThreshold.low_threshold)
}

// required uint32 med_threshold = 3;
inline bool AccountThreshold::has_med_threshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountThreshold::set_has_med_threshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountThreshold::clear_has_med_threshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountThreshold::clear_med_threshold() {
  med_threshold_ = 0u;
  clear_has_med_threshold();
}
inline ::google::protobuf::uint32 AccountThreshold::med_threshold() const {
  // @@protoc_insertion_point(field_get:protocol.AccountThreshold.med_threshold)
  return med_threshold_;
}
inline void AccountThreshold::set_med_threshold(::google::protobuf::uint32 value) {
  set_has_med_threshold();
  med_threshold_ = value;
  // @@protoc_insertion_point(field_set:protocol.AccountThreshold.med_threshold)
}

// required uint32 high_threshold = 4;
inline bool AccountThreshold::has_high_threshold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountThreshold::set_has_high_threshold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountThreshold::clear_has_high_threshold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountThreshold::clear_high_threshold() {
  high_threshold_ = 0u;
  clear_has_high_threshold();
}
inline ::google::protobuf::uint32 AccountThreshold::high_threshold() const {
  // @@protoc_insertion_point(field_get:protocol.AccountThreshold.high_threshold)
  return high_threshold_;
}
inline void AccountThreshold::set_high_threshold(::google::protobuf::uint32 value) {
  set_has_high_threshold();
  high_threshold_ = value;
  // @@protoc_insertion_point(field_set:protocol.AccountThreshold.high_threshold)
}

// -------------------------------------------------------------------

// Signer

// required string address = 1;
inline bool Signer::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signer::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signer::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signer::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& Signer::address() const {
  // @@protoc_insertion_point(field_get:protocol.Signer.address)
  return address_.GetNoArena();
}
inline void Signer::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Signer.address)
}
#if LANG_CXX11
inline void Signer::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Signer.address)
}
#endif
inline void Signer::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Signer.address)
}
inline void Signer::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Signer.address)
}
inline ::std::string* Signer::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:protocol.Signer.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signer::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Signer.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signer::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Signer.address)
}

// required uint32 weight = 2;
inline bool Signer::has_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signer::set_has_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Signer::clear_has_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Signer::clear_weight() {
  weight_ = 0u;
  clear_has_weight();
}
inline ::google::protobuf::uint32 Signer::weight() const {
  // @@protoc_insertion_point(field_get:protocol.Signer.weight)
  return weight_;
}
inline void Signer::set_weight(::google::protobuf::uint32 value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:protocol.Signer.weight)
}

// -------------------------------------------------------------------

// Account

// required int64 account_balance = 1;
inline bool Account::has_account_balance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Account::set_has_account_balance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Account::clear_has_account_balance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Account::clear_account_balance() {
  account_balance_ = GOOGLE_LONGLONG(0);
  clear_has_account_balance();
}
inline ::google::protobuf::int64 Account::account_balance() const {
  // @@protoc_insertion_point(field_get:protocol.Account.account_balance)
  return account_balance_;
}
inline void Account::set_account_balance(::google::protobuf::int64 value) {
  set_has_account_balance();
  account_balance_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.account_balance)
}

// required int64 previous_ledger_seq = 2;
inline bool Account::has_previous_ledger_seq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Account::set_has_previous_ledger_seq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Account::clear_has_previous_ledger_seq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Account::clear_previous_ledger_seq() {
  previous_ledger_seq_ = GOOGLE_LONGLONG(0);
  clear_has_previous_ledger_seq();
}
inline ::google::protobuf::int64 Account::previous_ledger_seq() const {
  // @@protoc_insertion_point(field_get:protocol.Account.previous_ledger_seq)
  return previous_ledger_seq_;
}
inline void Account::set_previous_ledger_seq(::google::protobuf::int64 value) {
  set_has_previous_ledger_seq();
  previous_ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.previous_ledger_seq)
}

// required bytes previous_tx_hash = 3;
inline bool Account::has_previous_tx_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Account::set_has_previous_tx_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Account::clear_has_previous_tx_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Account::clear_previous_tx_hash() {
  previous_tx_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_previous_tx_hash();
}
inline const ::std::string& Account::previous_tx_hash() const {
  // @@protoc_insertion_point(field_get:protocol.Account.previous_tx_hash)
  return previous_tx_hash_.GetNoArena();
}
inline void Account::set_previous_tx_hash(const ::std::string& value) {
  set_has_previous_tx_hash();
  previous_tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Account.previous_tx_hash)
}
#if LANG_CXX11
inline void Account::set_previous_tx_hash(::std::string&& value) {
  set_has_previous_tx_hash();
  previous_tx_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Account.previous_tx_hash)
}
#endif
inline void Account::set_previous_tx_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_previous_tx_hash();
  previous_tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Account.previous_tx_hash)
}
inline void Account::set_previous_tx_hash(const void* value, size_t size) {
  set_has_previous_tx_hash();
  previous_tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Account.previous_tx_hash)
}
inline ::std::string* Account::mutable_previous_tx_hash() {
  set_has_previous_tx_hash();
  // @@protoc_insertion_point(field_mutable:protocol.Account.previous_tx_hash)
  return previous_tx_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_previous_tx_hash() {
  // @@protoc_insertion_point(field_release:protocol.Account.previous_tx_hash)
  clear_has_previous_tx_hash();
  return previous_tx_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_previous_tx_hash(::std::string* previous_tx_hash) {
  if (previous_tx_hash != NULL) {
    set_has_previous_tx_hash();
  } else {
    clear_has_previous_tx_hash();
  }
  previous_tx_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previous_tx_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.previous_tx_hash)
}

// required string account_address = 4;
inline bool Account::has_account_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Account::set_has_account_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Account::clear_has_account_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Account::clear_account_address() {
  account_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account_address();
}
inline const ::std::string& Account::account_address() const {
  // @@protoc_insertion_point(field_get:protocol.Account.account_address)
  return account_address_.GetNoArena();
}
inline void Account::set_account_address(const ::std::string& value) {
  set_has_account_address();
  account_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Account.account_address)
}
#if LANG_CXX11
inline void Account::set_account_address(::std::string&& value) {
  set_has_account_address();
  account_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Account.account_address)
}
#endif
inline void Account::set_account_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account_address();
  account_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Account.account_address)
}
inline void Account::set_account_address(const char* value, size_t size) {
  set_has_account_address();
  account_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Account.account_address)
}
inline ::std::string* Account::mutable_account_address() {
  set_has_account_address();
  // @@protoc_insertion_point(field_mutable:protocol.Account.account_address)
  return account_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_account_address() {
  // @@protoc_insertion_point(field_release:protocol.Account.account_address)
  clear_has_account_address();
  return account_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_account_address(::std::string* account_address) {
  if (account_address != NULL) {
    set_has_account_address();
  } else {
    clear_has_account_address();
  }
  account_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.account_address)
}

// repeated .protocol.Asset assets = 5;
inline int Account::assets_size() const {
  return assets_.size();
}
inline void Account::clear_assets() {
  assets_.Clear();
}
inline const ::protocol::Asset& Account::assets(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Account.assets)
  return assets_.Get(index);
}
inline ::protocol::Asset* Account::mutable_assets(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Account.assets)
  return assets_.Mutable(index);
}
inline ::protocol::Asset* Account::add_assets() {
  // @@protoc_insertion_point(field_add:protocol.Account.assets)
  return assets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Asset >*
Account::mutable_assets() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Account.assets)
  return &assets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Asset >&
Account::assets() const {
  // @@protoc_insertion_point(field_list:protocol.Account.assets)
  return assets_;
}

// required int64 tx_seq = 6;
inline bool Account::has_tx_seq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Account::set_has_tx_seq() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Account::clear_has_tx_seq() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Account::clear_tx_seq() {
  tx_seq_ = GOOGLE_LONGLONG(0);
  clear_has_tx_seq();
}
inline ::google::protobuf::int64 Account::tx_seq() const {
  // @@protoc_insertion_point(field_get:protocol.Account.tx_seq)
  return tx_seq_;
}
inline void Account::set_tx_seq(::google::protobuf::int64 value) {
  set_has_tx_seq();
  tx_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.tx_seq)
}

// required .protocol.AccountThreshold thresholds = 7;
inline bool Account::has_thresholds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Account::set_has_thresholds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Account::clear_has_thresholds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Account::clear_thresholds() {
  if (thresholds_ != NULL) thresholds_->::protocol::AccountThreshold::Clear();
  clear_has_thresholds();
}
inline const ::protocol::AccountThreshold& Account::thresholds() const {
  // @@protoc_insertion_point(field_get:protocol.Account.thresholds)
  return thresholds_ != NULL ? *thresholds_
                         : *::protocol::AccountThreshold::internal_default_instance();
}
inline ::protocol::AccountThreshold* Account::mutable_thresholds() {
  set_has_thresholds();
  if (thresholds_ == NULL) {
    thresholds_ = new ::protocol::AccountThreshold;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Account.thresholds)
  return thresholds_;
}
inline ::protocol::AccountThreshold* Account::release_thresholds() {
  // @@protoc_insertion_point(field_release:protocol.Account.thresholds)
  clear_has_thresholds();
  ::protocol::AccountThreshold* temp = thresholds_;
  thresholds_ = NULL;
  return temp;
}
inline void Account::set_allocated_thresholds(::protocol::AccountThreshold* thresholds) {
  delete thresholds_;
  thresholds_ = thresholds;
  if (thresholds) {
    set_has_thresholds();
  } else {
    clear_has_thresholds();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.thresholds)
}

// repeated .protocol.Signer signers = 8;
inline int Account::signers_size() const {
  return signers_.size();
}
inline void Account::clear_signers() {
  signers_.Clear();
}
inline const ::protocol::Signer& Account::signers(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Account.signers)
  return signers_.Get(index);
}
inline ::protocol::Signer* Account::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Account.signers)
  return signers_.Mutable(index);
}
inline ::protocol::Signer* Account::add_signers() {
  // @@protoc_insertion_point(field_add:protocol.Account.signers)
  return signers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Signer >*
Account::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Account.signers)
  return &signers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Signer >&
Account::signers() const {
  // @@protoc_insertion_point(field_list:protocol.Account.signers)
  return signers_;
}

// required bytes metadata = 9;
inline bool Account::has_metadata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Account::set_has_metadata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Account::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Account::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_metadata();
}
inline const ::std::string& Account::metadata() const {
  // @@protoc_insertion_point(field_get:protocol.Account.metadata)
  return metadata_.GetNoArena();
}
inline void Account::set_metadata(const ::std::string& value) {
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Account.metadata)
}
#if LANG_CXX11
inline void Account::set_metadata(::std::string&& value) {
  set_has_metadata();
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Account.metadata)
}
#endif
inline void Account::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Account.metadata)
}
inline void Account::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Account.metadata)
}
inline ::std::string* Account::mutable_metadata() {
  set_has_metadata();
  // @@protoc_insertion_point(field_mutable:protocol.Account.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Account::release_metadata() {
  // @@protoc_insertion_point(field_release:protocol.Account.metadata)
  clear_has_metadata();
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Account::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    set_has_metadata();
  } else {
    clear_has_metadata();
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:protocol.Account.metadata)
}

// optional int64 metadata_version = 10;
inline bool Account::has_metadata_version() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Account::set_has_metadata_version() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Account::clear_has_metadata_version() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Account::clear_metadata_version() {
  metadata_version_ = GOOGLE_LONGLONG(0);
  clear_has_metadata_version();
}
inline ::google::protobuf::int64 Account::metadata_version() const {
  // @@protoc_insertion_point(field_get:protocol.Account.metadata_version)
  return metadata_version_;
}
inline void Account::set_metadata_version(::google::protobuf::int64 value) {
  set_has_metadata_version();
  metadata_version_ = value;
  // @@protoc_insertion_point(field_set:protocol.Account.metadata_version)
}

// repeated .protocol.UniqueAsset unique_asset = 11;
inline int Account::unique_asset_size() const {
  return unique_asset_.size();
}
inline void Account::clear_unique_asset() {
  unique_asset_.Clear();
}
inline const ::protocol::UniqueAsset& Account::unique_asset(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Account.unique_asset)
  return unique_asset_.Get(index);
}
inline ::protocol::UniqueAsset* Account::mutable_unique_asset(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Account.unique_asset)
  return unique_asset_.Mutable(index);
}
inline ::protocol::UniqueAsset* Account::add_unique_asset() {
  // @@protoc_insertion_point(field_add:protocol.Account.unique_asset)
  return unique_asset_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::UniqueAsset >*
Account::mutable_unique_asset() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Account.unique_asset)
  return &unique_asset_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::UniqueAsset >&
Account::unique_asset() const {
  // @@protoc_insertion_point(field_list:protocol.Account.unique_asset)
  return unique_asset_;
}

// -------------------------------------------------------------------

// UpgradeRequest

// required string id = 1;
inline bool UpgradeRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& UpgradeRequest::id() const {
  // @@protoc_insertion_point(field_get:protocol.UpgradeRequest.id)
  return id_.GetNoArena();
}
inline void UpgradeRequest::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.UpgradeRequest.id)
}
#if LANG_CXX11
inline void UpgradeRequest::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.UpgradeRequest.id)
}
#endif
inline void UpgradeRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.UpgradeRequest.id)
}
inline void UpgradeRequest::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.UpgradeRequest.id)
}
inline ::std::string* UpgradeRequest::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:protocol.UpgradeRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpgradeRequest::release_id() {
  // @@protoc_insertion_point(field_release:protocol.UpgradeRequest.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpgradeRequest::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:protocol.UpgradeRequest.id)
}

// required uint64 time = 2;
inline bool UpgradeRequest::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpgradeRequest::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpgradeRequest::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpgradeRequest::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 UpgradeRequest::time() const {
  // @@protoc_insertion_point(field_get:protocol.UpgradeRequest.time)
  return time_;
}
inline void UpgradeRequest::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:protocol.UpgradeRequest.time)
}

// required uint32 ledger_version = 3;
inline bool UpgradeRequest::has_ledger_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpgradeRequest::set_has_ledger_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpgradeRequest::clear_has_ledger_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpgradeRequest::clear_ledger_version() {
  ledger_version_ = 0u;
  clear_has_ledger_version();
}
inline ::google::protobuf::uint32 UpgradeRequest::ledger_version() const {
  // @@protoc_insertion_point(field_get:protocol.UpgradeRequest.ledger_version)
  return ledger_version_;
}
inline void UpgradeRequest::set_ledger_version(::google::protobuf::uint32 value) {
  set_has_ledger_version();
  ledger_version_ = value;
  // @@protoc_insertion_point(field_set:protocol.UpgradeRequest.ledger_version)
}

// optional string add_validator = 4;
inline bool UpgradeRequest::has_add_validator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeRequest::set_has_add_validator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeRequest::clear_has_add_validator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeRequest::clear_add_validator() {
  add_validator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_add_validator();
}
inline const ::std::string& UpgradeRequest::add_validator() const {
  // @@protoc_insertion_point(field_get:protocol.UpgradeRequest.add_validator)
  return add_validator_.GetNoArena();
}
inline void UpgradeRequest::set_add_validator(const ::std::string& value) {
  set_has_add_validator();
  add_validator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.UpgradeRequest.add_validator)
}
#if LANG_CXX11
inline void UpgradeRequest::set_add_validator(::std::string&& value) {
  set_has_add_validator();
  add_validator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.UpgradeRequest.add_validator)
}
#endif
inline void UpgradeRequest::set_add_validator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_add_validator();
  add_validator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.UpgradeRequest.add_validator)
}
inline void UpgradeRequest::set_add_validator(const char* value, size_t size) {
  set_has_add_validator();
  add_validator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.UpgradeRequest.add_validator)
}
inline ::std::string* UpgradeRequest::mutable_add_validator() {
  set_has_add_validator();
  // @@protoc_insertion_point(field_mutable:protocol.UpgradeRequest.add_validator)
  return add_validator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpgradeRequest::release_add_validator() {
  // @@protoc_insertion_point(field_release:protocol.UpgradeRequest.add_validator)
  clear_has_add_validator();
  return add_validator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpgradeRequest::set_allocated_add_validator(::std::string* add_validator) {
  if (add_validator != NULL) {
    set_has_add_validator();
  } else {
    clear_has_add_validator();
  }
  add_validator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), add_validator);
  // @@protoc_insertion_point(field_set_allocated:protocol.UpgradeRequest.add_validator)
}

// optional uint32 new_ledger_version = 5;
inline bool UpgradeRequest::has_new_ledger_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpgradeRequest::set_has_new_ledger_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpgradeRequest::clear_has_new_ledger_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpgradeRequest::clear_new_ledger_version() {
  new_ledger_version_ = 0u;
  clear_has_new_ledger_version();
}
inline ::google::protobuf::uint32 UpgradeRequest::new_ledger_version() const {
  // @@protoc_insertion_point(field_get:protocol.UpgradeRequest.new_ledger_version)
  return new_ledger_version_;
}
inline void UpgradeRequest::set_new_ledger_version(::google::protobuf::uint32 value) {
  set_has_new_ledger_version();
  new_ledger_version_ = value;
  // @@protoc_insertion_point(field_set:protocol.UpgradeRequest.new_ledger_version)
}

// required uint64 start_time = 6;
inline bool UpgradeRequest::has_start_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpgradeRequest::set_has_start_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpgradeRequest::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpgradeRequest::clear_start_time() {
  start_time_ = GOOGLE_ULONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::uint64 UpgradeRequest::start_time() const {
  // @@protoc_insertion_point(field_get:protocol.UpgradeRequest.start_time)
  return start_time_;
}
inline void UpgradeRequest::set_start_time(::google::protobuf::uint64 value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.UpgradeRequest.start_time)
}

// -------------------------------------------------------------------

// UpgradeRequestEnv

// required .protocol.UpgradeRequest request = 1;
inline bool UpgradeRequestEnv::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeRequestEnv::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeRequestEnv::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeRequestEnv::clear_request() {
  if (request_ != NULL) request_->::protocol::UpgradeRequest::Clear();
  clear_has_request();
}
inline const ::protocol::UpgradeRequest& UpgradeRequestEnv::request() const {
  // @@protoc_insertion_point(field_get:protocol.UpgradeRequestEnv.request)
  return request_ != NULL ? *request_
                         : *::protocol::UpgradeRequest::internal_default_instance();
}
inline ::protocol::UpgradeRequest* UpgradeRequestEnv::mutable_request() {
  set_has_request();
  if (request_ == NULL) {
    request_ = new ::protocol::UpgradeRequest;
  }
  // @@protoc_insertion_point(field_mutable:protocol.UpgradeRequestEnv.request)
  return request_;
}
inline ::protocol::UpgradeRequest* UpgradeRequestEnv::release_request() {
  // @@protoc_insertion_point(field_release:protocol.UpgradeRequestEnv.request)
  clear_has_request();
  ::protocol::UpgradeRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline void UpgradeRequestEnv::set_allocated_request(::protocol::UpgradeRequest* request) {
  delete request_;
  request_ = request;
  if (request) {
    set_has_request();
  } else {
    clear_has_request();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.UpgradeRequestEnv.request)
}

// required .protocol.Signature signature = 2;
inline bool UpgradeRequestEnv::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeRequestEnv::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeRequestEnv::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeRequestEnv::clear_signature() {
  if (signature_ != NULL) signature_->::protocol::Signature::Clear();
  clear_has_signature();
}
inline const ::protocol::Signature& UpgradeRequestEnv::signature() const {
  // @@protoc_insertion_point(field_get:protocol.UpgradeRequestEnv.signature)
  return signature_ != NULL ? *signature_
                         : *::protocol::Signature::internal_default_instance();
}
inline ::protocol::Signature* UpgradeRequestEnv::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) {
    signature_ = new ::protocol::Signature;
  }
  // @@protoc_insertion_point(field_mutable:protocol.UpgradeRequestEnv.signature)
  return signature_;
}
inline ::protocol::Signature* UpgradeRequestEnv::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.UpgradeRequestEnv.signature)
  clear_has_signature();
  ::protocol::Signature* temp = signature_;
  signature_ = NULL;
  return temp;
}
inline void UpgradeRequestEnv::set_allocated_signature(::protocol::Signature* signature) {
  delete signature_;
  signature_ = signature;
  if (signature) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.UpgradeRequestEnv.signature)
}

// -------------------------------------------------------------------

// LedgerUpgrade

// optional uint32 new_ledger_version = 1;
inline bool LedgerUpgrade::has_new_ledger_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LedgerUpgrade::set_has_new_ledger_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LedgerUpgrade::clear_has_new_ledger_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LedgerUpgrade::clear_new_ledger_version() {
  new_ledger_version_ = 0u;
  clear_has_new_ledger_version();
}
inline ::google::protobuf::uint32 LedgerUpgrade::new_ledger_version() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerUpgrade.new_ledger_version)
  return new_ledger_version_;
}
inline void LedgerUpgrade::set_new_ledger_version(::google::protobuf::uint32 value) {
  set_has_new_ledger_version();
  new_ledger_version_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerUpgrade.new_ledger_version)
}

// optional uint32 new_base_fee = 2;
inline bool LedgerUpgrade::has_new_base_fee() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LedgerUpgrade::set_has_new_base_fee() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LedgerUpgrade::clear_has_new_base_fee() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LedgerUpgrade::clear_new_base_fee() {
  new_base_fee_ = 0u;
  clear_has_new_base_fee();
}
inline ::google::protobuf::uint32 LedgerUpgrade::new_base_fee() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerUpgrade.new_base_fee)
  return new_base_fee_;
}
inline void LedgerUpgrade::set_new_base_fee(::google::protobuf::uint32 value) {
  set_has_new_base_fee();
  new_base_fee_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerUpgrade.new_base_fee)
}

// optional uint32 new_base_reserve = 3;
inline bool LedgerUpgrade::has_new_base_reserve() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LedgerUpgrade::set_has_new_base_reserve() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LedgerUpgrade::clear_has_new_base_reserve() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LedgerUpgrade::clear_new_base_reserve() {
  new_base_reserve_ = 0u;
  clear_has_new_base_reserve();
}
inline ::google::protobuf::uint32 LedgerUpgrade::new_base_reserve() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerUpgrade.new_base_reserve)
  return new_base_reserve_;
}
inline void LedgerUpgrade::set_new_base_reserve(::google::protobuf::uint32 value) {
  set_has_new_base_reserve();
  new_base_reserve_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerUpgrade.new_base_reserve)
}

// -------------------------------------------------------------------

// Value

// required bytes hash_set = 1;
inline bool Value::has_hash_set() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Value::set_has_hash_set() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Value::clear_has_hash_set() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Value::clear_hash_set() {
  hash_set_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash_set();
}
inline const ::std::string& Value::hash_set() const {
  // @@protoc_insertion_point(field_get:protocol.Value.hash_set)
  return hash_set_.GetNoArena();
}
inline void Value::set_hash_set(const ::std::string& value) {
  set_has_hash_set();
  hash_set_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Value.hash_set)
}
#if LANG_CXX11
inline void Value::set_hash_set(::std::string&& value) {
  set_has_hash_set();
  hash_set_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Value.hash_set)
}
#endif
inline void Value::set_hash_set(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash_set();
  hash_set_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Value.hash_set)
}
inline void Value::set_hash_set(const void* value, size_t size) {
  set_has_hash_set();
  hash_set_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Value.hash_set)
}
inline ::std::string* Value::mutable_hash_set() {
  set_has_hash_set();
  // @@protoc_insertion_point(field_mutable:protocol.Value.hash_set)
  return hash_set_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Value::release_hash_set() {
  // @@protoc_insertion_point(field_release:protocol.Value.hash_set)
  clear_has_hash_set();
  return hash_set_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Value::set_allocated_hash_set(::std::string* hash_set) {
  if (hash_set != NULL) {
    set_has_hash_set();
  } else {
    clear_has_hash_set();
  }
  hash_set_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash_set);
  // @@protoc_insertion_point(field_set_allocated:protocol.Value.hash_set)
}

// required uint64 close_time = 2;
inline bool Value::has_close_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Value::set_has_close_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Value::clear_has_close_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Value::clear_close_time() {
  close_time_ = GOOGLE_ULONGLONG(0);
  clear_has_close_time();
}
inline ::google::protobuf::uint64 Value::close_time() const {
  // @@protoc_insertion_point(field_get:protocol.Value.close_time)
  return close_time_;
}
inline void Value::set_close_time(::google::protobuf::uint64 value) {
  set_has_close_time();
  close_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.Value.close_time)
}

// optional .protocol.LedgerUpgrade ledger_upgrade = 3;
inline bool Value::has_ledger_upgrade() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Value::set_has_ledger_upgrade() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Value::clear_has_ledger_upgrade() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Value::clear_ledger_upgrade() {
  if (ledger_upgrade_ != NULL) ledger_upgrade_->::protocol::LedgerUpgrade::Clear();
  clear_has_ledger_upgrade();
}
inline const ::protocol::LedgerUpgrade& Value::ledger_upgrade() const {
  // @@protoc_insertion_point(field_get:protocol.Value.ledger_upgrade)
  return ledger_upgrade_ != NULL ? *ledger_upgrade_
                         : *::protocol::LedgerUpgrade::internal_default_instance();
}
inline ::protocol::LedgerUpgrade* Value::mutable_ledger_upgrade() {
  set_has_ledger_upgrade();
  if (ledger_upgrade_ == NULL) {
    ledger_upgrade_ = new ::protocol::LedgerUpgrade;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Value.ledger_upgrade)
  return ledger_upgrade_;
}
inline ::protocol::LedgerUpgrade* Value::release_ledger_upgrade() {
  // @@protoc_insertion_point(field_release:protocol.Value.ledger_upgrade)
  clear_has_ledger_upgrade();
  ::protocol::LedgerUpgrade* temp = ledger_upgrade_;
  ledger_upgrade_ = NULL;
  return temp;
}
inline void Value::set_allocated_ledger_upgrade(::protocol::LedgerUpgrade* ledger_upgrade) {
  delete ledger_upgrade_;
  ledger_upgrade_ = ledger_upgrade;
  if (ledger_upgrade) {
    set_has_ledger_upgrade();
  } else {
    clear_has_ledger_upgrade();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Value.ledger_upgrade)
}

// -------------------------------------------------------------------

// LedgerHeader

// required bytes parent_hash = 1;
inline bool LedgerHeader::has_parent_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LedgerHeader::set_has_parent_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LedgerHeader::clear_has_parent_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LedgerHeader::clear_parent_hash() {
  parent_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parent_hash();
}
inline const ::std::string& LedgerHeader::parent_hash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.parent_hash)
  return parent_hash_.GetNoArena();
}
inline void LedgerHeader::set_parent_hash(const ::std::string& value) {
  set_has_parent_hash();
  parent_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.parent_hash)
}
#if LANG_CXX11
inline void LedgerHeader::set_parent_hash(::std::string&& value) {
  set_has_parent_hash();
  parent_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.LedgerHeader.parent_hash)
}
#endif
inline void LedgerHeader::set_parent_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parent_hash();
  parent_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeader.parent_hash)
}
inline void LedgerHeader::set_parent_hash(const void* value, size_t size) {
  set_has_parent_hash();
  parent_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeader.parent_hash)
}
inline ::std::string* LedgerHeader::mutable_parent_hash() {
  set_has_parent_hash();
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeader.parent_hash)
  return parent_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_parent_hash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeader.parent_hash)
  clear_has_parent_hash();
  return parent_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_parent_hash(::std::string* parent_hash) {
  if (parent_hash != NULL) {
    set_has_parent_hash();
  } else {
    clear_has_parent_hash();
  }
  parent_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeader.parent_hash)
}

// required bytes transaction_tree_hash = 2;
inline bool LedgerHeader::has_transaction_tree_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LedgerHeader::set_has_transaction_tree_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LedgerHeader::clear_has_transaction_tree_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LedgerHeader::clear_transaction_tree_hash() {
  transaction_tree_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_transaction_tree_hash();
}
inline const ::std::string& LedgerHeader::transaction_tree_hash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.transaction_tree_hash)
  return transaction_tree_hash_.GetNoArena();
}
inline void LedgerHeader::set_transaction_tree_hash(const ::std::string& value) {
  set_has_transaction_tree_hash();
  transaction_tree_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.transaction_tree_hash)
}
#if LANG_CXX11
inline void LedgerHeader::set_transaction_tree_hash(::std::string&& value) {
  set_has_transaction_tree_hash();
  transaction_tree_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.LedgerHeader.transaction_tree_hash)
}
#endif
inline void LedgerHeader::set_transaction_tree_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_transaction_tree_hash();
  transaction_tree_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeader.transaction_tree_hash)
}
inline void LedgerHeader::set_transaction_tree_hash(const void* value, size_t size) {
  set_has_transaction_tree_hash();
  transaction_tree_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeader.transaction_tree_hash)
}
inline ::std::string* LedgerHeader::mutable_transaction_tree_hash() {
  set_has_transaction_tree_hash();
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeader.transaction_tree_hash)
  return transaction_tree_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_transaction_tree_hash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeader.transaction_tree_hash)
  clear_has_transaction_tree_hash();
  return transaction_tree_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_transaction_tree_hash(::std::string* transaction_tree_hash) {
  if (transaction_tree_hash != NULL) {
    set_has_transaction_tree_hash();
  } else {
    clear_has_transaction_tree_hash();
  }
  transaction_tree_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transaction_tree_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeader.transaction_tree_hash)
}

// required bytes account_tree_hash = 3;
inline bool LedgerHeader::has_account_tree_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LedgerHeader::set_has_account_tree_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LedgerHeader::clear_has_account_tree_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LedgerHeader::clear_account_tree_hash() {
  account_tree_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account_tree_hash();
}
inline const ::std::string& LedgerHeader::account_tree_hash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.account_tree_hash)
  return account_tree_hash_.GetNoArena();
}
inline void LedgerHeader::set_account_tree_hash(const ::std::string& value) {
  set_has_account_tree_hash();
  account_tree_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.account_tree_hash)
}
#if LANG_CXX11
inline void LedgerHeader::set_account_tree_hash(::std::string&& value) {
  set_has_account_tree_hash();
  account_tree_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.LedgerHeader.account_tree_hash)
}
#endif
inline void LedgerHeader::set_account_tree_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account_tree_hash();
  account_tree_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeader.account_tree_hash)
}
inline void LedgerHeader::set_account_tree_hash(const void* value, size_t size) {
  set_has_account_tree_hash();
  account_tree_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeader.account_tree_hash)
}
inline ::std::string* LedgerHeader::mutable_account_tree_hash() {
  set_has_account_tree_hash();
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeader.account_tree_hash)
  return account_tree_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_account_tree_hash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeader.account_tree_hash)
  clear_has_account_tree_hash();
  return account_tree_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_account_tree_hash(::std::string* account_tree_hash) {
  if (account_tree_hash != NULL) {
    set_has_account_tree_hash();
  } else {
    clear_has_account_tree_hash();
  }
  account_tree_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_tree_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeader.account_tree_hash)
}

// required int64 ledger_sequence = 4;
inline bool LedgerHeader::has_ledger_sequence() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LedgerHeader::set_has_ledger_sequence() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LedgerHeader::clear_has_ledger_sequence() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LedgerHeader::clear_ledger_sequence() {
  ledger_sequence_ = GOOGLE_LONGLONG(0);
  clear_has_ledger_sequence();
}
inline ::google::protobuf::int64 LedgerHeader::ledger_sequence() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.ledger_sequence)
  return ledger_sequence_;
}
inline void LedgerHeader::set_ledger_sequence(::google::protobuf::int64 value) {
  set_has_ledger_sequence();
  ledger_sequence_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.ledger_sequence)
}

// required .protocol.Value consensus_value = 5;
inline bool LedgerHeader::has_consensus_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LedgerHeader::set_has_consensus_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LedgerHeader::clear_has_consensus_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LedgerHeader::clear_consensus_value() {
  if (consensus_value_ != NULL) consensus_value_->::protocol::Value::Clear();
  clear_has_consensus_value();
}
inline const ::protocol::Value& LedgerHeader::consensus_value() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.consensus_value)
  return consensus_value_ != NULL ? *consensus_value_
                         : *::protocol::Value::internal_default_instance();
}
inline ::protocol::Value* LedgerHeader::mutable_consensus_value() {
  set_has_consensus_value();
  if (consensus_value_ == NULL) {
    consensus_value_ = new ::protocol::Value;
  }
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeader.consensus_value)
  return consensus_value_;
}
inline ::protocol::Value* LedgerHeader::release_consensus_value() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeader.consensus_value)
  clear_has_consensus_value();
  ::protocol::Value* temp = consensus_value_;
  consensus_value_ = NULL;
  return temp;
}
inline void LedgerHeader::set_allocated_consensus_value(::protocol::Value* consensus_value) {
  delete consensus_value_;
  consensus_value_ = consensus_value;
  if (consensus_value) {
    set_has_consensus_value();
  } else {
    clear_has_consensus_value();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeader.consensus_value)
}

// required bytes hash = 6;
inline bool LedgerHeader::has_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LedgerHeader::set_has_hash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LedgerHeader::clear_has_hash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LedgerHeader::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& LedgerHeader::hash() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.hash)
  return hash_.GetNoArena();
}
inline void LedgerHeader::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.hash)
}
#if LANG_CXX11
inline void LedgerHeader::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.LedgerHeader.hash)
}
#endif
inline void LedgerHeader::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LedgerHeader.hash)
}
inline void LedgerHeader::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LedgerHeader.hash)
}
inline ::std::string* LedgerHeader::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:protocol.LedgerHeader.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LedgerHeader::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.LedgerHeader.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LedgerHeader::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.LedgerHeader.hash)
}

// required uint32 base_fee = 7;
inline bool LedgerHeader::has_base_fee() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LedgerHeader::set_has_base_fee() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LedgerHeader::clear_has_base_fee() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LedgerHeader::clear_base_fee() {
  base_fee_ = 0u;
  clear_has_base_fee();
}
inline ::google::protobuf::uint32 LedgerHeader::base_fee() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.base_fee)
  return base_fee_;
}
inline void LedgerHeader::set_base_fee(::google::protobuf::uint32 value) {
  set_has_base_fee();
  base_fee_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.base_fee)
}

// required uint32 base_reserve = 8;
inline bool LedgerHeader::has_base_reserve() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LedgerHeader::set_has_base_reserve() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LedgerHeader::clear_has_base_reserve() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LedgerHeader::clear_base_reserve() {
  base_reserve_ = 0u;
  clear_has_base_reserve();
}
inline ::google::protobuf::uint32 LedgerHeader::base_reserve() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.base_reserve)
  return base_reserve_;
}
inline void LedgerHeader::set_base_reserve(::google::protobuf::uint32 value) {
  set_has_base_reserve();
  base_reserve_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.base_reserve)
}

// required uint32 ledger_version = 9;
inline bool LedgerHeader::has_ledger_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LedgerHeader::set_has_ledger_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LedgerHeader::clear_has_ledger_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LedgerHeader::clear_ledger_version() {
  ledger_version_ = 0u;
  clear_has_ledger_version();
}
inline ::google::protobuf::uint32 LedgerHeader::ledger_version() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.ledger_version)
  return ledger_version_;
}
inline void LedgerHeader::set_ledger_version(::google::protobuf::uint32 value) {
  set_has_ledger_version();
  ledger_version_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.ledger_version)
}

// required int64 tx_count = 10;
inline bool LedgerHeader::has_tx_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LedgerHeader::set_has_tx_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LedgerHeader::clear_has_tx_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LedgerHeader::clear_tx_count() {
  tx_count_ = GOOGLE_LONGLONG(0);
  clear_has_tx_count();
}
inline ::google::protobuf::int64 LedgerHeader::tx_count() const {
  // @@protoc_insertion_point(field_get:protocol.LedgerHeader.tx_count)
  return tx_count_;
}
inline void LedgerHeader::set_tx_count(::google::protobuf::int64 value) {
  set_has_tx_count();
  tx_count_ = value;
  // @@protoc_insertion_point(field_set:protocol.LedgerHeader.tx_count)
}

// -------------------------------------------------------------------

// GetLedgers

// required int64 ledger_seq = 1;
inline bool GetLedgers::has_ledger_seq() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLedgers::set_has_ledger_seq() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLedgers::clear_has_ledger_seq() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLedgers::clear_ledger_seq() {
  ledger_seq_ = GOOGLE_LONGLONG(0);
  clear_has_ledger_seq();
}
inline ::google::protobuf::int64 GetLedgers::ledger_seq() const {
  // @@protoc_insertion_point(field_get:protocol.GetLedgers.ledger_seq)
  return ledger_seq_;
}
inline void GetLedgers::set_ledger_seq(::google::protobuf::int64 value) {
  set_has_ledger_seq();
  ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.GetLedgers.ledger_seq)
}

// optional int64 ledger_num = 2;
inline bool GetLedgers::has_ledger_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLedgers::set_has_ledger_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLedgers::clear_has_ledger_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLedgers::clear_ledger_num() {
  ledger_num_ = GOOGLE_LONGLONG(0);
  clear_has_ledger_num();
}
inline ::google::protobuf::int64 GetLedgers::ledger_num() const {
  // @@protoc_insertion_point(field_get:protocol.GetLedgers.ledger_num)
  return ledger_num_;
}
inline void GetLedgers::set_ledger_num(::google::protobuf::int64 value) {
  set_has_ledger_num();
  ledger_num_ = value;
  // @@protoc_insertion_point(field_set:protocol.GetLedgers.ledger_num)
}

// -------------------------------------------------------------------

// Ledger

// required .protocol.LedgerHeader ledger_header = 1;
inline bool Ledger::has_ledger_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ledger::set_has_ledger_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ledger::clear_has_ledger_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ledger::clear_ledger_header() {
  if (ledger_header_ != NULL) ledger_header_->::protocol::LedgerHeader::Clear();
  clear_has_ledger_header();
}
inline const ::protocol::LedgerHeader& Ledger::ledger_header() const {
  // @@protoc_insertion_point(field_get:protocol.Ledger.ledger_header)
  return ledger_header_ != NULL ? *ledger_header_
                         : *::protocol::LedgerHeader::internal_default_instance();
}
inline ::protocol::LedgerHeader* Ledger::mutable_ledger_header() {
  set_has_ledger_header();
  if (ledger_header_ == NULL) {
    ledger_header_ = new ::protocol::LedgerHeader;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Ledger.ledger_header)
  return ledger_header_;
}
inline ::protocol::LedgerHeader* Ledger::release_ledger_header() {
  // @@protoc_insertion_point(field_release:protocol.Ledger.ledger_header)
  clear_has_ledger_header();
  ::protocol::LedgerHeader* temp = ledger_header_;
  ledger_header_ = NULL;
  return temp;
}
inline void Ledger::set_allocated_ledger_header(::protocol::LedgerHeader* ledger_header) {
  delete ledger_header_;
  ledger_header_ = ledger_header;
  if (ledger_header) {
    set_has_ledger_header();
  } else {
    clear_has_ledger_header();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Ledger.ledger_header)
}

// repeated .protocol.TransactionEnv transaction_envs = 2;
inline int Ledger::transaction_envs_size() const {
  return transaction_envs_.size();
}
inline void Ledger::clear_transaction_envs() {
  transaction_envs_.Clear();
}
inline const ::protocol::TransactionEnv& Ledger::transaction_envs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Ledger.transaction_envs)
  return transaction_envs_.Get(index);
}
inline ::protocol::TransactionEnv* Ledger::mutable_transaction_envs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Ledger.transaction_envs)
  return transaction_envs_.Mutable(index);
}
inline ::protocol::TransactionEnv* Ledger::add_transaction_envs() {
  // @@protoc_insertion_point(field_add:protocol.Ledger.transaction_envs)
  return transaction_envs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >*
Ledger::mutable_transaction_envs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Ledger.transaction_envs)
  return &transaction_envs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >&
Ledger::transaction_envs() const {
  // @@protoc_insertion_point(field_list:protocol.Ledger.transaction_envs)
  return transaction_envs_;
}

// -------------------------------------------------------------------

// Ledgers

// repeated .protocol.Ledger ledger = 1;
inline int Ledgers::ledger_size() const {
  return ledger_.size();
}
inline void Ledgers::clear_ledger() {
  ledger_.Clear();
}
inline const ::protocol::Ledger& Ledgers::ledger(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Ledgers.ledger)
  return ledger_.Get(index);
}
inline ::protocol::Ledger* Ledgers::mutable_ledger(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Ledgers.ledger)
  return ledger_.Mutable(index);
}
inline ::protocol::Ledger* Ledgers::add_ledger() {
  // @@protoc_insertion_point(field_add:protocol.Ledgers.ledger)
  return ledger_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Ledger >*
Ledgers::mutable_ledger() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Ledgers.ledger)
  return &ledger_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Ledger >&
Ledgers::ledger() const {
  // @@protoc_insertion_point(field_list:protocol.Ledgers.ledger)
  return ledger_;
}

// optional .protocol.Ledgers.SyncCode sync_code = 2;
inline bool Ledgers::has_sync_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ledgers::set_has_sync_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ledgers::clear_has_sync_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ledgers::clear_sync_code() {
  sync_code_ = 0;
  clear_has_sync_code();
}
inline ::protocol::Ledgers_SyncCode Ledgers::sync_code() const {
  // @@protoc_insertion_point(field_get:protocol.Ledgers.sync_code)
  return static_cast< ::protocol::Ledgers_SyncCode >(sync_code_);
}
inline void Ledgers::set_sync_code(::protocol::Ledgers_SyncCode value) {
  assert(::protocol::Ledgers_SyncCode_IsValid(value));
  set_has_sync_code();
  sync_code_ = value;
  // @@protoc_insertion_point(field_set:protocol.Ledgers.sync_code)
}

// optional int32 max_ledgers = 3;
inline bool Ledgers::has_max_ledgers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ledgers::set_has_max_ledgers() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ledgers::clear_has_max_ledgers() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ledgers::clear_max_ledgers() {
  max_ledgers_ = 0;
  clear_has_max_ledgers();
}
inline ::google::protobuf::int32 Ledgers::max_ledgers() const {
  // @@protoc_insertion_point(field_get:protocol.Ledgers.max_ledgers)
  return max_ledgers_;
}
inline void Ledgers::set_max_ledgers(::google::protobuf::int32 value) {
  set_has_max_ledgers();
  max_ledgers_ = value;
  // @@protoc_insertion_point(field_set:protocol.Ledgers.max_ledgers)
}

// -------------------------------------------------------------------

// CloseTimeRange

// required int64 minTime = 1;
inline bool CloseTimeRange::has_mintime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseTimeRange::set_has_mintime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseTimeRange::clear_has_mintime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseTimeRange::clear_mintime() {
  mintime_ = GOOGLE_LONGLONG(0);
  clear_has_mintime();
}
inline ::google::protobuf::int64 CloseTimeRange::mintime() const {
  // @@protoc_insertion_point(field_get:protocol.CloseTimeRange.minTime)
  return mintime_;
}
inline void CloseTimeRange::set_mintime(::google::protobuf::int64 value) {
  set_has_mintime();
  mintime_ = value;
  // @@protoc_insertion_point(field_set:protocol.CloseTimeRange.minTime)
}

// required int64 maxTime = 2;
inline bool CloseTimeRange::has_maxtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CloseTimeRange::set_has_maxtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CloseTimeRange::clear_has_maxtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CloseTimeRange::clear_maxtime() {
  maxtime_ = GOOGLE_LONGLONG(0);
  clear_has_maxtime();
}
inline ::google::protobuf::int64 CloseTimeRange::maxtime() const {
  // @@protoc_insertion_point(field_get:protocol.CloseTimeRange.maxTime)
  return maxtime_;
}
inline void CloseTimeRange::set_maxtime(::google::protobuf::int64 value) {
  set_has_maxtime();
  maxtime_ = value;
  // @@protoc_insertion_point(field_set:protocol.CloseTimeRange.maxTime)
}

// -------------------------------------------------------------------

// AssetProperty

// required .protocol.AssetProperty.Type type = 1;
inline bool AssetProperty::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AssetProperty::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AssetProperty::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AssetProperty::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::protocol::AssetProperty_Type AssetProperty::type() const {
  // @@protoc_insertion_point(field_get:protocol.AssetProperty.type)
  return static_cast< ::protocol::AssetProperty_Type >(type_);
}
inline void AssetProperty::set_type(::protocol::AssetProperty_Type value) {
  assert(::protocol::AssetProperty_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.AssetProperty.type)
}

// required string issuer = 2;
inline bool AssetProperty::has_issuer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssetProperty::set_has_issuer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssetProperty::clear_has_issuer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssetProperty::clear_issuer() {
  issuer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_issuer();
}
inline const ::std::string& AssetProperty::issuer() const {
  // @@protoc_insertion_point(field_get:protocol.AssetProperty.issuer)
  return issuer_.GetNoArena();
}
inline void AssetProperty::set_issuer(const ::std::string& value) {
  set_has_issuer();
  issuer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.AssetProperty.issuer)
}
#if LANG_CXX11
inline void AssetProperty::set_issuer(::std::string&& value) {
  set_has_issuer();
  issuer_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.AssetProperty.issuer)
}
#endif
inline void AssetProperty::set_issuer(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_issuer();
  issuer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.AssetProperty.issuer)
}
inline void AssetProperty::set_issuer(const char* value, size_t size) {
  set_has_issuer();
  issuer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.AssetProperty.issuer)
}
inline ::std::string* AssetProperty::mutable_issuer() {
  set_has_issuer();
  // @@protoc_insertion_point(field_mutable:protocol.AssetProperty.issuer)
  return issuer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssetProperty::release_issuer() {
  // @@protoc_insertion_point(field_release:protocol.AssetProperty.issuer)
  clear_has_issuer();
  return issuer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetProperty::set_allocated_issuer(::std::string* issuer) {
  if (issuer != NULL) {
    set_has_issuer();
  } else {
    clear_has_issuer();
  }
  issuer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), issuer);
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetProperty.issuer)
}

// required string code = 3;
inline bool AssetProperty::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssetProperty::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssetProperty::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssetProperty::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_code();
}
inline const ::std::string& AssetProperty::code() const {
  // @@protoc_insertion_point(field_get:protocol.AssetProperty.code)
  return code_.GetNoArena();
}
inline void AssetProperty::set_code(const ::std::string& value) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.AssetProperty.code)
}
#if LANG_CXX11
inline void AssetProperty::set_code(::std::string&& value) {
  set_has_code();
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.AssetProperty.code)
}
#endif
inline void AssetProperty::set_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.AssetProperty.code)
}
inline void AssetProperty::set_code(const char* value, size_t size) {
  set_has_code();
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.AssetProperty.code)
}
inline ::std::string* AssetProperty::mutable_code() {
  set_has_code();
  // @@protoc_insertion_point(field_mutable:protocol.AssetProperty.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssetProperty::release_code() {
  // @@protoc_insertion_point(field_release:protocol.AssetProperty.code)
  clear_has_code();
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssetProperty::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    set_has_code();
  } else {
    clear_has_code();
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:protocol.AssetProperty.code)
}

// -------------------------------------------------------------------

// Detail

// required int64 amount = 1;
inline bool Detail::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Detail::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Detail::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Detail::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::int64 Detail::amount() const {
  // @@protoc_insertion_point(field_get:protocol.Detail.amount)
  return amount_;
}
inline void Detail::set_amount(::google::protobuf::int64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:protocol.Detail.amount)
}

// required int64 start = 2;
inline bool Detail::has_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Detail::set_has_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Detail::clear_has_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Detail::clear_start() {
  start_ = GOOGLE_LONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::int64 Detail::start() const {
  // @@protoc_insertion_point(field_get:protocol.Detail.start)
  return start_;
}
inline void Detail::set_start(::google::protobuf::int64 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:protocol.Detail.start)
}

// required int64 length = 3;
inline bool Detail::has_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Detail::set_has_length() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Detail::clear_has_length() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Detail::clear_length() {
  length_ = GOOGLE_LONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::int64 Detail::length() const {
  // @@protoc_insertion_point(field_get:protocol.Detail.length)
  return length_;
}
inline void Detail::set_length(::google::protobuf::int64 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:protocol.Detail.length)
}

// required string ext = 4;
inline bool Detail::has_ext() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Detail::set_has_ext() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Detail::clear_has_ext() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Detail::clear_ext() {
  ext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ext();
}
inline const ::std::string& Detail::ext() const {
  // @@protoc_insertion_point(field_get:protocol.Detail.ext)
  return ext_.GetNoArena();
}
inline void Detail::set_ext(const ::std::string& value) {
  set_has_ext();
  ext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Detail.ext)
}
#if LANG_CXX11
inline void Detail::set_ext(::std::string&& value) {
  set_has_ext();
  ext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Detail.ext)
}
#endif
inline void Detail::set_ext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ext();
  ext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Detail.ext)
}
inline void Detail::set_ext(const char* value, size_t size) {
  set_has_ext();
  ext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Detail.ext)
}
inline ::std::string* Detail::mutable_ext() {
  set_has_ext();
  // @@protoc_insertion_point(field_mutable:protocol.Detail.ext)
  return ext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Detail::release_ext() {
  // @@protoc_insertion_point(field_release:protocol.Detail.ext)
  clear_has_ext();
  return ext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Detail::set_allocated_ext(::std::string* ext) {
  if (ext != NULL) {
    set_has_ext();
  } else {
    clear_has_ext();
  }
  ext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ext);
  // @@protoc_insertion_point(field_set_allocated:protocol.Detail.ext)
}

// -------------------------------------------------------------------

// Asset

// required .protocol.AssetProperty property = 1;
inline bool Asset::has_property() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Asset::set_has_property() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Asset::clear_has_property() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Asset::clear_property() {
  if (property_ != NULL) property_->::protocol::AssetProperty::Clear();
  clear_has_property();
}
inline const ::protocol::AssetProperty& Asset::property() const {
  // @@protoc_insertion_point(field_get:protocol.Asset.property)
  return property_ != NULL ? *property_
                         : *::protocol::AssetProperty::internal_default_instance();
}
inline ::protocol::AssetProperty* Asset::mutable_property() {
  set_has_property();
  if (property_ == NULL) {
    property_ = new ::protocol::AssetProperty;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Asset.property)
  return property_;
}
inline ::protocol::AssetProperty* Asset::release_property() {
  // @@protoc_insertion_point(field_release:protocol.Asset.property)
  clear_has_property();
  ::protocol::AssetProperty* temp = property_;
  property_ = NULL;
  return temp;
}
inline void Asset::set_allocated_property(::protocol::AssetProperty* property) {
  delete property_;
  property_ = property;
  if (property) {
    set_has_property();
  } else {
    clear_has_property();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Asset.property)
}

// required int64 amount = 2;
inline bool Asset::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Asset::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Asset::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Asset::clear_amount() {
  amount_ = GOOGLE_LONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::int64 Asset::amount() const {
  // @@protoc_insertion_point(field_get:protocol.Asset.amount)
  return amount_;
}
inline void Asset::set_amount(::google::protobuf::int64 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:protocol.Asset.amount)
}

// repeated .protocol.Detail details = 3;
inline int Asset::details_size() const {
  return details_.size();
}
inline void Asset::clear_details() {
  details_.Clear();
}
inline const ::protocol::Detail& Asset::details(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Asset.details)
  return details_.Get(index);
}
inline ::protocol::Detail* Asset::mutable_details(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Asset.details)
  return details_.Mutable(index);
}
inline ::protocol::Detail* Asset::add_details() {
  // @@protoc_insertion_point(field_add:protocol.Asset.details)
  return details_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Detail >*
Asset::mutable_details() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Asset.details)
  return &details_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Detail >&
Asset::details() const {
  // @@protoc_insertion_point(field_list:protocol.Asset.details)
  return details_;
}

// -------------------------------------------------------------------

// OperationCreateAccount

// required string dest_address = 1;
inline bool OperationCreateAccount::has_dest_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationCreateAccount::set_has_dest_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationCreateAccount::clear_has_dest_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationCreateAccount::clear_dest_address() {
  dest_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dest_address();
}
inline const ::std::string& OperationCreateAccount::dest_address() const {
  // @@protoc_insertion_point(field_get:protocol.OperationCreateAccount.dest_address)
  return dest_address_.GetNoArena();
}
inline void OperationCreateAccount::set_dest_address(const ::std::string& value) {
  set_has_dest_address();
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationCreateAccount.dest_address)
}
#if LANG_CXX11
inline void OperationCreateAccount::set_dest_address(::std::string&& value) {
  set_has_dest_address();
  dest_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.OperationCreateAccount.dest_address)
}
#endif
inline void OperationCreateAccount::set_dest_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dest_address();
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationCreateAccount.dest_address)
}
inline void OperationCreateAccount::set_dest_address(const char* value, size_t size) {
  set_has_dest_address();
  dest_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationCreateAccount.dest_address)
}
inline ::std::string* OperationCreateAccount::mutable_dest_address() {
  set_has_dest_address();
  // @@protoc_insertion_point(field_mutable:protocol.OperationCreateAccount.dest_address)
  return dest_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationCreateAccount::release_dest_address() {
  // @@protoc_insertion_point(field_release:protocol.OperationCreateAccount.dest_address)
  clear_has_dest_address();
  return dest_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationCreateAccount::set_allocated_dest_address(::std::string* dest_address) {
  if (dest_address != NULL) {
    set_has_dest_address();
  } else {
    clear_has_dest_address();
  }
  dest_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationCreateAccount.dest_address)
}

// required int64 init_balance = 2;
inline bool OperationCreateAccount::has_init_balance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationCreateAccount::set_has_init_balance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationCreateAccount::clear_has_init_balance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationCreateAccount::clear_init_balance() {
  init_balance_ = GOOGLE_LONGLONG(0);
  clear_has_init_balance();
}
inline ::google::protobuf::int64 OperationCreateAccount::init_balance() const {
  // @@protoc_insertion_point(field_get:protocol.OperationCreateAccount.init_balance)
  return init_balance_;
}
inline void OperationCreateAccount::set_init_balance(::google::protobuf::int64 value) {
  set_has_init_balance();
  init_balance_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationCreateAccount.init_balance)
}

// optional .protocol.AccountThreshold thresholds = 3;
inline bool OperationCreateAccount::has_thresholds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationCreateAccount::set_has_thresholds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationCreateAccount::clear_has_thresholds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationCreateAccount::clear_thresholds() {
  if (thresholds_ != NULL) thresholds_->::protocol::AccountThreshold::Clear();
  clear_has_thresholds();
}
inline const ::protocol::AccountThreshold& OperationCreateAccount::thresholds() const {
  // @@protoc_insertion_point(field_get:protocol.OperationCreateAccount.thresholds)
  return thresholds_ != NULL ? *thresholds_
                         : *::protocol::AccountThreshold::internal_default_instance();
}
inline ::protocol::AccountThreshold* OperationCreateAccount::mutable_thresholds() {
  set_has_thresholds();
  if (thresholds_ == NULL) {
    thresholds_ = new ::protocol::AccountThreshold;
  }
  // @@protoc_insertion_point(field_mutable:protocol.OperationCreateAccount.thresholds)
  return thresholds_;
}
inline ::protocol::AccountThreshold* OperationCreateAccount::release_thresholds() {
  // @@protoc_insertion_point(field_release:protocol.OperationCreateAccount.thresholds)
  clear_has_thresholds();
  ::protocol::AccountThreshold* temp = thresholds_;
  thresholds_ = NULL;
  return temp;
}
inline void OperationCreateAccount::set_allocated_thresholds(::protocol::AccountThreshold* thresholds) {
  delete thresholds_;
  thresholds_ = thresholds;
  if (thresholds) {
    set_has_thresholds();
  } else {
    clear_has_thresholds();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationCreateAccount.thresholds)
}

// repeated .protocol.Signer signers = 4;
inline int OperationCreateAccount::signers_size() const {
  return signers_.size();
}
inline void OperationCreateAccount::clear_signers() {
  signers_.Clear();
}
inline const ::protocol::Signer& OperationCreateAccount::signers(int index) const {
  // @@protoc_insertion_point(field_get:protocol.OperationCreateAccount.signers)
  return signers_.Get(index);
}
inline ::protocol::Signer* OperationCreateAccount::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.OperationCreateAccount.signers)
  return signers_.Mutable(index);
}
inline ::protocol::Signer* OperationCreateAccount::add_signers() {
  // @@protoc_insertion_point(field_add:protocol.OperationCreateAccount.signers)
  return signers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Signer >*
OperationCreateAccount::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:protocol.OperationCreateAccount.signers)
  return &signers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Signer >&
OperationCreateAccount::signers() const {
  // @@protoc_insertion_point(field_list:protocol.OperationCreateAccount.signers)
  return signers_;
}

// optional bytes account_metadata = 5;
inline bool OperationCreateAccount::has_account_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationCreateAccount::set_has_account_metadata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationCreateAccount::clear_has_account_metadata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationCreateAccount::clear_account_metadata() {
  account_metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account_metadata();
}
inline const ::std::string& OperationCreateAccount::account_metadata() const {
  // @@protoc_insertion_point(field_get:protocol.OperationCreateAccount.account_metadata)
  return account_metadata_.GetNoArena();
}
inline void OperationCreateAccount::set_account_metadata(const ::std::string& value) {
  set_has_account_metadata();
  account_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationCreateAccount.account_metadata)
}
#if LANG_CXX11
inline void OperationCreateAccount::set_account_metadata(::std::string&& value) {
  set_has_account_metadata();
  account_metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.OperationCreateAccount.account_metadata)
}
#endif
inline void OperationCreateAccount::set_account_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account_metadata();
  account_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationCreateAccount.account_metadata)
}
inline void OperationCreateAccount::set_account_metadata(const void* value, size_t size) {
  set_has_account_metadata();
  account_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationCreateAccount.account_metadata)
}
inline ::std::string* OperationCreateAccount::mutable_account_metadata() {
  set_has_account_metadata();
  // @@protoc_insertion_point(field_mutable:protocol.OperationCreateAccount.account_metadata)
  return account_metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationCreateAccount::release_account_metadata() {
  // @@protoc_insertion_point(field_release:protocol.OperationCreateAccount.account_metadata)
  clear_has_account_metadata();
  return account_metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationCreateAccount::set_allocated_account_metadata(::std::string* account_metadata) {
  if (account_metadata != NULL) {
    set_has_account_metadata();
  } else {
    clear_has_account_metadata();
  }
  account_metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_metadata);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationCreateAccount.account_metadata)
}

// -------------------------------------------------------------------

// OperationPayment

// required string destAddress = 1;
inline bool OperationPayment::has_destaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationPayment::set_has_destaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationPayment::clear_has_destaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationPayment::clear_destaddress() {
  destaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destaddress();
}
inline const ::std::string& OperationPayment::destaddress() const {
  // @@protoc_insertion_point(field_get:protocol.OperationPayment.destAddress)
  return destaddress_.GetNoArena();
}
inline void OperationPayment::set_destaddress(const ::std::string& value) {
  set_has_destaddress();
  destaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationPayment.destAddress)
}
#if LANG_CXX11
inline void OperationPayment::set_destaddress(::std::string&& value) {
  set_has_destaddress();
  destaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.OperationPayment.destAddress)
}
#endif
inline void OperationPayment::set_destaddress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_destaddress();
  destaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationPayment.destAddress)
}
inline void OperationPayment::set_destaddress(const char* value, size_t size) {
  set_has_destaddress();
  destaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationPayment.destAddress)
}
inline ::std::string* OperationPayment::mutable_destaddress() {
  set_has_destaddress();
  // @@protoc_insertion_point(field_mutable:protocol.OperationPayment.destAddress)
  return destaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationPayment::release_destaddress() {
  // @@protoc_insertion_point(field_release:protocol.OperationPayment.destAddress)
  clear_has_destaddress();
  return destaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPayment::set_allocated_destaddress(::std::string* destaddress) {
  if (destaddress != NULL) {
    set_has_destaddress();
  } else {
    clear_has_destaddress();
  }
  destaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destaddress);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationPayment.destAddress)
}

// required .protocol.Asset asset = 2;
inline bool OperationPayment::has_asset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationPayment::set_has_asset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationPayment::clear_has_asset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationPayment::clear_asset() {
  if (asset_ != NULL) asset_->::protocol::Asset::Clear();
  clear_has_asset();
}
inline const ::protocol::Asset& OperationPayment::asset() const {
  // @@protoc_insertion_point(field_get:protocol.OperationPayment.asset)
  return asset_ != NULL ? *asset_
                         : *::protocol::Asset::internal_default_instance();
}
inline ::protocol::Asset* OperationPayment::mutable_asset() {
  set_has_asset();
  if (asset_ == NULL) {
    asset_ = new ::protocol::Asset;
  }
  // @@protoc_insertion_point(field_mutable:protocol.OperationPayment.asset)
  return asset_;
}
inline ::protocol::Asset* OperationPayment::release_asset() {
  // @@protoc_insertion_point(field_release:protocol.OperationPayment.asset)
  clear_has_asset();
  ::protocol::Asset* temp = asset_;
  asset_ = NULL;
  return temp;
}
inline void OperationPayment::set_allocated_asset(::protocol::Asset* asset) {
  delete asset_;
  asset_ = asset;
  if (asset) {
    set_has_asset();
  } else {
    clear_has_asset();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationPayment.asset)
}

// -------------------------------------------------------------------

// OperationInitPayment

// required string destAddress = 1;
inline bool OperationInitPayment::has_destaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationInitPayment::set_has_destaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationInitPayment::clear_has_destaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationInitPayment::clear_destaddress() {
  destaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destaddress();
}
inline const ::std::string& OperationInitPayment::destaddress() const {
  // @@protoc_insertion_point(field_get:protocol.OperationInitPayment.destAddress)
  return destaddress_.GetNoArena();
}
inline void OperationInitPayment::set_destaddress(const ::std::string& value) {
  set_has_destaddress();
  destaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationInitPayment.destAddress)
}
#if LANG_CXX11
inline void OperationInitPayment::set_destaddress(::std::string&& value) {
  set_has_destaddress();
  destaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.OperationInitPayment.destAddress)
}
#endif
inline void OperationInitPayment::set_destaddress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_destaddress();
  destaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationInitPayment.destAddress)
}
inline void OperationInitPayment::set_destaddress(const char* value, size_t size) {
  set_has_destaddress();
  destaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationInitPayment.destAddress)
}
inline ::std::string* OperationInitPayment::mutable_destaddress() {
  set_has_destaddress();
  // @@protoc_insertion_point(field_mutable:protocol.OperationInitPayment.destAddress)
  return destaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationInitPayment::release_destaddress() {
  // @@protoc_insertion_point(field_release:protocol.OperationInitPayment.destAddress)
  clear_has_destaddress();
  return destaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationInitPayment::set_allocated_destaddress(::std::string* destaddress) {
  if (destaddress != NULL) {
    set_has_destaddress();
  } else {
    clear_has_destaddress();
  }
  destaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destaddress);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationInitPayment.destAddress)
}

// required .protocol.Asset asset = 2;
inline bool OperationInitPayment::has_asset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationInitPayment::set_has_asset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationInitPayment::clear_has_asset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationInitPayment::clear_asset() {
  if (asset_ != NULL) asset_->::protocol::Asset::Clear();
  clear_has_asset();
}
inline const ::protocol::Asset& OperationInitPayment::asset() const {
  // @@protoc_insertion_point(field_get:protocol.OperationInitPayment.asset)
  return asset_ != NULL ? *asset_
                         : *::protocol::Asset::internal_default_instance();
}
inline ::protocol::Asset* OperationInitPayment::mutable_asset() {
  set_has_asset();
  if (asset_ == NULL) {
    asset_ = new ::protocol::Asset;
  }
  // @@protoc_insertion_point(field_mutable:protocol.OperationInitPayment.asset)
  return asset_;
}
inline ::protocol::Asset* OperationInitPayment::release_asset() {
  // @@protoc_insertion_point(field_release:protocol.OperationInitPayment.asset)
  clear_has_asset();
  ::protocol::Asset* temp = asset_;
  asset_ = NULL;
  return temp;
}
inline void OperationInitPayment::set_allocated_asset(::protocol::Asset* asset) {
  delete asset_;
  asset_ = asset;
  if (asset) {
    set_has_asset();
  } else {
    clear_has_asset();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationInitPayment.asset)
}

// -------------------------------------------------------------------

// OperationIssueAsset

// required .protocol.Asset asset = 1;
inline bool OperationIssueAsset::has_asset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationIssueAsset::set_has_asset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationIssueAsset::clear_has_asset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationIssueAsset::clear_asset() {
  if (asset_ != NULL) asset_->::protocol::Asset::Clear();
  clear_has_asset();
}
inline const ::protocol::Asset& OperationIssueAsset::asset() const {
  // @@protoc_insertion_point(field_get:protocol.OperationIssueAsset.asset)
  return asset_ != NULL ? *asset_
                         : *::protocol::Asset::internal_default_instance();
}
inline ::protocol::Asset* OperationIssueAsset::mutable_asset() {
  set_has_asset();
  if (asset_ == NULL) {
    asset_ = new ::protocol::Asset;
  }
  // @@protoc_insertion_point(field_mutable:protocol.OperationIssueAsset.asset)
  return asset_;
}
inline ::protocol::Asset* OperationIssueAsset::release_asset() {
  // @@protoc_insertion_point(field_release:protocol.OperationIssueAsset.asset)
  clear_has_asset();
  ::protocol::Asset* temp = asset_;
  asset_ = NULL;
  return temp;
}
inline void OperationIssueAsset::set_allocated_asset(::protocol::Asset* asset) {
  delete asset_;
  asset_ = asset;
  if (asset) {
    set_has_asset();
  } else {
    clear_has_asset();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationIssueAsset.asset)
}

// -------------------------------------------------------------------

// UniqueAsset

// required .protocol.AssetProperty property = 1;
inline bool UniqueAsset::has_property() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UniqueAsset::set_has_property() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UniqueAsset::clear_has_property() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UniqueAsset::clear_property() {
  if (property_ != NULL) property_->::protocol::AssetProperty::Clear();
  clear_has_property();
}
inline const ::protocol::AssetProperty& UniqueAsset::property() const {
  // @@protoc_insertion_point(field_get:protocol.UniqueAsset.property)
  return property_ != NULL ? *property_
                         : *::protocol::AssetProperty::internal_default_instance();
}
inline ::protocol::AssetProperty* UniqueAsset::mutable_property() {
  set_has_property();
  if (property_ == NULL) {
    property_ = new ::protocol::AssetProperty;
  }
  // @@protoc_insertion_point(field_mutable:protocol.UniqueAsset.property)
  return property_;
}
inline ::protocol::AssetProperty* UniqueAsset::release_property() {
  // @@protoc_insertion_point(field_release:protocol.UniqueAsset.property)
  clear_has_property();
  ::protocol::AssetProperty* temp = property_;
  property_ = NULL;
  return temp;
}
inline void UniqueAsset::set_allocated_property(::protocol::AssetProperty* property) {
  delete property_;
  property_ = property;
  if (property) {
    set_has_property();
  } else {
    clear_has_property();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.UniqueAsset.property)
}

// required bytes detailed = 2;
inline bool UniqueAsset::has_detailed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UniqueAsset::set_has_detailed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UniqueAsset::clear_has_detailed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UniqueAsset::clear_detailed() {
  detailed_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_detailed();
}
inline const ::std::string& UniqueAsset::detailed() const {
  // @@protoc_insertion_point(field_get:protocol.UniqueAsset.detailed)
  return detailed_.GetNoArena();
}
inline void UniqueAsset::set_detailed(const ::std::string& value) {
  set_has_detailed();
  detailed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.UniqueAsset.detailed)
}
#if LANG_CXX11
inline void UniqueAsset::set_detailed(::std::string&& value) {
  set_has_detailed();
  detailed_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.UniqueAsset.detailed)
}
#endif
inline void UniqueAsset::set_detailed(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_detailed();
  detailed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.UniqueAsset.detailed)
}
inline void UniqueAsset::set_detailed(const void* value, size_t size) {
  set_has_detailed();
  detailed_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.UniqueAsset.detailed)
}
inline ::std::string* UniqueAsset::mutable_detailed() {
  set_has_detailed();
  // @@protoc_insertion_point(field_mutable:protocol.UniqueAsset.detailed)
  return detailed_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UniqueAsset::release_detailed() {
  // @@protoc_insertion_point(field_release:protocol.UniqueAsset.detailed)
  clear_has_detailed();
  return detailed_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UniqueAsset::set_allocated_detailed(::std::string* detailed) {
  if (detailed != NULL) {
    set_has_detailed();
  } else {
    clear_has_detailed();
  }
  detailed_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detailed);
  // @@protoc_insertion_point(field_set_allocated:protocol.UniqueAsset.detailed)
}

// -------------------------------------------------------------------

// OperationPaymentUniqueAsset

// required string destAddress = 1;
inline bool OperationPaymentUniqueAsset::has_destaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationPaymentUniqueAsset::set_has_destaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationPaymentUniqueAsset::clear_has_destaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationPaymentUniqueAsset::clear_destaddress() {
  destaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destaddress();
}
inline const ::std::string& OperationPaymentUniqueAsset::destaddress() const {
  // @@protoc_insertion_point(field_get:protocol.OperationPaymentUniqueAsset.destAddress)
  return destaddress_.GetNoArena();
}
inline void OperationPaymentUniqueAsset::set_destaddress(const ::std::string& value) {
  set_has_destaddress();
  destaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationPaymentUniqueAsset.destAddress)
}
#if LANG_CXX11
inline void OperationPaymentUniqueAsset::set_destaddress(::std::string&& value) {
  set_has_destaddress();
  destaddress_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.OperationPaymentUniqueAsset.destAddress)
}
#endif
inline void OperationPaymentUniqueAsset::set_destaddress(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_destaddress();
  destaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationPaymentUniqueAsset.destAddress)
}
inline void OperationPaymentUniqueAsset::set_destaddress(const char* value, size_t size) {
  set_has_destaddress();
  destaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationPaymentUniqueAsset.destAddress)
}
inline ::std::string* OperationPaymentUniqueAsset::mutable_destaddress() {
  set_has_destaddress();
  // @@protoc_insertion_point(field_mutable:protocol.OperationPaymentUniqueAsset.destAddress)
  return destaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationPaymentUniqueAsset::release_destaddress() {
  // @@protoc_insertion_point(field_release:protocol.OperationPaymentUniqueAsset.destAddress)
  clear_has_destaddress();
  return destaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationPaymentUniqueAsset::set_allocated_destaddress(::std::string* destaddress) {
  if (destaddress != NULL) {
    set_has_destaddress();
  } else {
    clear_has_destaddress();
  }
  destaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destaddress);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationPaymentUniqueAsset.destAddress)
}

// required .protocol.AssetProperty asset_pro = 2;
inline bool OperationPaymentUniqueAsset::has_asset_pro() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationPaymentUniqueAsset::set_has_asset_pro() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationPaymentUniqueAsset::clear_has_asset_pro() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationPaymentUniqueAsset::clear_asset_pro() {
  if (asset_pro_ != NULL) asset_pro_->::protocol::AssetProperty::Clear();
  clear_has_asset_pro();
}
inline const ::protocol::AssetProperty& OperationPaymentUniqueAsset::asset_pro() const {
  // @@protoc_insertion_point(field_get:protocol.OperationPaymentUniqueAsset.asset_pro)
  return asset_pro_ != NULL ? *asset_pro_
                         : *::protocol::AssetProperty::internal_default_instance();
}
inline ::protocol::AssetProperty* OperationPaymentUniqueAsset::mutable_asset_pro() {
  set_has_asset_pro();
  if (asset_pro_ == NULL) {
    asset_pro_ = new ::protocol::AssetProperty;
  }
  // @@protoc_insertion_point(field_mutable:protocol.OperationPaymentUniqueAsset.asset_pro)
  return asset_pro_;
}
inline ::protocol::AssetProperty* OperationPaymentUniqueAsset::release_asset_pro() {
  // @@protoc_insertion_point(field_release:protocol.OperationPaymentUniqueAsset.asset_pro)
  clear_has_asset_pro();
  ::protocol::AssetProperty* temp = asset_pro_;
  asset_pro_ = NULL;
  return temp;
}
inline void OperationPaymentUniqueAsset::set_allocated_asset_pro(::protocol::AssetProperty* asset_pro) {
  delete asset_pro_;
  asset_pro_ = asset_pro;
  if (asset_pro) {
    set_has_asset_pro();
  } else {
    clear_has_asset_pro();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationPaymentUniqueAsset.asset_pro)
}

// -------------------------------------------------------------------

// OperationRecord

// optional string address = 1;
inline bool OperationRecord::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationRecord::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationRecord::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationRecord::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& OperationRecord::address() const {
  // @@protoc_insertion_point(field_get:protocol.OperationRecord.address)
  return address_.GetNoArena();
}
inline void OperationRecord::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationRecord.address)
}
#if LANG_CXX11
inline void OperationRecord::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.OperationRecord.address)
}
#endif
inline void OperationRecord::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationRecord.address)
}
inline void OperationRecord::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationRecord.address)
}
inline ::std::string* OperationRecord::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:protocol.OperationRecord.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationRecord::release_address() {
  // @@protoc_insertion_point(field_release:protocol.OperationRecord.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationRecord::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationRecord.address)
}

// required string id = 2;
inline bool OperationRecord::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationRecord::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationRecord::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationRecord::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& OperationRecord::id() const {
  // @@protoc_insertion_point(field_get:protocol.OperationRecord.id)
  return id_.GetNoArena();
}
inline void OperationRecord::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationRecord.id)
}
#if LANG_CXX11
inline void OperationRecord::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.OperationRecord.id)
}
#endif
inline void OperationRecord::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationRecord.id)
}
inline void OperationRecord::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationRecord.id)
}
inline ::std::string* OperationRecord::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:protocol.OperationRecord.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationRecord::release_id() {
  // @@protoc_insertion_point(field_release:protocol.OperationRecord.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationRecord::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationRecord.id)
}

// required bytes ext = 3;
inline bool OperationRecord::has_ext() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationRecord::set_has_ext() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationRecord::clear_has_ext() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationRecord::clear_ext() {
  ext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ext();
}
inline const ::std::string& OperationRecord::ext() const {
  // @@protoc_insertion_point(field_get:protocol.OperationRecord.ext)
  return ext_.GetNoArena();
}
inline void OperationRecord::set_ext(const ::std::string& value) {
  set_has_ext();
  ext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationRecord.ext)
}
#if LANG_CXX11
inline void OperationRecord::set_ext(::std::string&& value) {
  set_has_ext();
  ext_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.OperationRecord.ext)
}
#endif
inline void OperationRecord::set_ext(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ext();
  ext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationRecord.ext)
}
inline void OperationRecord::set_ext(const void* value, size_t size) {
  set_has_ext();
  ext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationRecord.ext)
}
inline ::std::string* OperationRecord::mutable_ext() {
  set_has_ext();
  // @@protoc_insertion_point(field_mutable:protocol.OperationRecord.ext)
  return ext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationRecord::release_ext() {
  // @@protoc_insertion_point(field_release:protocol.OperationRecord.ext)
  clear_has_ext();
  return ext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationRecord::set_allocated_ext(::std::string* ext) {
  if (ext != NULL) {
    set_has_ext();
  } else {
    clear_has_ext();
  }
  ext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ext);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationRecord.ext)
}

// -------------------------------------------------------------------

// OperationIssueUniqueAsset

// required .protocol.UniqueAsset asset = 1;
inline bool OperationIssueUniqueAsset::has_asset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationIssueUniqueAsset::set_has_asset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationIssueUniqueAsset::clear_has_asset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationIssueUniqueAsset::clear_asset() {
  if (asset_ != NULL) asset_->::protocol::UniqueAsset::Clear();
  clear_has_asset();
}
inline const ::protocol::UniqueAsset& OperationIssueUniqueAsset::asset() const {
  // @@protoc_insertion_point(field_get:protocol.OperationIssueUniqueAsset.asset)
  return asset_ != NULL ? *asset_
                         : *::protocol::UniqueAsset::internal_default_instance();
}
inline ::protocol::UniqueAsset* OperationIssueUniqueAsset::mutable_asset() {
  set_has_asset();
  if (asset_ == NULL) {
    asset_ = new ::protocol::UniqueAsset;
  }
  // @@protoc_insertion_point(field_mutable:protocol.OperationIssueUniqueAsset.asset)
  return asset_;
}
inline ::protocol::UniqueAsset* OperationIssueUniqueAsset::release_asset() {
  // @@protoc_insertion_point(field_release:protocol.OperationIssueUniqueAsset.asset)
  clear_has_asset();
  ::protocol::UniqueAsset* temp = asset_;
  asset_ = NULL;
  return temp;
}
inline void OperationIssueUniqueAsset::set_allocated_asset(::protocol::UniqueAsset* asset) {
  delete asset_;
  asset_ = asset;
  if (asset) {
    set_has_asset();
  } else {
    clear_has_asset();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationIssueUniqueAsset.asset)
}

// -------------------------------------------------------------------

// OperationSetOptions

// optional uint32 master_weight = 1;
inline bool OperationSetOptions::has_master_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationSetOptions::set_has_master_weight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationSetOptions::clear_has_master_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationSetOptions::clear_master_weight() {
  master_weight_ = 0u;
  clear_has_master_weight();
}
inline ::google::protobuf::uint32 OperationSetOptions::master_weight() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetOptions.master_weight)
  return master_weight_;
}
inline void OperationSetOptions::set_master_weight(::google::protobuf::uint32 value) {
  set_has_master_weight();
  master_weight_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationSetOptions.master_weight)
}

// optional uint32 low_threshold = 2;
inline bool OperationSetOptions::has_low_threshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationSetOptions::set_has_low_threshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationSetOptions::clear_has_low_threshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationSetOptions::clear_low_threshold() {
  low_threshold_ = 0u;
  clear_has_low_threshold();
}
inline ::google::protobuf::uint32 OperationSetOptions::low_threshold() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetOptions.low_threshold)
  return low_threshold_;
}
inline void OperationSetOptions::set_low_threshold(::google::protobuf::uint32 value) {
  set_has_low_threshold();
  low_threshold_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationSetOptions.low_threshold)
}

// optional uint32 med_threshold = 3;
inline bool OperationSetOptions::has_med_threshold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperationSetOptions::set_has_med_threshold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperationSetOptions::clear_has_med_threshold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperationSetOptions::clear_med_threshold() {
  med_threshold_ = 0u;
  clear_has_med_threshold();
}
inline ::google::protobuf::uint32 OperationSetOptions::med_threshold() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetOptions.med_threshold)
  return med_threshold_;
}
inline void OperationSetOptions::set_med_threshold(::google::protobuf::uint32 value) {
  set_has_med_threshold();
  med_threshold_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationSetOptions.med_threshold)
}

// optional uint32 high_threshold = 4;
inline bool OperationSetOptions::has_high_threshold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperationSetOptions::set_has_high_threshold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperationSetOptions::clear_has_high_threshold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperationSetOptions::clear_high_threshold() {
  high_threshold_ = 0u;
  clear_has_high_threshold();
}
inline ::google::protobuf::uint32 OperationSetOptions::high_threshold() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetOptions.high_threshold)
  return high_threshold_;
}
inline void OperationSetOptions::set_high_threshold(::google::protobuf::uint32 value) {
  set_has_high_threshold();
  high_threshold_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationSetOptions.high_threshold)
}

// repeated .protocol.Signer signers = 5;
inline int OperationSetOptions::signers_size() const {
  return signers_.size();
}
inline void OperationSetOptions::clear_signers() {
  signers_.Clear();
}
inline const ::protocol::Signer& OperationSetOptions::signers(int index) const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetOptions.signers)
  return signers_.Get(index);
}
inline ::protocol::Signer* OperationSetOptions::mutable_signers(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.OperationSetOptions.signers)
  return signers_.Mutable(index);
}
inline ::protocol::Signer* OperationSetOptions::add_signers() {
  // @@protoc_insertion_point(field_add:protocol.OperationSetOptions.signers)
  return signers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Signer >*
OperationSetOptions::mutable_signers() {
  // @@protoc_insertion_point(field_mutable_list:protocol.OperationSetOptions.signers)
  return &signers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Signer >&
OperationSetOptions::signers() const {
  // @@protoc_insertion_point(field_list:protocol.OperationSetOptions.signers)
  return signers_;
}

// optional bytes account_metadata = 6;
inline bool OperationSetOptions::has_account_metadata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationSetOptions::set_has_account_metadata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationSetOptions::clear_has_account_metadata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationSetOptions::clear_account_metadata() {
  account_metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account_metadata();
}
inline const ::std::string& OperationSetOptions::account_metadata() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetOptions.account_metadata)
  return account_metadata_.GetNoArena();
}
inline void OperationSetOptions::set_account_metadata(const ::std::string& value) {
  set_has_account_metadata();
  account_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.OperationSetOptions.account_metadata)
}
#if LANG_CXX11
inline void OperationSetOptions::set_account_metadata(::std::string&& value) {
  set_has_account_metadata();
  account_metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.OperationSetOptions.account_metadata)
}
#endif
inline void OperationSetOptions::set_account_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account_metadata();
  account_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.OperationSetOptions.account_metadata)
}
inline void OperationSetOptions::set_account_metadata(const void* value, size_t size) {
  set_has_account_metadata();
  account_metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.OperationSetOptions.account_metadata)
}
inline ::std::string* OperationSetOptions::mutable_account_metadata() {
  set_has_account_metadata();
  // @@protoc_insertion_point(field_mutable:protocol.OperationSetOptions.account_metadata)
  return account_metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationSetOptions::release_account_metadata() {
  // @@protoc_insertion_point(field_release:protocol.OperationSetOptions.account_metadata)
  clear_has_account_metadata();
  return account_metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationSetOptions::set_allocated_account_metadata(::std::string* account_metadata) {
  if (account_metadata != NULL) {
    set_has_account_metadata();
  } else {
    clear_has_account_metadata();
  }
  account_metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account_metadata);
  // @@protoc_insertion_point(field_set_allocated:protocol.OperationSetOptions.account_metadata)
}

// optional int64 account_metadata_version = 7;
inline bool OperationSetOptions::has_account_metadata_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OperationSetOptions::set_has_account_metadata_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OperationSetOptions::clear_has_account_metadata_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OperationSetOptions::clear_account_metadata_version() {
  account_metadata_version_ = GOOGLE_LONGLONG(0);
  clear_has_account_metadata_version();
}
inline ::google::protobuf::int64 OperationSetOptions::account_metadata_version() const {
  // @@protoc_insertion_point(field_get:protocol.OperationSetOptions.account_metadata_version)
  return account_metadata_version_;
}
inline void OperationSetOptions::set_account_metadata_version(::google::protobuf::int64 value) {
  set_has_account_metadata_version();
  account_metadata_version_ = value;
  // @@protoc_insertion_point(field_set:protocol.OperationSetOptions.account_metadata_version)
}

// -------------------------------------------------------------------

// Input

// required bytes hash = 1;
inline bool Input::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& Input::hash() const {
  // @@protoc_insertion_point(field_get:protocol.Input.hash)
  return hash_.GetNoArena();
}
inline void Input::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Input.hash)
}
#if LANG_CXX11
inline void Input::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Input.hash)
}
#endif
inline void Input::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Input.hash)
}
inline void Input::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Input.hash)
}
inline ::std::string* Input::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:protocol.Input.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.Input.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.Input.hash)
}

// required int64 index = 2;
inline bool Input::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Input::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Input::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Input::clear_index() {
  index_ = GOOGLE_LONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::int64 Input::index() const {
  // @@protoc_insertion_point(field_get:protocol.Input.index)
  return index_;
}
inline void Input::set_index(::google::protobuf::int64 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:protocol.Input.index)
}

// optional bytes metadata = 3;
inline bool Input::has_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Input::set_has_metadata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Input::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Input::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_metadata();
}
inline const ::std::string& Input::metadata() const {
  // @@protoc_insertion_point(field_get:protocol.Input.metadata)
  return metadata_.GetNoArena();
}
inline void Input::set_metadata(const ::std::string& value) {
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Input.metadata)
}
#if LANG_CXX11
inline void Input::set_metadata(::std::string&& value) {
  set_has_metadata();
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Input.metadata)
}
#endif
inline void Input::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Input.metadata)
}
inline void Input::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Input.metadata)
}
inline ::std::string* Input::mutable_metadata() {
  set_has_metadata();
  // @@protoc_insertion_point(field_mutable:protocol.Input.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Input::release_metadata() {
  // @@protoc_insertion_point(field_release:protocol.Input.metadata)
  clear_has_metadata();
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Input::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    set_has_metadata();
  } else {
    clear_has_metadata();
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:protocol.Input.metadata)
}

// -------------------------------------------------------------------

// Output

// required string address = 1;
inline bool Output::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Output::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Output::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Output::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_address();
}
inline const ::std::string& Output::address() const {
  // @@protoc_insertion_point(field_get:protocol.Output.address)
  return address_.GetNoArena();
}
inline void Output::set_address(const ::std::string& value) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Output.address)
}
#if LANG_CXX11
inline void Output::set_address(::std::string&& value) {
  set_has_address();
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Output.address)
}
#endif
inline void Output::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Output.address)
}
inline void Output::set_address(const char* value, size_t size) {
  set_has_address();
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Output.address)
}
inline ::std::string* Output::mutable_address() {
  set_has_address();
  // @@protoc_insertion_point(field_mutable:protocol.Output.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Output::release_address() {
  // @@protoc_insertion_point(field_release:protocol.Output.address)
  clear_has_address();
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Output::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    set_has_address();
  } else {
    clear_has_address();
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Output.address)
}

// optional bytes metadata = 2;
inline bool Output::has_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Output::set_has_metadata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Output::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Output::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_metadata();
}
inline const ::std::string& Output::metadata() const {
  // @@protoc_insertion_point(field_get:protocol.Output.metadata)
  return metadata_.GetNoArena();
}
inline void Output::set_metadata(const ::std::string& value) {
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Output.metadata)
}
#if LANG_CXX11
inline void Output::set_metadata(::std::string&& value) {
  set_has_metadata();
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Output.metadata)
}
#endif
inline void Output::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Output.metadata)
}
inline void Output::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Output.metadata)
}
inline ::std::string* Output::mutable_metadata() {
  set_has_metadata();
  // @@protoc_insertion_point(field_mutable:protocol.Output.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Output::release_metadata() {
  // @@protoc_insertion_point(field_release:protocol.Output.metadata)
  clear_has_metadata();
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Output::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    set_has_metadata();
  } else {
    clear_has_metadata();
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:protocol.Output.metadata)
}

// -------------------------------------------------------------------

// OperationProduction

// repeated .protocol.Input inputs = 1;
inline int OperationProduction::inputs_size() const {
  return inputs_.size();
}
inline void OperationProduction::clear_inputs() {
  inputs_.Clear();
}
inline const ::protocol::Input& OperationProduction::inputs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.OperationProduction.inputs)
  return inputs_.Get(index);
}
inline ::protocol::Input* OperationProduction::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.OperationProduction.inputs)
  return inputs_.Mutable(index);
}
inline ::protocol::Input* OperationProduction::add_inputs() {
  // @@protoc_insertion_point(field_add:protocol.OperationProduction.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Input >*
OperationProduction::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.OperationProduction.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Input >&
OperationProduction::inputs() const {
  // @@protoc_insertion_point(field_list:protocol.OperationProduction.inputs)
  return inputs_;
}

// repeated .protocol.Output outputs = 2;
inline int OperationProduction::outputs_size() const {
  return outputs_.size();
}
inline void OperationProduction::clear_outputs() {
  outputs_.Clear();
}
inline const ::protocol::Output& OperationProduction::outputs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.OperationProduction.outputs)
  return outputs_.Get(index);
}
inline ::protocol::Output* OperationProduction::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.OperationProduction.outputs)
  return outputs_.Mutable(index);
}
inline ::protocol::Output* OperationProduction::add_outputs() {
  // @@protoc_insertion_point(field_add:protocol.OperationProduction.outputs)
  return outputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Output >*
OperationProduction::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.OperationProduction.outputs)
  return &outputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Output >&
OperationProduction::outputs() const {
  // @@protoc_insertion_point(field_list:protocol.OperationProduction.outputs)
  return outputs_;
}

// -------------------------------------------------------------------

// OperationManageOrder

// -------------------------------------------------------------------

// Operation

// required .protocol.Operation.Type type = 1;
inline bool Operation::has_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Operation::set_has_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Operation::clear_has_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Operation::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::protocol::Operation_Type Operation::type() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.type)
  return static_cast< ::protocol::Operation_Type >(type_);
}
inline void Operation::set_type(::protocol::Operation_Type value) {
  assert(::protocol::Operation_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.Operation.type)
}

// optional string source_address = 2;
inline bool Operation::has_source_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operation::set_has_source_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operation::clear_has_source_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operation::clear_source_address() {
  source_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source_address();
}
inline const ::std::string& Operation::source_address() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.source_address)
  return source_address_.GetNoArena();
}
inline void Operation::set_source_address(const ::std::string& value) {
  set_has_source_address();
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Operation.source_address)
}
#if LANG_CXX11
inline void Operation::set_source_address(::std::string&& value) {
  set_has_source_address();
  source_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Operation.source_address)
}
#endif
inline void Operation::set_source_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source_address();
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Operation.source_address)
}
inline void Operation::set_source_address(const char* value, size_t size) {
  set_has_source_address();
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Operation.source_address)
}
inline ::std::string* Operation::mutable_source_address() {
  set_has_source_address();
  // @@protoc_insertion_point(field_mutable:protocol.Operation.source_address)
  return source_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Operation::release_source_address() {
  // @@protoc_insertion_point(field_release:protocol.Operation.source_address)
  clear_has_source_address();
  return source_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operation::set_allocated_source_address(::std::string* source_address) {
  if (source_address != NULL) {
    set_has_source_address();
  } else {
    clear_has_source_address();
  }
  source_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.source_address)
}

// optional .protocol.OperationCreateAccount create_account = 3;
inline bool Operation::has_create_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Operation::set_has_create_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Operation::clear_has_create_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Operation::clear_create_account() {
  if (create_account_ != NULL) create_account_->::protocol::OperationCreateAccount::Clear();
  clear_has_create_account();
}
inline const ::protocol::OperationCreateAccount& Operation::create_account() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.create_account)
  return create_account_ != NULL ? *create_account_
                         : *::protocol::OperationCreateAccount::internal_default_instance();
}
inline ::protocol::OperationCreateAccount* Operation::mutable_create_account() {
  set_has_create_account();
  if (create_account_ == NULL) {
    create_account_ = new ::protocol::OperationCreateAccount;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.create_account)
  return create_account_;
}
inline ::protocol::OperationCreateAccount* Operation::release_create_account() {
  // @@protoc_insertion_point(field_release:protocol.Operation.create_account)
  clear_has_create_account();
  ::protocol::OperationCreateAccount* temp = create_account_;
  create_account_ = NULL;
  return temp;
}
inline void Operation::set_allocated_create_account(::protocol::OperationCreateAccount* create_account) {
  delete create_account_;
  create_account_ = create_account;
  if (create_account) {
    set_has_create_account();
  } else {
    clear_has_create_account();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.create_account)
}

// optional .protocol.OperationPayment payment = 4;
inline bool Operation::has_payment() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Operation::set_has_payment() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Operation::clear_has_payment() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Operation::clear_payment() {
  if (payment_ != NULL) payment_->::protocol::OperationPayment::Clear();
  clear_has_payment();
}
inline const ::protocol::OperationPayment& Operation::payment() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.payment)
  return payment_ != NULL ? *payment_
                         : *::protocol::OperationPayment::internal_default_instance();
}
inline ::protocol::OperationPayment* Operation::mutable_payment() {
  set_has_payment();
  if (payment_ == NULL) {
    payment_ = new ::protocol::OperationPayment;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.payment)
  return payment_;
}
inline ::protocol::OperationPayment* Operation::release_payment() {
  // @@protoc_insertion_point(field_release:protocol.Operation.payment)
  clear_has_payment();
  ::protocol::OperationPayment* temp = payment_;
  payment_ = NULL;
  return temp;
}
inline void Operation::set_allocated_payment(::protocol::OperationPayment* payment) {
  delete payment_;
  payment_ = payment;
  if (payment) {
    set_has_payment();
  } else {
    clear_has_payment();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.payment)
}

// optional .protocol.OperationIssueAsset issue_asset = 5;
inline bool Operation::has_issue_asset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Operation::set_has_issue_asset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Operation::clear_has_issue_asset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Operation::clear_issue_asset() {
  if (issue_asset_ != NULL) issue_asset_->::protocol::OperationIssueAsset::Clear();
  clear_has_issue_asset();
}
inline const ::protocol::OperationIssueAsset& Operation::issue_asset() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.issue_asset)
  return issue_asset_ != NULL ? *issue_asset_
                         : *::protocol::OperationIssueAsset::internal_default_instance();
}
inline ::protocol::OperationIssueAsset* Operation::mutable_issue_asset() {
  set_has_issue_asset();
  if (issue_asset_ == NULL) {
    issue_asset_ = new ::protocol::OperationIssueAsset;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.issue_asset)
  return issue_asset_;
}
inline ::protocol::OperationIssueAsset* Operation::release_issue_asset() {
  // @@protoc_insertion_point(field_release:protocol.Operation.issue_asset)
  clear_has_issue_asset();
  ::protocol::OperationIssueAsset* temp = issue_asset_;
  issue_asset_ = NULL;
  return temp;
}
inline void Operation::set_allocated_issue_asset(::protocol::OperationIssueAsset* issue_asset) {
  delete issue_asset_;
  issue_asset_ = issue_asset;
  if (issue_asset) {
    set_has_issue_asset();
  } else {
    clear_has_issue_asset();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.issue_asset)
}

// optional .protocol.OperationSetOptions setoptions = 6;
inline bool Operation::has_setoptions() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Operation::set_has_setoptions() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Operation::clear_has_setoptions() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Operation::clear_setoptions() {
  if (setoptions_ != NULL) setoptions_->::protocol::OperationSetOptions::Clear();
  clear_has_setoptions();
}
inline const ::protocol::OperationSetOptions& Operation::setoptions() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.setoptions)
  return setoptions_ != NULL ? *setoptions_
                         : *::protocol::OperationSetOptions::internal_default_instance();
}
inline ::protocol::OperationSetOptions* Operation::mutable_setoptions() {
  set_has_setoptions();
  if (setoptions_ == NULL) {
    setoptions_ = new ::protocol::OperationSetOptions;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.setoptions)
  return setoptions_;
}
inline ::protocol::OperationSetOptions* Operation::release_setoptions() {
  // @@protoc_insertion_point(field_release:protocol.Operation.setoptions)
  clear_has_setoptions();
  ::protocol::OperationSetOptions* temp = setoptions_;
  setoptions_ = NULL;
  return temp;
}
inline void Operation::set_allocated_setoptions(::protocol::OperationSetOptions* setoptions) {
  delete setoptions_;
  setoptions_ = setoptions;
  if (setoptions) {
    set_has_setoptions();
  } else {
    clear_has_setoptions();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.setoptions)
}

// optional .protocol.OperationManageOrder manage_order = 7;
inline bool Operation::has_manage_order() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Operation::set_has_manage_order() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Operation::clear_has_manage_order() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Operation::clear_manage_order() {
  if (manage_order_ != NULL) manage_order_->::protocol::OperationManageOrder::Clear();
  clear_has_manage_order();
}
inline const ::protocol::OperationManageOrder& Operation::manage_order() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.manage_order)
  return manage_order_ != NULL ? *manage_order_
                         : *::protocol::OperationManageOrder::internal_default_instance();
}
inline ::protocol::OperationManageOrder* Operation::mutable_manage_order() {
  set_has_manage_order();
  if (manage_order_ == NULL) {
    manage_order_ = new ::protocol::OperationManageOrder;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.manage_order)
  return manage_order_;
}
inline ::protocol::OperationManageOrder* Operation::release_manage_order() {
  // @@protoc_insertion_point(field_release:protocol.Operation.manage_order)
  clear_has_manage_order();
  ::protocol::OperationManageOrder* temp = manage_order_;
  manage_order_ = NULL;
  return temp;
}
inline void Operation::set_allocated_manage_order(::protocol::OperationManageOrder* manage_order) {
  delete manage_order_;
  manage_order_ = manage_order;
  if (manage_order) {
    set_has_manage_order();
  } else {
    clear_has_manage_order();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.manage_order)
}

// optional .protocol.OperationInitPayment init_payment = 8;
inline bool Operation::has_init_payment() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Operation::set_has_init_payment() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Operation::clear_has_init_payment() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Operation::clear_init_payment() {
  if (init_payment_ != NULL) init_payment_->::protocol::OperationInitPayment::Clear();
  clear_has_init_payment();
}
inline const ::protocol::OperationInitPayment& Operation::init_payment() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.init_payment)
  return init_payment_ != NULL ? *init_payment_
                         : *::protocol::OperationInitPayment::internal_default_instance();
}
inline ::protocol::OperationInitPayment* Operation::mutable_init_payment() {
  set_has_init_payment();
  if (init_payment_ == NULL) {
    init_payment_ = new ::protocol::OperationInitPayment;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.init_payment)
  return init_payment_;
}
inline ::protocol::OperationInitPayment* Operation::release_init_payment() {
  // @@protoc_insertion_point(field_release:protocol.Operation.init_payment)
  clear_has_init_payment();
  ::protocol::OperationInitPayment* temp = init_payment_;
  init_payment_ = NULL;
  return temp;
}
inline void Operation::set_allocated_init_payment(::protocol::OperationInitPayment* init_payment) {
  delete init_payment_;
  init_payment_ = init_payment;
  if (init_payment) {
    set_has_init_payment();
  } else {
    clear_has_init_payment();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.init_payment)
}

// optional .protocol.OperationProduction production = 9;
inline bool Operation::has_production() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Operation::set_has_production() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Operation::clear_has_production() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Operation::clear_production() {
  if (production_ != NULL) production_->::protocol::OperationProduction::Clear();
  clear_has_production();
}
inline const ::protocol::OperationProduction& Operation::production() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.production)
  return production_ != NULL ? *production_
                         : *::protocol::OperationProduction::internal_default_instance();
}
inline ::protocol::OperationProduction* Operation::mutable_production() {
  set_has_production();
  if (production_ == NULL) {
    production_ = new ::protocol::OperationProduction;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.production)
  return production_;
}
inline ::protocol::OperationProduction* Operation::release_production() {
  // @@protoc_insertion_point(field_release:protocol.Operation.production)
  clear_has_production();
  ::protocol::OperationProduction* temp = production_;
  production_ = NULL;
  return temp;
}
inline void Operation::set_allocated_production(::protocol::OperationProduction* production) {
  delete production_;
  production_ = production;
  if (production) {
    set_has_production();
  } else {
    clear_has_production();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.production)
}

// optional bytes metadata = 10;
inline bool Operation::has_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Operation::set_has_metadata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Operation::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Operation::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_metadata();
}
inline const ::std::string& Operation::metadata() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.metadata)
  return metadata_.GetNoArena();
}
inline void Operation::set_metadata(const ::std::string& value) {
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Operation.metadata)
}
#if LANG_CXX11
inline void Operation::set_metadata(::std::string&& value) {
  set_has_metadata();
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Operation.metadata)
}
#endif
inline void Operation::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Operation.metadata)
}
inline void Operation::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Operation.metadata)
}
inline ::std::string* Operation::mutable_metadata() {
  set_has_metadata();
  // @@protoc_insertion_point(field_mutable:protocol.Operation.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Operation::release_metadata() {
  // @@protoc_insertion_point(field_release:protocol.Operation.metadata)
  clear_has_metadata();
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Operation::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    set_has_metadata();
  } else {
    clear_has_metadata();
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.metadata)
}

// optional .protocol.OperationRecord record = 11;
inline bool Operation::has_record() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Operation::set_has_record() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Operation::clear_has_record() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Operation::clear_record() {
  if (record_ != NULL) record_->::protocol::OperationRecord::Clear();
  clear_has_record();
}
inline const ::protocol::OperationRecord& Operation::record() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.record)
  return record_ != NULL ? *record_
                         : *::protocol::OperationRecord::internal_default_instance();
}
inline ::protocol::OperationRecord* Operation::mutable_record() {
  set_has_record();
  if (record_ == NULL) {
    record_ = new ::protocol::OperationRecord;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.record)
  return record_;
}
inline ::protocol::OperationRecord* Operation::release_record() {
  // @@protoc_insertion_point(field_release:protocol.Operation.record)
  clear_has_record();
  ::protocol::OperationRecord* temp = record_;
  record_ = NULL;
  return temp;
}
inline void Operation::set_allocated_record(::protocol::OperationRecord* record) {
  delete record_;
  record_ = record;
  if (record) {
    set_has_record();
  } else {
    clear_has_record();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.record)
}

// optional .protocol.OperationIssueUniqueAsset issue_unique_asset = 12;
inline bool Operation::has_issue_unique_asset() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Operation::set_has_issue_unique_asset() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Operation::clear_has_issue_unique_asset() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Operation::clear_issue_unique_asset() {
  if (issue_unique_asset_ != NULL) issue_unique_asset_->::protocol::OperationIssueUniqueAsset::Clear();
  clear_has_issue_unique_asset();
}
inline const ::protocol::OperationIssueUniqueAsset& Operation::issue_unique_asset() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.issue_unique_asset)
  return issue_unique_asset_ != NULL ? *issue_unique_asset_
                         : *::protocol::OperationIssueUniqueAsset::internal_default_instance();
}
inline ::protocol::OperationIssueUniqueAsset* Operation::mutable_issue_unique_asset() {
  set_has_issue_unique_asset();
  if (issue_unique_asset_ == NULL) {
    issue_unique_asset_ = new ::protocol::OperationIssueUniqueAsset;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.issue_unique_asset)
  return issue_unique_asset_;
}
inline ::protocol::OperationIssueUniqueAsset* Operation::release_issue_unique_asset() {
  // @@protoc_insertion_point(field_release:protocol.Operation.issue_unique_asset)
  clear_has_issue_unique_asset();
  ::protocol::OperationIssueUniqueAsset* temp = issue_unique_asset_;
  issue_unique_asset_ = NULL;
  return temp;
}
inline void Operation::set_allocated_issue_unique_asset(::protocol::OperationIssueUniqueAsset* issue_unique_asset) {
  delete issue_unique_asset_;
  issue_unique_asset_ = issue_unique_asset;
  if (issue_unique_asset) {
    set_has_issue_unique_asset();
  } else {
    clear_has_issue_unique_asset();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.issue_unique_asset)
}

// optional .protocol.OperationPaymentUniqueAsset payment_unique_asset = 13;
inline bool Operation::has_payment_unique_asset() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Operation::set_has_payment_unique_asset() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Operation::clear_has_payment_unique_asset() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Operation::clear_payment_unique_asset() {
  if (payment_unique_asset_ != NULL) payment_unique_asset_->::protocol::OperationPaymentUniqueAsset::Clear();
  clear_has_payment_unique_asset();
}
inline const ::protocol::OperationPaymentUniqueAsset& Operation::payment_unique_asset() const {
  // @@protoc_insertion_point(field_get:protocol.Operation.payment_unique_asset)
  return payment_unique_asset_ != NULL ? *payment_unique_asset_
                         : *::protocol::OperationPaymentUniqueAsset::internal_default_instance();
}
inline ::protocol::OperationPaymentUniqueAsset* Operation::mutable_payment_unique_asset() {
  set_has_payment_unique_asset();
  if (payment_unique_asset_ == NULL) {
    payment_unique_asset_ = new ::protocol::OperationPaymentUniqueAsset;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Operation.payment_unique_asset)
  return payment_unique_asset_;
}
inline ::protocol::OperationPaymentUniqueAsset* Operation::release_payment_unique_asset() {
  // @@protoc_insertion_point(field_release:protocol.Operation.payment_unique_asset)
  clear_has_payment_unique_asset();
  ::protocol::OperationPaymentUniqueAsset* temp = payment_unique_asset_;
  payment_unique_asset_ = NULL;
  return temp;
}
inline void Operation::set_allocated_payment_unique_asset(::protocol::OperationPaymentUniqueAsset* payment_unique_asset) {
  delete payment_unique_asset_;
  payment_unique_asset_ = payment_unique_asset;
  if (payment_unique_asset) {
    set_has_payment_unique_asset();
  } else {
    clear_has_payment_unique_asset();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Operation.payment_unique_asset)
}

// -------------------------------------------------------------------

// Transaction

// required string source_address = 1;
inline bool Transaction::has_source_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Transaction::set_has_source_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Transaction::clear_has_source_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Transaction::clear_source_address() {
  source_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source_address();
}
inline const ::std::string& Transaction::source_address() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.source_address)
  return source_address_.GetNoArena();
}
inline void Transaction::set_source_address(const ::std::string& value) {
  set_has_source_address();
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.source_address)
}
#if LANG_CXX11
inline void Transaction::set_source_address(::std::string&& value) {
  set_has_source_address();
  source_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.source_address)
}
#endif
inline void Transaction::set_source_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source_address();
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.source_address)
}
inline void Transaction::set_source_address(const char* value, size_t size) {
  set_has_source_address();
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.source_address)
}
inline ::std::string* Transaction::mutable_source_address() {
  set_has_source_address();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.source_address)
  return source_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_source_address() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.source_address)
  clear_has_source_address();
  return source_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_source_address(::std::string* source_address) {
  if (source_address != NULL) {
    set_has_source_address();
  } else {
    clear_has_source_address();
  }
  source_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.source_address)
}

// required uint32 fee = 2;
inline bool Transaction::has_fee() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Transaction::set_has_fee() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Transaction::clear_has_fee() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Transaction::clear_fee() {
  fee_ = 0u;
  clear_has_fee();
}
inline ::google::protobuf::uint32 Transaction::fee() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.fee)
  return fee_;
}
inline void Transaction::set_fee(::google::protobuf::uint32 value) {
  set_has_fee();
  fee_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.fee)
}

// required int64 sequence_number = 3;
inline bool Transaction::has_sequence_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Transaction::set_has_sequence_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Transaction::clear_has_sequence_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Transaction::clear_sequence_number() {
  sequence_number_ = GOOGLE_LONGLONG(0);
  clear_has_sequence_number();
}
inline ::google::protobuf::int64 Transaction::sequence_number() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.sequence_number)
  return sequence_number_;
}
inline void Transaction::set_sequence_number(::google::protobuf::int64 value) {
  set_has_sequence_number();
  sequence_number_ = value;
  // @@protoc_insertion_point(field_set:protocol.Transaction.sequence_number)
}

// optional .protocol.CloseTimeRange close_time_range = 4;
inline bool Transaction::has_close_time_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Transaction::set_has_close_time_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Transaction::clear_has_close_time_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Transaction::clear_close_time_range() {
  if (close_time_range_ != NULL) close_time_range_->::protocol::CloseTimeRange::Clear();
  clear_has_close_time_range();
}
inline const ::protocol::CloseTimeRange& Transaction::close_time_range() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.close_time_range)
  return close_time_range_ != NULL ? *close_time_range_
                         : *::protocol::CloseTimeRange::internal_default_instance();
}
inline ::protocol::CloseTimeRange* Transaction::mutable_close_time_range() {
  set_has_close_time_range();
  if (close_time_range_ == NULL) {
    close_time_range_ = new ::protocol::CloseTimeRange;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.close_time_range)
  return close_time_range_;
}
inline ::protocol::CloseTimeRange* Transaction::release_close_time_range() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.close_time_range)
  clear_has_close_time_range();
  ::protocol::CloseTimeRange* temp = close_time_range_;
  close_time_range_ = NULL;
  return temp;
}
inline void Transaction::set_allocated_close_time_range(::protocol::CloseTimeRange* close_time_range) {
  delete close_time_range_;
  close_time_range_ = close_time_range;
  if (close_time_range) {
    set_has_close_time_range();
  } else {
    clear_has_close_time_range();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.close_time_range)
}

// repeated .protocol.Operation operations = 5;
inline int Transaction::operations_size() const {
  return operations_.size();
}
inline void Transaction::clear_operations() {
  operations_.Clear();
}
inline const ::protocol::Operation& Transaction::operations(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.operations)
  return operations_.Get(index);
}
inline ::protocol::Operation* Transaction::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.operations)
  return operations_.Mutable(index);
}
inline ::protocol::Operation* Transaction::add_operations() {
  // @@protoc_insertion_point(field_add:protocol.Transaction.operations)
  return operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Operation >*
Transaction::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Transaction.operations)
  return &operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Operation >&
Transaction::operations() const {
  // @@protoc_insertion_point(field_list:protocol.Transaction.operations)
  return operations_;
}

// optional bytes metadata = 6;
inline bool Transaction::has_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Transaction::set_has_metadata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Transaction::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Transaction::clear_metadata() {
  metadata_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_metadata();
}
inline const ::std::string& Transaction::metadata() const {
  // @@protoc_insertion_point(field_get:protocol.Transaction.metadata)
  return metadata_.GetNoArena();
}
inline void Transaction::set_metadata(const ::std::string& value) {
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Transaction.metadata)
}
#if LANG_CXX11
inline void Transaction::set_metadata(::std::string&& value) {
  set_has_metadata();
  metadata_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Transaction.metadata)
}
#endif
inline void Transaction::set_metadata(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Transaction.metadata)
}
inline void Transaction::set_metadata(const void* value, size_t size) {
  set_has_metadata();
  metadata_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Transaction.metadata)
}
inline ::std::string* Transaction::mutable_metadata() {
  set_has_metadata();
  // @@protoc_insertion_point(field_mutable:protocol.Transaction.metadata)
  return metadata_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_metadata() {
  // @@protoc_insertion_point(field_release:protocol.Transaction.metadata)
  clear_has_metadata();
  return metadata_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_metadata(::std::string* metadata) {
  if (metadata != NULL) {
    set_has_metadata();
  } else {
    clear_has_metadata();
  }
  metadata_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata);
  // @@protoc_insertion_point(field_set_allocated:protocol.Transaction.metadata)
}

// -------------------------------------------------------------------

// Signature

// required string public_key = 1;
inline bool Signature::has_public_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signature::set_has_public_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signature::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signature::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_public_key();
}
inline const ::std::string& Signature::public_key() const {
  // @@protoc_insertion_point(field_get:protocol.Signature.public_key)
  return public_key_.GetNoArena();
}
inline void Signature::set_public_key(const ::std::string& value) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Signature.public_key)
}
#if LANG_CXX11
inline void Signature::set_public_key(::std::string&& value) {
  set_has_public_key();
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Signature.public_key)
}
#endif
inline void Signature::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Signature.public_key)
}
inline void Signature::set_public_key(const char* value, size_t size) {
  set_has_public_key();
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Signature.public_key)
}
inline ::std::string* Signature::mutable_public_key() {
  set_has_public_key();
  // @@protoc_insertion_point(field_mutable:protocol.Signature.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signature::release_public_key() {
  // @@protoc_insertion_point(field_release:protocol.Signature.public_key)
  clear_has_public_key();
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signature::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    set_has_public_key();
  } else {
    clear_has_public_key();
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:protocol.Signature.public_key)
}

// required bytes sign_data = 2;
inline bool Signature::has_sign_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signature::set_has_sign_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Signature::clear_has_sign_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Signature::clear_sign_data() {
  sign_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sign_data();
}
inline const ::std::string& Signature::sign_data() const {
  // @@protoc_insertion_point(field_get:protocol.Signature.sign_data)
  return sign_data_.GetNoArena();
}
inline void Signature::set_sign_data(const ::std::string& value) {
  set_has_sign_data();
  sign_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Signature.sign_data)
}
#if LANG_CXX11
inline void Signature::set_sign_data(::std::string&& value) {
  set_has_sign_data();
  sign_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Signature.sign_data)
}
#endif
inline void Signature::set_sign_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sign_data();
  sign_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Signature.sign_data)
}
inline void Signature::set_sign_data(const void* value, size_t size) {
  set_has_sign_data();
  sign_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Signature.sign_data)
}
inline ::std::string* Signature::mutable_sign_data() {
  set_has_sign_data();
  // @@protoc_insertion_point(field_mutable:protocol.Signature.sign_data)
  return sign_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signature::release_sign_data() {
  // @@protoc_insertion_point(field_release:protocol.Signature.sign_data)
  clear_has_sign_data();
  return sign_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signature::set_allocated_sign_data(::std::string* sign_data) {
  if (sign_data != NULL) {
    set_has_sign_data();
  } else {
    clear_has_sign_data();
  }
  sign_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sign_data);
  // @@protoc_insertion_point(field_set_allocated:protocol.Signature.sign_data)
}

// -------------------------------------------------------------------

// TransactionEnv

// required .protocol.Transaction transaction = 1;
inline bool TransactionEnv::has_transaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionEnv::set_has_transaction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionEnv::clear_has_transaction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionEnv::clear_transaction() {
  if (transaction_ != NULL) transaction_->::protocol::Transaction::Clear();
  clear_has_transaction();
}
inline const ::protocol::Transaction& TransactionEnv::transaction() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnv.transaction)
  return transaction_ != NULL ? *transaction_
                         : *::protocol::Transaction::internal_default_instance();
}
inline ::protocol::Transaction* TransactionEnv::mutable_transaction() {
  set_has_transaction();
  if (transaction_ == NULL) {
    transaction_ = new ::protocol::Transaction;
  }
  // @@protoc_insertion_point(field_mutable:protocol.TransactionEnv.transaction)
  return transaction_;
}
inline ::protocol::Transaction* TransactionEnv::release_transaction() {
  // @@protoc_insertion_point(field_release:protocol.TransactionEnv.transaction)
  clear_has_transaction();
  ::protocol::Transaction* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline void TransactionEnv::set_allocated_transaction(::protocol::Transaction* transaction) {
  delete transaction_;
  transaction_ = transaction;
  if (transaction) {
    set_has_transaction();
  } else {
    clear_has_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionEnv.transaction)
}

// repeated .protocol.Signature signatures = 2;
inline int TransactionEnv::signatures_size() const {
  return signatures_.size();
}
inline void TransactionEnv::clear_signatures() {
  signatures_.Clear();
}
inline const ::protocol::Signature& TransactionEnv::signatures(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnv.signatures)
  return signatures_.Get(index);
}
inline ::protocol::Signature* TransactionEnv::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TransactionEnv.signatures)
  return signatures_.Mutable(index);
}
inline ::protocol::Signature* TransactionEnv::add_signatures() {
  // @@protoc_insertion_point(field_add:protocol.TransactionEnv.signatures)
  return signatures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Signature >*
TransactionEnv::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TransactionEnv.signatures)
  return &signatures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Signature >&
TransactionEnv::signatures() const {
  // @@protoc_insertion_point(field_list:protocol.TransactionEnv.signatures)
  return signatures_;
}

// -------------------------------------------------------------------

// TransactionEnvWrapper

// required .protocol.TransactionEnv transaction_env = 1;
inline bool TransactionEnvWrapper::has_transaction_env() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionEnvWrapper::set_has_transaction_env() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionEnvWrapper::clear_has_transaction_env() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionEnvWrapper::clear_transaction_env() {
  if (transaction_env_ != NULL) transaction_env_->::protocol::TransactionEnv::Clear();
  clear_has_transaction_env();
}
inline const ::protocol::TransactionEnv& TransactionEnvWrapper::transaction_env() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvWrapper.transaction_env)
  return transaction_env_ != NULL ? *transaction_env_
                         : *::protocol::TransactionEnv::internal_default_instance();
}
inline ::protocol::TransactionEnv* TransactionEnvWrapper::mutable_transaction_env() {
  set_has_transaction_env();
  if (transaction_env_ == NULL) {
    transaction_env_ = new ::protocol::TransactionEnv;
  }
  // @@protoc_insertion_point(field_mutable:protocol.TransactionEnvWrapper.transaction_env)
  return transaction_env_;
}
inline ::protocol::TransactionEnv* TransactionEnvWrapper::release_transaction_env() {
  // @@protoc_insertion_point(field_release:protocol.TransactionEnvWrapper.transaction_env)
  clear_has_transaction_env();
  ::protocol::TransactionEnv* temp = transaction_env_;
  transaction_env_ = NULL;
  return temp;
}
inline void TransactionEnvWrapper::set_allocated_transaction_env(::protocol::TransactionEnv* transaction_env) {
  delete transaction_env_;
  transaction_env_ = transaction_env;
  if (transaction_env) {
    set_has_transaction_env();
  } else {
    clear_has_transaction_env();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionEnvWrapper.transaction_env)
}

// optional int64 suggest_ledger_seq = 2;
inline bool TransactionEnvWrapper::has_suggest_ledger_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionEnvWrapper::set_has_suggest_ledger_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionEnvWrapper::clear_has_suggest_ledger_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionEnvWrapper::clear_suggest_ledger_seq() {
  suggest_ledger_seq_ = GOOGLE_LONGLONG(0);
  clear_has_suggest_ledger_seq();
}
inline ::google::protobuf::int64 TransactionEnvWrapper::suggest_ledger_seq() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvWrapper.suggest_ledger_seq)
  return suggest_ledger_seq_;
}
inline void TransactionEnvWrapper::set_suggest_ledger_seq(::google::protobuf::int64 value) {
  set_has_suggest_ledger_seq();
  suggest_ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransactionEnvWrapper.suggest_ledger_seq)
}

// -------------------------------------------------------------------

// TransactionEnvStore

// required .protocol.TransactionEnv transaction_env = 1;
inline bool TransactionEnvStore::has_transaction_env() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionEnvStore::set_has_transaction_env() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionEnvStore::clear_has_transaction_env() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionEnvStore::clear_transaction_env() {
  if (transaction_env_ != NULL) transaction_env_->::protocol::TransactionEnv::Clear();
  clear_has_transaction_env();
}
inline const ::protocol::TransactionEnv& TransactionEnvStore::transaction_env() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvStore.transaction_env)
  return transaction_env_ != NULL ? *transaction_env_
                         : *::protocol::TransactionEnv::internal_default_instance();
}
inline ::protocol::TransactionEnv* TransactionEnvStore::mutable_transaction_env() {
  set_has_transaction_env();
  if (transaction_env_ == NULL) {
    transaction_env_ = new ::protocol::TransactionEnv;
  }
  // @@protoc_insertion_point(field_mutable:protocol.TransactionEnvStore.transaction_env)
  return transaction_env_;
}
inline ::protocol::TransactionEnv* TransactionEnvStore::release_transaction_env() {
  // @@protoc_insertion_point(field_release:protocol.TransactionEnvStore.transaction_env)
  clear_has_transaction_env();
  ::protocol::TransactionEnv* temp = transaction_env_;
  transaction_env_ = NULL;
  return temp;
}
inline void TransactionEnvStore::set_allocated_transaction_env(::protocol::TransactionEnv* transaction_env) {
  delete transaction_env_;
  transaction_env_ = transaction_env;
  if (transaction_env) {
    set_has_transaction_env();
  } else {
    clear_has_transaction_env();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionEnvStore.transaction_env)
}

// optional int32 error_code = 2;
inline bool TransactionEnvStore::has_error_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransactionEnvStore::set_has_error_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransactionEnvStore::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransactionEnvStore::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 TransactionEnvStore::error_code() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvStore.error_code)
  return error_code_;
}
inline void TransactionEnvStore::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransactionEnvStore.error_code)
}

// optional bytes error_desc = 3;
inline bool TransactionEnvStore::has_error_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionEnvStore::set_has_error_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionEnvStore::clear_has_error_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionEnvStore::clear_error_desc() {
  error_desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_desc();
}
inline const ::std::string& TransactionEnvStore::error_desc() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvStore.error_desc)
  return error_desc_.GetNoArena();
}
inline void TransactionEnvStore::set_error_desc(const ::std::string& value) {
  set_has_error_desc();
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TransactionEnvStore.error_desc)
}
#if LANG_CXX11
inline void TransactionEnvStore::set_error_desc(::std::string&& value) {
  set_has_error_desc();
  error_desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TransactionEnvStore.error_desc)
}
#endif
inline void TransactionEnvStore::set_error_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_desc();
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TransactionEnvStore.error_desc)
}
inline void TransactionEnvStore::set_error_desc(const void* value, size_t size) {
  set_has_error_desc();
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TransactionEnvStore.error_desc)
}
inline ::std::string* TransactionEnvStore::mutable_error_desc() {
  set_has_error_desc();
  // @@protoc_insertion_point(field_mutable:protocol.TransactionEnvStore.error_desc)
  return error_desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TransactionEnvStore::release_error_desc() {
  // @@protoc_insertion_point(field_release:protocol.TransactionEnvStore.error_desc)
  clear_has_error_desc();
  return error_desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TransactionEnvStore::set_allocated_error_desc(::std::string* error_desc) {
  if (error_desc != NULL) {
    set_has_error_desc();
  } else {
    clear_has_error_desc();
  }
  error_desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_desc);
  // @@protoc_insertion_point(field_set_allocated:protocol.TransactionEnvStore.error_desc)
}

// optional int64 ledger_seq = 4;
inline bool TransactionEnvStore::has_ledger_seq() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransactionEnvStore::set_has_ledger_seq() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransactionEnvStore::clear_has_ledger_seq() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransactionEnvStore::clear_ledger_seq() {
  ledger_seq_ = GOOGLE_LONGLONG(0);
  clear_has_ledger_seq();
}
inline ::google::protobuf::int64 TransactionEnvStore::ledger_seq() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvStore.ledger_seq)
  return ledger_seq_;
}
inline void TransactionEnvStore::set_ledger_seq(::google::protobuf::int64 value) {
  set_has_ledger_seq();
  ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransactionEnvStore.ledger_seq)
}

// optional int64 close_time = 5;
inline bool TransactionEnvStore::has_close_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransactionEnvStore::set_has_close_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransactionEnvStore::clear_has_close_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransactionEnvStore::clear_close_time() {
  close_time_ = GOOGLE_LONGLONG(0);
  clear_has_close_time();
}
inline ::google::protobuf::int64 TransactionEnvStore::close_time() const {
  // @@protoc_insertion_point(field_get:protocol.TransactionEnvStore.close_time)
  return close_time_;
}
inline void TransactionEnvStore::set_close_time(::google::protobuf::int64 value) {
  set_has_close_time();
  close_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.TransactionEnvStore.close_time)
}

// -------------------------------------------------------------------

// SlaveVerifyRequest

// required bytes peer_message = 1;
inline bool SlaveVerifyRequest::has_peer_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveVerifyRequest::set_has_peer_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveVerifyRequest::clear_has_peer_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveVerifyRequest::clear_peer_message() {
  peer_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_message();
}
inline const ::std::string& SlaveVerifyRequest::peer_message() const {
  // @@protoc_insertion_point(field_get:protocol.SlaveVerifyRequest.peer_message)
  return peer_message_.GetNoArena();
}
inline void SlaveVerifyRequest::set_peer_message(const ::std::string& value) {
  set_has_peer_message();
  peer_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.SlaveVerifyRequest.peer_message)
}
#if LANG_CXX11
inline void SlaveVerifyRequest::set_peer_message(::std::string&& value) {
  set_has_peer_message();
  peer_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.SlaveVerifyRequest.peer_message)
}
#endif
inline void SlaveVerifyRequest::set_peer_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_message();
  peer_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.SlaveVerifyRequest.peer_message)
}
inline void SlaveVerifyRequest::set_peer_message(const void* value, size_t size) {
  set_has_peer_message();
  peer_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.SlaveVerifyRequest.peer_message)
}
inline ::std::string* SlaveVerifyRequest::mutable_peer_message() {
  set_has_peer_message();
  // @@protoc_insertion_point(field_mutable:protocol.SlaveVerifyRequest.peer_message)
  return peer_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SlaveVerifyRequest::release_peer_message() {
  // @@protoc_insertion_point(field_release:protocol.SlaveVerifyRequest.peer_message)
  clear_has_peer_message();
  return peer_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SlaveVerifyRequest::set_allocated_peer_message(::std::string* peer_message) {
  if (peer_message != NULL) {
    set_has_peer_message();
  } else {
    clear_has_peer_message();
  }
  peer_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_message);
  // @@protoc_insertion_point(field_set_allocated:protocol.SlaveVerifyRequest.peer_message)
}

// required int64 peer_id = 2;
inline bool SlaveVerifyRequest::has_peer_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlaveVerifyRequest::set_has_peer_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlaveVerifyRequest::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlaveVerifyRequest::clear_peer_id() {
  peer_id_ = GOOGLE_LONGLONG(0);
  clear_has_peer_id();
}
inline ::google::protobuf::int64 SlaveVerifyRequest::peer_id() const {
  // @@protoc_insertion_point(field_get:protocol.SlaveVerifyRequest.peer_id)
  return peer_id_;
}
inline void SlaveVerifyRequest::set_peer_id(::google::protobuf::int64 value) {
  set_has_peer_id();
  peer_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.SlaveVerifyRequest.peer_id)
}

// optional bytes txset_hash = 3;
inline bool SlaveVerifyRequest::has_txset_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveVerifyRequest::set_has_txset_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveVerifyRequest::clear_has_txset_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveVerifyRequest::clear_txset_hash() {
  txset_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_txset_hash();
}
inline const ::std::string& SlaveVerifyRequest::txset_hash() const {
  // @@protoc_insertion_point(field_get:protocol.SlaveVerifyRequest.txset_hash)
  return txset_hash_.GetNoArena();
}
inline void SlaveVerifyRequest::set_txset_hash(const ::std::string& value) {
  set_has_txset_hash();
  txset_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.SlaveVerifyRequest.txset_hash)
}
#if LANG_CXX11
inline void SlaveVerifyRequest::set_txset_hash(::std::string&& value) {
  set_has_txset_hash();
  txset_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.SlaveVerifyRequest.txset_hash)
}
#endif
inline void SlaveVerifyRequest::set_txset_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_txset_hash();
  txset_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.SlaveVerifyRequest.txset_hash)
}
inline void SlaveVerifyRequest::set_txset_hash(const void* value, size_t size) {
  set_has_txset_hash();
  txset_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.SlaveVerifyRequest.txset_hash)
}
inline ::std::string* SlaveVerifyRequest::mutable_txset_hash() {
  set_has_txset_hash();
  // @@protoc_insertion_point(field_mutable:protocol.SlaveVerifyRequest.txset_hash)
  return txset_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SlaveVerifyRequest::release_txset_hash() {
  // @@protoc_insertion_point(field_release:protocol.SlaveVerifyRequest.txset_hash)
  clear_has_txset_hash();
  return txset_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SlaveVerifyRequest::set_allocated_txset_hash(::std::string* txset_hash) {
  if (txset_hash != NULL) {
    set_has_txset_hash();
  } else {
    clear_has_txset_hash();
  }
  txset_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txset_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.SlaveVerifyRequest.txset_hash)
}

// -------------------------------------------------------------------

// SlaveVerifyResponse

// required bytes peer_message = 1;
inline bool SlaveVerifyResponse::has_peer_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SlaveVerifyResponse::set_has_peer_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SlaveVerifyResponse::clear_has_peer_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SlaveVerifyResponse::clear_peer_message() {
  peer_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_message();
}
inline const ::std::string& SlaveVerifyResponse::peer_message() const {
  // @@protoc_insertion_point(field_get:protocol.SlaveVerifyResponse.peer_message)
  return peer_message_.GetNoArena();
}
inline void SlaveVerifyResponse::set_peer_message(const ::std::string& value) {
  set_has_peer_message();
  peer_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.SlaveVerifyResponse.peer_message)
}
#if LANG_CXX11
inline void SlaveVerifyResponse::set_peer_message(::std::string&& value) {
  set_has_peer_message();
  peer_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.SlaveVerifyResponse.peer_message)
}
#endif
inline void SlaveVerifyResponse::set_peer_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_message();
  peer_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.SlaveVerifyResponse.peer_message)
}
inline void SlaveVerifyResponse::set_peer_message(const void* value, size_t size) {
  set_has_peer_message();
  peer_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.SlaveVerifyResponse.peer_message)
}
inline ::std::string* SlaveVerifyResponse::mutable_peer_message() {
  set_has_peer_message();
  // @@protoc_insertion_point(field_mutable:protocol.SlaveVerifyResponse.peer_message)
  return peer_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SlaveVerifyResponse::release_peer_message() {
  // @@protoc_insertion_point(field_release:protocol.SlaveVerifyResponse.peer_message)
  clear_has_peer_message();
  return peer_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SlaveVerifyResponse::set_allocated_peer_message(::std::string* peer_message) {
  if (peer_message != NULL) {
    set_has_peer_message();
  } else {
    clear_has_peer_message();
  }
  peer_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_message);
  // @@protoc_insertion_point(field_set_allocated:protocol.SlaveVerifyResponse.peer_message)
}

// optional int64 peer_id = 2;
inline bool SlaveVerifyResponse::has_peer_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SlaveVerifyResponse::set_has_peer_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SlaveVerifyResponse::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SlaveVerifyResponse::clear_peer_id() {
  peer_id_ = GOOGLE_LONGLONG(0);
  clear_has_peer_id();
}
inline ::google::protobuf::int64 SlaveVerifyResponse::peer_id() const {
  // @@protoc_insertion_point(field_get:protocol.SlaveVerifyResponse.peer_id)
  return peer_id_;
}
inline void SlaveVerifyResponse::set_peer_id(::google::protobuf::int64 value) {
  set_has_peer_id();
  peer_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.SlaveVerifyResponse.peer_id)
}

// optional bytes txset_hash = 3;
inline bool SlaveVerifyResponse::has_txset_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SlaveVerifyResponse::set_has_txset_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SlaveVerifyResponse::clear_has_txset_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SlaveVerifyResponse::clear_txset_hash() {
  txset_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_txset_hash();
}
inline const ::std::string& SlaveVerifyResponse::txset_hash() const {
  // @@protoc_insertion_point(field_get:protocol.SlaveVerifyResponse.txset_hash)
  return txset_hash_.GetNoArena();
}
inline void SlaveVerifyResponse::set_txset_hash(const ::std::string& value) {
  set_has_txset_hash();
  txset_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.SlaveVerifyResponse.txset_hash)
}
#if LANG_CXX11
inline void SlaveVerifyResponse::set_txset_hash(::std::string&& value) {
  set_has_txset_hash();
  txset_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.SlaveVerifyResponse.txset_hash)
}
#endif
inline void SlaveVerifyResponse::set_txset_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_txset_hash();
  txset_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.SlaveVerifyResponse.txset_hash)
}
inline void SlaveVerifyResponse::set_txset_hash(const void* value, size_t size) {
  set_has_txset_hash();
  txset_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.SlaveVerifyResponse.txset_hash)
}
inline ::std::string* SlaveVerifyResponse::mutable_txset_hash() {
  set_has_txset_hash();
  // @@protoc_insertion_point(field_mutable:protocol.SlaveVerifyResponse.txset_hash)
  return txset_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SlaveVerifyResponse::release_txset_hash() {
  // @@protoc_insertion_point(field_release:protocol.SlaveVerifyResponse.txset_hash)
  clear_has_txset_hash();
  return txset_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SlaveVerifyResponse::set_allocated_txset_hash(::std::string* txset_hash) {
  if (txset_hash != NULL) {
    set_has_txset_hash();
  } else {
    clear_has_txset_hash();
  }
  txset_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txset_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.SlaveVerifyResponse.txset_hash)
}

// required bytes peer_message_hash = 4;
inline bool SlaveVerifyResponse::has_peer_message_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SlaveVerifyResponse::set_has_peer_message_hash() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SlaveVerifyResponse::clear_has_peer_message_hash() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SlaveVerifyResponse::clear_peer_message_hash() {
  peer_message_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_message_hash();
}
inline const ::std::string& SlaveVerifyResponse::peer_message_hash() const {
  // @@protoc_insertion_point(field_get:protocol.SlaveVerifyResponse.peer_message_hash)
  return peer_message_hash_.GetNoArena();
}
inline void SlaveVerifyResponse::set_peer_message_hash(const ::std::string& value) {
  set_has_peer_message_hash();
  peer_message_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.SlaveVerifyResponse.peer_message_hash)
}
#if LANG_CXX11
inline void SlaveVerifyResponse::set_peer_message_hash(::std::string&& value) {
  set_has_peer_message_hash();
  peer_message_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.SlaveVerifyResponse.peer_message_hash)
}
#endif
inline void SlaveVerifyResponse::set_peer_message_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_message_hash();
  peer_message_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.SlaveVerifyResponse.peer_message_hash)
}
inline void SlaveVerifyResponse::set_peer_message_hash(const void* value, size_t size) {
  set_has_peer_message_hash();
  peer_message_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.SlaveVerifyResponse.peer_message_hash)
}
inline ::std::string* SlaveVerifyResponse::mutable_peer_message_hash() {
  set_has_peer_message_hash();
  // @@protoc_insertion_point(field_mutable:protocol.SlaveVerifyResponse.peer_message_hash)
  return peer_message_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SlaveVerifyResponse::release_peer_message_hash() {
  // @@protoc_insertion_point(field_release:protocol.SlaveVerifyResponse.peer_message_hash)
  clear_has_peer_message_hash();
  return peer_message_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SlaveVerifyResponse::set_allocated_peer_message_hash(::std::string* peer_message_hash) {
  if (peer_message_hash != NULL) {
    set_has_peer_message_hash();
  } else {
    clear_has_peer_message_hash();
  }
  peer_message_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_message_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.SlaveVerifyResponse.peer_message_hash)
}

// required bytes transaction_hash = 5;
inline bool SlaveVerifyResponse::has_transaction_hash() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SlaveVerifyResponse::set_has_transaction_hash() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SlaveVerifyResponse::clear_has_transaction_hash() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SlaveVerifyResponse::clear_transaction_hash() {
  transaction_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_transaction_hash();
}
inline const ::std::string& SlaveVerifyResponse::transaction_hash() const {
  // @@protoc_insertion_point(field_get:protocol.SlaveVerifyResponse.transaction_hash)
  return transaction_hash_.GetNoArena();
}
inline void SlaveVerifyResponse::set_transaction_hash(const ::std::string& value) {
  set_has_transaction_hash();
  transaction_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.SlaveVerifyResponse.transaction_hash)
}
#if LANG_CXX11
inline void SlaveVerifyResponse::set_transaction_hash(::std::string&& value) {
  set_has_transaction_hash();
  transaction_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.SlaveVerifyResponse.transaction_hash)
}
#endif
inline void SlaveVerifyResponse::set_transaction_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_transaction_hash();
  transaction_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.SlaveVerifyResponse.transaction_hash)
}
inline void SlaveVerifyResponse::set_transaction_hash(const void* value, size_t size) {
  set_has_transaction_hash();
  transaction_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.SlaveVerifyResponse.transaction_hash)
}
inline ::std::string* SlaveVerifyResponse::mutable_transaction_hash() {
  set_has_transaction_hash();
  // @@protoc_insertion_point(field_mutable:protocol.SlaveVerifyResponse.transaction_hash)
  return transaction_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SlaveVerifyResponse::release_transaction_hash() {
  // @@protoc_insertion_point(field_release:protocol.SlaveVerifyResponse.transaction_hash)
  clear_has_transaction_hash();
  return transaction_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SlaveVerifyResponse::set_allocated_transaction_hash(::std::string* transaction_hash) {
  if (transaction_hash != NULL) {
    set_has_transaction_hash();
  } else {
    clear_has_transaction_hash();
  }
  transaction_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transaction_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.SlaveVerifyResponse.transaction_hash)
}

// required bytes transaction_env_hash = 6;
inline bool SlaveVerifyResponse::has_transaction_env_hash() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SlaveVerifyResponse::set_has_transaction_env_hash() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SlaveVerifyResponse::clear_has_transaction_env_hash() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SlaveVerifyResponse::clear_transaction_env_hash() {
  transaction_env_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_transaction_env_hash();
}
inline const ::std::string& SlaveVerifyResponse::transaction_env_hash() const {
  // @@protoc_insertion_point(field_get:protocol.SlaveVerifyResponse.transaction_env_hash)
  return transaction_env_hash_.GetNoArena();
}
inline void SlaveVerifyResponse::set_transaction_env_hash(const ::std::string& value) {
  set_has_transaction_env_hash();
  transaction_env_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.SlaveVerifyResponse.transaction_env_hash)
}
#if LANG_CXX11
inline void SlaveVerifyResponse::set_transaction_env_hash(::std::string&& value) {
  set_has_transaction_env_hash();
  transaction_env_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.SlaveVerifyResponse.transaction_env_hash)
}
#endif
inline void SlaveVerifyResponse::set_transaction_env_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_transaction_env_hash();
  transaction_env_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.SlaveVerifyResponse.transaction_env_hash)
}
inline void SlaveVerifyResponse::set_transaction_env_hash(const void* value, size_t size) {
  set_has_transaction_env_hash();
  transaction_env_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.SlaveVerifyResponse.transaction_env_hash)
}
inline ::std::string* SlaveVerifyResponse::mutable_transaction_env_hash() {
  set_has_transaction_env_hash();
  // @@protoc_insertion_point(field_mutable:protocol.SlaveVerifyResponse.transaction_env_hash)
  return transaction_env_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SlaveVerifyResponse::release_transaction_env_hash() {
  // @@protoc_insertion_point(field_release:protocol.SlaveVerifyResponse.transaction_env_hash)
  clear_has_transaction_env_hash();
  return transaction_env_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SlaveVerifyResponse::set_allocated_transaction_env_hash(::std::string* transaction_env_hash) {
  if (transaction_env_hash != NULL) {
    set_has_transaction_env_hash();
  } else {
    clear_has_transaction_env_hash();
  }
  transaction_env_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transaction_env_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.SlaveVerifyResponse.transaction_env_hash)
}

// repeated string address = 7;
inline int SlaveVerifyResponse::address_size() const {
  return address_.size();
}
inline void SlaveVerifyResponse::clear_address() {
  address_.Clear();
}
inline const ::std::string& SlaveVerifyResponse::address(int index) const {
  // @@protoc_insertion_point(field_get:protocol.SlaveVerifyResponse.address)
  return address_.Get(index);
}
inline ::std::string* SlaveVerifyResponse::mutable_address(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.SlaveVerifyResponse.address)
  return address_.Mutable(index);
}
inline void SlaveVerifyResponse::set_address(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.SlaveVerifyResponse.address)
  address_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SlaveVerifyResponse::set_address(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.SlaveVerifyResponse.address)
  address_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SlaveVerifyResponse::set_address(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  address_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.SlaveVerifyResponse.address)
}
inline void SlaveVerifyResponse::set_address(int index, const char* value, size_t size) {
  address_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.SlaveVerifyResponse.address)
}
inline ::std::string* SlaveVerifyResponse::add_address() {
  // @@protoc_insertion_point(field_add_mutable:protocol.SlaveVerifyResponse.address)
  return address_.Add();
}
inline void SlaveVerifyResponse::add_address(const ::std::string& value) {
  address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.SlaveVerifyResponse.address)
}
#if LANG_CXX11
inline void SlaveVerifyResponse::add_address(::std::string&& value) {
  address_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.SlaveVerifyResponse.address)
}
#endif
inline void SlaveVerifyResponse::add_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  address_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.SlaveVerifyResponse.address)
}
inline void SlaveVerifyResponse::add_address(const char* value, size_t size) {
  address_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.SlaveVerifyResponse.address)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SlaveVerifyResponse::address() const {
  // @@protoc_insertion_point(field_list:protocol.SlaveVerifyResponse.address)
  return address_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SlaveVerifyResponse::mutable_address() {
  // @@protoc_insertion_point(field_mutable_list:protocol.SlaveVerifyResponse.address)
  return &address_;
}

// -------------------------------------------------------------------

// GetTxHashSet

// required bytes hash = 1;
inline bool GetTxHashSet::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTxHashSet::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTxHashSet::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTxHashSet::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& GetTxHashSet::hash() const {
  // @@protoc_insertion_point(field_get:protocol.GetTxHashSet.hash)
  return hash_.GetNoArena();
}
inline void GetTxHashSet::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.GetTxHashSet.hash)
}
#if LANG_CXX11
inline void GetTxHashSet::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.GetTxHashSet.hash)
}
#endif
inline void GetTxHashSet::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.GetTxHashSet.hash)
}
inline void GetTxHashSet::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.GetTxHashSet.hash)
}
inline ::std::string* GetTxHashSet::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:protocol.GetTxHashSet.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTxHashSet::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.GetTxHashSet.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTxHashSet::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.GetTxHashSet.hash)
}

// -------------------------------------------------------------------

// TxHashSet

// required bytes hash = 1;
inline bool TxHashSet::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxHashSet::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxHashSet::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxHashSet::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& TxHashSet::hash() const {
  // @@protoc_insertion_point(field_get:protocol.TxHashSet.hash)
  return hash_.GetNoArena();
}
inline void TxHashSet::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TxHashSet.hash)
}
#if LANG_CXX11
inline void TxHashSet::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TxHashSet.hash)
}
#endif
inline void TxHashSet::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TxHashSet.hash)
}
inline void TxHashSet::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TxHashSet.hash)
}
inline ::std::string* TxHashSet::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:protocol.TxHashSet.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxHashSet::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.TxHashSet.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxHashSet::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.TxHashSet.hash)
}

// required bytes previous_ledger_hash = 2;
inline bool TxHashSet::has_previous_ledger_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxHashSet::set_has_previous_ledger_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxHashSet::clear_has_previous_ledger_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxHashSet::clear_previous_ledger_hash() {
  previous_ledger_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_previous_ledger_hash();
}
inline const ::std::string& TxHashSet::previous_ledger_hash() const {
  // @@protoc_insertion_point(field_get:protocol.TxHashSet.previous_ledger_hash)
  return previous_ledger_hash_.GetNoArena();
}
inline void TxHashSet::set_previous_ledger_hash(const ::std::string& value) {
  set_has_previous_ledger_hash();
  previous_ledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TxHashSet.previous_ledger_hash)
}
#if LANG_CXX11
inline void TxHashSet::set_previous_ledger_hash(::std::string&& value) {
  set_has_previous_ledger_hash();
  previous_ledger_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TxHashSet.previous_ledger_hash)
}
#endif
inline void TxHashSet::set_previous_ledger_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_previous_ledger_hash();
  previous_ledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TxHashSet.previous_ledger_hash)
}
inline void TxHashSet::set_previous_ledger_hash(const void* value, size_t size) {
  set_has_previous_ledger_hash();
  previous_ledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TxHashSet.previous_ledger_hash)
}
inline ::std::string* TxHashSet::mutable_previous_ledger_hash() {
  set_has_previous_ledger_hash();
  // @@protoc_insertion_point(field_mutable:protocol.TxHashSet.previous_ledger_hash)
  return previous_ledger_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxHashSet::release_previous_ledger_hash() {
  // @@protoc_insertion_point(field_release:protocol.TxHashSet.previous_ledger_hash)
  clear_has_previous_ledger_hash();
  return previous_ledger_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxHashSet::set_allocated_previous_ledger_hash(::std::string* previous_ledger_hash) {
  if (previous_ledger_hash != NULL) {
    set_has_previous_ledger_hash();
  } else {
    clear_has_previous_ledger_hash();
  }
  previous_ledger_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previous_ledger_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.TxHashSet.previous_ledger_hash)
}

// repeated bytes hashs = 3;
inline int TxHashSet::hashs_size() const {
  return hashs_.size();
}
inline void TxHashSet::clear_hashs() {
  hashs_.Clear();
}
inline const ::std::string& TxHashSet::hashs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TxHashSet.hashs)
  return hashs_.Get(index);
}
inline ::std::string* TxHashSet::mutable_hashs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TxHashSet.hashs)
  return hashs_.Mutable(index);
}
inline void TxHashSet::set_hashs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.TxHashSet.hashs)
  hashs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TxHashSet::set_hashs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.TxHashSet.hashs)
  hashs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TxHashSet::set_hashs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  hashs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.TxHashSet.hashs)
}
inline void TxHashSet::set_hashs(int index, const void* value, size_t size) {
  hashs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.TxHashSet.hashs)
}
inline ::std::string* TxHashSet::add_hashs() {
  // @@protoc_insertion_point(field_add_mutable:protocol.TxHashSet.hashs)
  return hashs_.Add();
}
inline void TxHashSet::add_hashs(const ::std::string& value) {
  hashs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.TxHashSet.hashs)
}
#if LANG_CXX11
inline void TxHashSet::add_hashs(::std::string&& value) {
  hashs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.TxHashSet.hashs)
}
#endif
inline void TxHashSet::add_hashs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  hashs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.TxHashSet.hashs)
}
inline void TxHashSet::add_hashs(const void* value, size_t size) {
  hashs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.TxHashSet.hashs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TxHashSet::hashs() const {
  // @@protoc_insertion_point(field_list:protocol.TxHashSet.hashs)
  return hashs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TxHashSet::mutable_hashs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TxHashSet.hashs)
  return &hashs_;
}

// -------------------------------------------------------------------

// GetQuorumset

// required bytes hash = 1;
inline bool GetQuorumset::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetQuorumset::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetQuorumset::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetQuorumset::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& GetQuorumset::hash() const {
  // @@protoc_insertion_point(field_get:protocol.GetQuorumset.hash)
  return hash_.GetNoArena();
}
inline void GetQuorumset::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.GetQuorumset.hash)
}
#if LANG_CXX11
inline void GetQuorumset::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.GetQuorumset.hash)
}
#endif
inline void GetQuorumset::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.GetQuorumset.hash)
}
inline void GetQuorumset::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.GetQuorumset.hash)
}
inline ::std::string* GetQuorumset::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:protocol.GetQuorumset.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetQuorumset::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.GetQuorumset.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetQuorumset::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.GetQuorumset.hash)
}

// -------------------------------------------------------------------

// GetTxSet

// required bytes hash = 1;
inline bool GetTxSet::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTxSet::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTxSet::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTxSet::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& GetTxSet::hash() const {
  // @@protoc_insertion_point(field_get:protocol.GetTxSet.hash)
  return hash_.GetNoArena();
}
inline void GetTxSet::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.GetTxSet.hash)
}
#if LANG_CXX11
inline void GetTxSet::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.GetTxSet.hash)
}
#endif
inline void GetTxSet::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.GetTxSet.hash)
}
inline void GetTxSet::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.GetTxSet.hash)
}
inline ::std::string* GetTxSet::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:protocol.GetTxSet.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTxSet::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.GetTxSet.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTxSet::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.GetTxSet.hash)
}

// repeated bytes hashs = 2;
inline int GetTxSet::hashs_size() const {
  return hashs_.size();
}
inline void GetTxSet::clear_hashs() {
  hashs_.Clear();
}
inline const ::std::string& GetTxSet::hashs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.GetTxSet.hashs)
  return hashs_.Get(index);
}
inline ::std::string* GetTxSet::mutable_hashs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.GetTxSet.hashs)
  return hashs_.Mutable(index);
}
inline void GetTxSet::set_hashs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.GetTxSet.hashs)
  hashs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetTxSet::set_hashs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.GetTxSet.hashs)
  hashs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetTxSet::set_hashs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  hashs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.GetTxSet.hashs)
}
inline void GetTxSet::set_hashs(int index, const void* value, size_t size) {
  hashs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.GetTxSet.hashs)
}
inline ::std::string* GetTxSet::add_hashs() {
  // @@protoc_insertion_point(field_add_mutable:protocol.GetTxSet.hashs)
  return hashs_.Add();
}
inline void GetTxSet::add_hashs(const ::std::string& value) {
  hashs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.GetTxSet.hashs)
}
#if LANG_CXX11
inline void GetTxSet::add_hashs(::std::string&& value) {
  hashs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.GetTxSet.hashs)
}
#endif
inline void GetTxSet::add_hashs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  hashs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.GetTxSet.hashs)
}
inline void GetTxSet::add_hashs(const void* value, size_t size) {
  hashs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.GetTxSet.hashs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetTxSet::hashs() const {
  // @@protoc_insertion_point(field_list:protocol.GetTxSet.hashs)
  return hashs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetTxSet::mutable_hashs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.GetTxSet.hashs)
  return &hashs_;
}

// -------------------------------------------------------------------

// TxSet

// required bytes hash = 1;
inline bool TxSet::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxSet::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxSet::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxSet::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& TxSet::hash() const {
  // @@protoc_insertion_point(field_get:protocol.TxSet.hash)
  return hash_.GetNoArena();
}
inline void TxSet::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TxSet.hash)
}
#if LANG_CXX11
inline void TxSet::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TxSet.hash)
}
#endif
inline void TxSet::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TxSet.hash)
}
inline void TxSet::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TxSet.hash)
}
inline ::std::string* TxSet::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:protocol.TxSet.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxSet::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.TxSet.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSet::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.TxSet.hash)
}

// required bytes previous_ledger_hash = 2;
inline bool TxSet::has_previous_ledger_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxSet::set_has_previous_ledger_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxSet::clear_has_previous_ledger_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxSet::clear_previous_ledger_hash() {
  previous_ledger_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_previous_ledger_hash();
}
inline const ::std::string& TxSet::previous_ledger_hash() const {
  // @@protoc_insertion_point(field_get:protocol.TxSet.previous_ledger_hash)
  return previous_ledger_hash_.GetNoArena();
}
inline void TxSet::set_previous_ledger_hash(const ::std::string& value) {
  set_has_previous_ledger_hash();
  previous_ledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.TxSet.previous_ledger_hash)
}
#if LANG_CXX11
inline void TxSet::set_previous_ledger_hash(::std::string&& value) {
  set_has_previous_ledger_hash();
  previous_ledger_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.TxSet.previous_ledger_hash)
}
#endif
inline void TxSet::set_previous_ledger_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_previous_ledger_hash();
  previous_ledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.TxSet.previous_ledger_hash)
}
inline void TxSet::set_previous_ledger_hash(const void* value, size_t size) {
  set_has_previous_ledger_hash();
  previous_ledger_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.TxSet.previous_ledger_hash)
}
inline ::std::string* TxSet::mutable_previous_ledger_hash() {
  set_has_previous_ledger_hash();
  // @@protoc_insertion_point(field_mutable:protocol.TxSet.previous_ledger_hash)
  return previous_ledger_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TxSet::release_previous_ledger_hash() {
  // @@protoc_insertion_point(field_release:protocol.TxSet.previous_ledger_hash)
  clear_has_previous_ledger_hash();
  return previous_ledger_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TxSet::set_allocated_previous_ledger_hash(::std::string* previous_ledger_hash) {
  if (previous_ledger_hash != NULL) {
    set_has_previous_ledger_hash();
  } else {
    clear_has_previous_ledger_hash();
  }
  previous_ledger_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), previous_ledger_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.TxSet.previous_ledger_hash)
}

// repeated .protocol.TransactionEnv tran_envs = 3;
inline int TxSet::tran_envs_size() const {
  return tran_envs_.size();
}
inline void TxSet::clear_tran_envs() {
  tran_envs_.Clear();
}
inline const ::protocol::TransactionEnv& TxSet::tran_envs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TxSet.tran_envs)
  return tran_envs_.Get(index);
}
inline ::protocol::TransactionEnv* TxSet::mutable_tran_envs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TxSet.tran_envs)
  return tran_envs_.Mutable(index);
}
inline ::protocol::TransactionEnv* TxSet::add_tran_envs() {
  // @@protoc_insertion_point(field_add:protocol.TxSet.tran_envs)
  return tran_envs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >*
TxSet::mutable_tran_envs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TxSet.tran_envs)
  return &tran_envs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::TransactionEnv >&
TxSet::tran_envs() const {
  // @@protoc_insertion_point(field_list:protocol.TxSet.tran_envs)
  return tran_envs_;
}

// -------------------------------------------------------------------

// DontHave

// required int32 type = 1;
inline bool DontHave::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DontHave::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DontHave::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DontHave::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DontHave::type() const {
  // @@protoc_insertion_point(field_get:protocol.DontHave.type)
  return type_;
}
inline void DontHave::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.DontHave.type)
}

// required bytes hash = 2;
inline bool DontHave::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DontHave::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DontHave::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DontHave::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& DontHave::hash() const {
  // @@protoc_insertion_point(field_get:protocol.DontHave.hash)
  return hash_.GetNoArena();
}
inline void DontHave::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.DontHave.hash)
}
#if LANG_CXX11
inline void DontHave::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.DontHave.hash)
}
#endif
inline void DontHave::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.DontHave.hash)
}
inline void DontHave::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.DontHave.hash)
}
inline ::std::string* DontHave::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:protocol.DontHave.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DontHave::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.DontHave.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DontHave::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.DontHave.hash)
}

// -------------------------------------------------------------------

// Hash

// required bytes hash = 2;
inline bool Hash::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Hash::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Hash::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Hash::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& Hash::hash() const {
  // @@protoc_insertion_point(field_get:protocol.Hash.hash)
  return hash_.GetNoArena();
}
inline void Hash::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Hash.hash)
}
#if LANG_CXX11
inline void Hash::set_hash(::std::string&& value) {
  set_has_hash();
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Hash.hash)
}
#endif
inline void Hash::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Hash.hash)
}
inline void Hash::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Hash.hash)
}
inline ::std::string* Hash::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:protocol.Hash.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Hash::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.Hash.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Hash::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.Hash.hash)
}

// -------------------------------------------------------------------

// PbftPrePrepare

// required int64 view_number = 1;
inline bool PbftPrePrepare::has_view_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbftPrePrepare::set_has_view_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbftPrePrepare::clear_has_view_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbftPrePrepare::clear_view_number() {
  view_number_ = GOOGLE_LONGLONG(0);
  clear_has_view_number();
}
inline ::google::protobuf::int64 PbftPrePrepare::view_number() const {
  // @@protoc_insertion_point(field_get:protocol.PbftPrePrepare.view_number)
  return view_number_;
}
inline void PbftPrePrepare::set_view_number(::google::protobuf::int64 value) {
  set_has_view_number();
  view_number_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftPrePrepare.view_number)
}

// required int64 sequence = 2;
inline bool PbftPrePrepare::has_sequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbftPrePrepare::set_has_sequence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbftPrePrepare::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbftPrePrepare::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 PbftPrePrepare::sequence() const {
  // @@protoc_insertion_point(field_get:protocol.PbftPrePrepare.sequence)
  return sequence_;
}
inline void PbftPrePrepare::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftPrePrepare.sequence)
}

// required int64 replica_id = 3;
inline bool PbftPrePrepare::has_replica_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbftPrePrepare::set_has_replica_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbftPrePrepare::clear_has_replica_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbftPrePrepare::clear_replica_id() {
  replica_id_ = GOOGLE_LONGLONG(0);
  clear_has_replica_id();
}
inline ::google::protobuf::int64 PbftPrePrepare::replica_id() const {
  // @@protoc_insertion_point(field_get:protocol.PbftPrePrepare.replica_id)
  return replica_id_;
}
inline void PbftPrePrepare::set_replica_id(::google::protobuf::int64 value) {
  set_has_replica_id();
  replica_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftPrePrepare.replica_id)
}

// required .protocol.Value value = 4;
inline bool PbftPrePrepare::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbftPrePrepare::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbftPrePrepare::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbftPrePrepare::clear_value() {
  if (value_ != NULL) value_->::protocol::Value::Clear();
  clear_has_value();
}
inline const ::protocol::Value& PbftPrePrepare::value() const {
  // @@protoc_insertion_point(field_get:protocol.PbftPrePrepare.value)
  return value_ != NULL ? *value_
                         : *::protocol::Value::internal_default_instance();
}
inline ::protocol::Value* PbftPrePrepare::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::protocol::Value;
  }
  // @@protoc_insertion_point(field_mutable:protocol.PbftPrePrepare.value)
  return value_;
}
inline ::protocol::Value* PbftPrePrepare::release_value() {
  // @@protoc_insertion_point(field_release:protocol.PbftPrePrepare.value)
  clear_has_value();
  ::protocol::Value* temp = value_;
  value_ = NULL;
  return temp;
}
inline void PbftPrePrepare::set_allocated_value(::protocol::Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.PbftPrePrepare.value)
}

// required bytes value_digest = 5;
inline bool PbftPrePrepare::has_value_digest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbftPrePrepare::set_has_value_digest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbftPrePrepare::clear_has_value_digest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbftPrePrepare::clear_value_digest() {
  value_digest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value_digest();
}
inline const ::std::string& PbftPrePrepare::value_digest() const {
  // @@protoc_insertion_point(field_get:protocol.PbftPrePrepare.value_digest)
  return value_digest_.GetNoArena();
}
inline void PbftPrePrepare::set_value_digest(const ::std::string& value) {
  set_has_value_digest();
  value_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.PbftPrePrepare.value_digest)
}
#if LANG_CXX11
inline void PbftPrePrepare::set_value_digest(::std::string&& value) {
  set_has_value_digest();
  value_digest_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.PbftPrePrepare.value_digest)
}
#endif
inline void PbftPrePrepare::set_value_digest(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value_digest();
  value_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.PbftPrePrepare.value_digest)
}
inline void PbftPrePrepare::set_value_digest(const void* value, size_t size) {
  set_has_value_digest();
  value_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.PbftPrePrepare.value_digest)
}
inline ::std::string* PbftPrePrepare::mutable_value_digest() {
  set_has_value_digest();
  // @@protoc_insertion_point(field_mutable:protocol.PbftPrePrepare.value_digest)
  return value_digest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PbftPrePrepare::release_value_digest() {
  // @@protoc_insertion_point(field_release:protocol.PbftPrePrepare.value_digest)
  clear_has_value_digest();
  return value_digest_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PbftPrePrepare::set_allocated_value_digest(::std::string* value_digest) {
  if (value_digest != NULL) {
    set_has_value_digest();
  } else {
    clear_has_value_digest();
  }
  value_digest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value_digest);
  // @@protoc_insertion_point(field_set_allocated:protocol.PbftPrePrepare.value_digest)
}

// required int64 block_seq = 6;
inline bool PbftPrePrepare::has_block_seq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PbftPrePrepare::set_has_block_seq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PbftPrePrepare::clear_has_block_seq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PbftPrePrepare::clear_block_seq() {
  block_seq_ = GOOGLE_LONGLONG(0);
  clear_has_block_seq();
}
inline ::google::protobuf::int64 PbftPrePrepare::block_seq() const {
  // @@protoc_insertion_point(field_get:protocol.PbftPrePrepare.block_seq)
  return block_seq_;
}
inline void PbftPrePrepare::set_block_seq(::google::protobuf::int64 value) {
  set_has_block_seq();
  block_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftPrePrepare.block_seq)
}

// -------------------------------------------------------------------

// PbftPrepare

// required int64 view_number = 1;
inline bool PbftPrepare::has_view_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbftPrepare::set_has_view_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbftPrepare::clear_has_view_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbftPrepare::clear_view_number() {
  view_number_ = GOOGLE_LONGLONG(0);
  clear_has_view_number();
}
inline ::google::protobuf::int64 PbftPrepare::view_number() const {
  // @@protoc_insertion_point(field_get:protocol.PbftPrepare.view_number)
  return view_number_;
}
inline void PbftPrepare::set_view_number(::google::protobuf::int64 value) {
  set_has_view_number();
  view_number_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftPrepare.view_number)
}

// required int64 sequence = 2;
inline bool PbftPrepare::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbftPrepare::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbftPrepare::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbftPrepare::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 PbftPrepare::sequence() const {
  // @@protoc_insertion_point(field_get:protocol.PbftPrepare.sequence)
  return sequence_;
}
inline void PbftPrepare::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftPrepare.sequence)
}

// required int64 replica_id = 3;
inline bool PbftPrepare::has_replica_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbftPrepare::set_has_replica_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbftPrepare::clear_has_replica_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbftPrepare::clear_replica_id() {
  replica_id_ = GOOGLE_LONGLONG(0);
  clear_has_replica_id();
}
inline ::google::protobuf::int64 PbftPrepare::replica_id() const {
  // @@protoc_insertion_point(field_get:protocol.PbftPrepare.replica_id)
  return replica_id_;
}
inline void PbftPrepare::set_replica_id(::google::protobuf::int64 value) {
  set_has_replica_id();
  replica_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftPrepare.replica_id)
}

// required bytes value_digest = 4;
inline bool PbftPrepare::has_value_digest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbftPrepare::set_has_value_digest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbftPrepare::clear_has_value_digest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbftPrepare::clear_value_digest() {
  value_digest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value_digest();
}
inline const ::std::string& PbftPrepare::value_digest() const {
  // @@protoc_insertion_point(field_get:protocol.PbftPrepare.value_digest)
  return value_digest_.GetNoArena();
}
inline void PbftPrepare::set_value_digest(const ::std::string& value) {
  set_has_value_digest();
  value_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.PbftPrepare.value_digest)
}
#if LANG_CXX11
inline void PbftPrepare::set_value_digest(::std::string&& value) {
  set_has_value_digest();
  value_digest_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.PbftPrepare.value_digest)
}
#endif
inline void PbftPrepare::set_value_digest(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value_digest();
  value_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.PbftPrepare.value_digest)
}
inline void PbftPrepare::set_value_digest(const void* value, size_t size) {
  set_has_value_digest();
  value_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.PbftPrepare.value_digest)
}
inline ::std::string* PbftPrepare::mutable_value_digest() {
  set_has_value_digest();
  // @@protoc_insertion_point(field_mutable:protocol.PbftPrepare.value_digest)
  return value_digest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PbftPrepare::release_value_digest() {
  // @@protoc_insertion_point(field_release:protocol.PbftPrepare.value_digest)
  clear_has_value_digest();
  return value_digest_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PbftPrepare::set_allocated_value_digest(::std::string* value_digest) {
  if (value_digest != NULL) {
    set_has_value_digest();
  } else {
    clear_has_value_digest();
  }
  value_digest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value_digest);
  // @@protoc_insertion_point(field_set_allocated:protocol.PbftPrepare.value_digest)
}

// -------------------------------------------------------------------

// PbftCommit

// required int64 view_number = 1;
inline bool PbftCommit::has_view_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbftCommit::set_has_view_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbftCommit::clear_has_view_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbftCommit::clear_view_number() {
  view_number_ = GOOGLE_LONGLONG(0);
  clear_has_view_number();
}
inline ::google::protobuf::int64 PbftCommit::view_number() const {
  // @@protoc_insertion_point(field_get:protocol.PbftCommit.view_number)
  return view_number_;
}
inline void PbftCommit::set_view_number(::google::protobuf::int64 value) {
  set_has_view_number();
  view_number_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftCommit.view_number)
}

// required int64 sequence = 2;
inline bool PbftCommit::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbftCommit::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbftCommit::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbftCommit::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 PbftCommit::sequence() const {
  // @@protoc_insertion_point(field_get:protocol.PbftCommit.sequence)
  return sequence_;
}
inline void PbftCommit::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftCommit.sequence)
}

// required int64 replica_id = 3;
inline bool PbftCommit::has_replica_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbftCommit::set_has_replica_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbftCommit::clear_has_replica_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbftCommit::clear_replica_id() {
  replica_id_ = GOOGLE_LONGLONG(0);
  clear_has_replica_id();
}
inline ::google::protobuf::int64 PbftCommit::replica_id() const {
  // @@protoc_insertion_point(field_get:protocol.PbftCommit.replica_id)
  return replica_id_;
}
inline void PbftCommit::set_replica_id(::google::protobuf::int64 value) {
  set_has_replica_id();
  replica_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftCommit.replica_id)
}

// required bytes value_digest = 4;
inline bool PbftCommit::has_value_digest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbftCommit::set_has_value_digest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbftCommit::clear_has_value_digest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbftCommit::clear_value_digest() {
  value_digest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value_digest();
}
inline const ::std::string& PbftCommit::value_digest() const {
  // @@protoc_insertion_point(field_get:protocol.PbftCommit.value_digest)
  return value_digest_.GetNoArena();
}
inline void PbftCommit::set_value_digest(const ::std::string& value) {
  set_has_value_digest();
  value_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.PbftCommit.value_digest)
}
#if LANG_CXX11
inline void PbftCommit::set_value_digest(::std::string&& value) {
  set_has_value_digest();
  value_digest_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.PbftCommit.value_digest)
}
#endif
inline void PbftCommit::set_value_digest(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value_digest();
  value_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.PbftCommit.value_digest)
}
inline void PbftCommit::set_value_digest(const void* value, size_t size) {
  set_has_value_digest();
  value_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.PbftCommit.value_digest)
}
inline ::std::string* PbftCommit::mutable_value_digest() {
  set_has_value_digest();
  // @@protoc_insertion_point(field_mutable:protocol.PbftCommit.value_digest)
  return value_digest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PbftCommit::release_value_digest() {
  // @@protoc_insertion_point(field_release:protocol.PbftCommit.value_digest)
  clear_has_value_digest();
  return value_digest_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PbftCommit::set_allocated_value_digest(::std::string* value_digest) {
  if (value_digest != NULL) {
    set_has_value_digest();
  } else {
    clear_has_value_digest();
  }
  value_digest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value_digest);
  // @@protoc_insertion_point(field_set_allocated:protocol.PbftCommit.value_digest)
}

// -------------------------------------------------------------------

// PbftCheckPoint

// required int64 sequence = 1;
inline bool PbftCheckPoint::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbftCheckPoint::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbftCheckPoint::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbftCheckPoint::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 PbftCheckPoint::sequence() const {
  // @@protoc_insertion_point(field_get:protocol.PbftCheckPoint.sequence)
  return sequence_;
}
inline void PbftCheckPoint::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftCheckPoint.sequence)
}

// required int64 replica_id = 2;
inline bool PbftCheckPoint::has_replica_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbftCheckPoint::set_has_replica_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbftCheckPoint::clear_has_replica_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbftCheckPoint::clear_replica_id() {
  replica_id_ = GOOGLE_LONGLONG(0);
  clear_has_replica_id();
}
inline ::google::protobuf::int64 PbftCheckPoint::replica_id() const {
  // @@protoc_insertion_point(field_get:protocol.PbftCheckPoint.replica_id)
  return replica_id_;
}
inline void PbftCheckPoint::set_replica_id(::google::protobuf::int64 value) {
  set_has_replica_id();
  replica_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftCheckPoint.replica_id)
}

// required bytes state_digest = 3;
inline bool PbftCheckPoint::has_state_digest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbftCheckPoint::set_has_state_digest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbftCheckPoint::clear_has_state_digest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbftCheckPoint::clear_state_digest() {
  state_digest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_state_digest();
}
inline const ::std::string& PbftCheckPoint::state_digest() const {
  // @@protoc_insertion_point(field_get:protocol.PbftCheckPoint.state_digest)
  return state_digest_.GetNoArena();
}
inline void PbftCheckPoint::set_state_digest(const ::std::string& value) {
  set_has_state_digest();
  state_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.PbftCheckPoint.state_digest)
}
#if LANG_CXX11
inline void PbftCheckPoint::set_state_digest(::std::string&& value) {
  set_has_state_digest();
  state_digest_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.PbftCheckPoint.state_digest)
}
#endif
inline void PbftCheckPoint::set_state_digest(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_state_digest();
  state_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.PbftCheckPoint.state_digest)
}
inline void PbftCheckPoint::set_state_digest(const void* value, size_t size) {
  set_has_state_digest();
  state_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.PbftCheckPoint.state_digest)
}
inline ::std::string* PbftCheckPoint::mutable_state_digest() {
  set_has_state_digest();
  // @@protoc_insertion_point(field_mutable:protocol.PbftCheckPoint.state_digest)
  return state_digest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PbftCheckPoint::release_state_digest() {
  // @@protoc_insertion_point(field_release:protocol.PbftCheckPoint.state_digest)
  clear_has_state_digest();
  return state_digest_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PbftCheckPoint::set_allocated_state_digest(::std::string* state_digest) {
  if (state_digest != NULL) {
    set_has_state_digest();
  } else {
    clear_has_state_digest();
  }
  state_digest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state_digest);
  // @@protoc_insertion_point(field_set_allocated:protocol.PbftCheckPoint.state_digest)
}

// -------------------------------------------------------------------

// PbftPreparedSet

// required .protocol.PbftEnv pre_prepare = 1;
inline bool PbftPreparedSet::has_pre_prepare() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbftPreparedSet::set_has_pre_prepare() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbftPreparedSet::clear_has_pre_prepare() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbftPreparedSet::clear_pre_prepare() {
  if (pre_prepare_ != NULL) pre_prepare_->::protocol::PbftEnv::Clear();
  clear_has_pre_prepare();
}
inline const ::protocol::PbftEnv& PbftPreparedSet::pre_prepare() const {
  // @@protoc_insertion_point(field_get:protocol.PbftPreparedSet.pre_prepare)
  return pre_prepare_ != NULL ? *pre_prepare_
                         : *::protocol::PbftEnv::internal_default_instance();
}
inline ::protocol::PbftEnv* PbftPreparedSet::mutable_pre_prepare() {
  set_has_pre_prepare();
  if (pre_prepare_ == NULL) {
    pre_prepare_ = new ::protocol::PbftEnv;
  }
  // @@protoc_insertion_point(field_mutable:protocol.PbftPreparedSet.pre_prepare)
  return pre_prepare_;
}
inline ::protocol::PbftEnv* PbftPreparedSet::release_pre_prepare() {
  // @@protoc_insertion_point(field_release:protocol.PbftPreparedSet.pre_prepare)
  clear_has_pre_prepare();
  ::protocol::PbftEnv* temp = pre_prepare_;
  pre_prepare_ = NULL;
  return temp;
}
inline void PbftPreparedSet::set_allocated_pre_prepare(::protocol::PbftEnv* pre_prepare) {
  delete pre_prepare_;
  pre_prepare_ = pre_prepare;
  if (pre_prepare) {
    set_has_pre_prepare();
  } else {
    clear_has_pre_prepare();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.PbftPreparedSet.pre_prepare)
}

// repeated .protocol.PbftEnv prepare = 2;
inline int PbftPreparedSet::prepare_size() const {
  return prepare_.size();
}
inline void PbftPreparedSet::clear_prepare() {
  prepare_.Clear();
}
inline const ::protocol::PbftEnv& PbftPreparedSet::prepare(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PbftPreparedSet.prepare)
  return prepare_.Get(index);
}
inline ::protocol::PbftEnv* PbftPreparedSet::mutable_prepare(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PbftPreparedSet.prepare)
  return prepare_.Mutable(index);
}
inline ::protocol::PbftEnv* PbftPreparedSet::add_prepare() {
  // @@protoc_insertion_point(field_add:protocol.PbftPreparedSet.prepare)
  return prepare_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >*
PbftPreparedSet::mutable_prepare() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PbftPreparedSet.prepare)
  return &prepare_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >&
PbftPreparedSet::prepare() const {
  // @@protoc_insertion_point(field_list:protocol.PbftPreparedSet.prepare)
  return prepare_;
}

// -------------------------------------------------------------------

// PbftViewChange

// required int64 view_number = 1;
inline bool PbftViewChange::has_view_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbftViewChange::set_has_view_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbftViewChange::clear_has_view_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbftViewChange::clear_view_number() {
  view_number_ = GOOGLE_LONGLONG(0);
  clear_has_view_number();
}
inline ::google::protobuf::int64 PbftViewChange::view_number() const {
  // @@protoc_insertion_point(field_get:protocol.PbftViewChange.view_number)
  return view_number_;
}
inline void PbftViewChange::set_view_number(::google::protobuf::int64 value) {
  set_has_view_number();
  view_number_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftViewChange.view_number)
}

// required int64 sequence = 2;
inline bool PbftViewChange::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbftViewChange::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbftViewChange::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbftViewChange::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 PbftViewChange::sequence() const {
  // @@protoc_insertion_point(field_get:protocol.PbftViewChange.sequence)
  return sequence_;
}
inline void PbftViewChange::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftViewChange.sequence)
}

// repeated .protocol.PbftEnv checkpoints = 3;
inline int PbftViewChange::checkpoints_size() const {
  return checkpoints_.size();
}
inline void PbftViewChange::clear_checkpoints() {
  checkpoints_.Clear();
}
inline const ::protocol::PbftEnv& PbftViewChange::checkpoints(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PbftViewChange.checkpoints)
  return checkpoints_.Get(index);
}
inline ::protocol::PbftEnv* PbftViewChange::mutable_checkpoints(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PbftViewChange.checkpoints)
  return checkpoints_.Mutable(index);
}
inline ::protocol::PbftEnv* PbftViewChange::add_checkpoints() {
  // @@protoc_insertion_point(field_add:protocol.PbftViewChange.checkpoints)
  return checkpoints_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >*
PbftViewChange::mutable_checkpoints() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PbftViewChange.checkpoints)
  return &checkpoints_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >&
PbftViewChange::checkpoints() const {
  // @@protoc_insertion_point(field_list:protocol.PbftViewChange.checkpoints)
  return checkpoints_;
}

// repeated .protocol.PbftPreparedSet prepared_set = 4;
inline int PbftViewChange::prepared_set_size() const {
  return prepared_set_.size();
}
inline void PbftViewChange::clear_prepared_set() {
  prepared_set_.Clear();
}
inline const ::protocol::PbftPreparedSet& PbftViewChange::prepared_set(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PbftViewChange.prepared_set)
  return prepared_set_.Get(index);
}
inline ::protocol::PbftPreparedSet* PbftViewChange::mutable_prepared_set(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PbftViewChange.prepared_set)
  return prepared_set_.Mutable(index);
}
inline ::protocol::PbftPreparedSet* PbftViewChange::add_prepared_set() {
  // @@protoc_insertion_point(field_add:protocol.PbftViewChange.prepared_set)
  return prepared_set_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::PbftPreparedSet >*
PbftViewChange::mutable_prepared_set() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PbftViewChange.prepared_set)
  return &prepared_set_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::PbftPreparedSet >&
PbftViewChange::prepared_set() const {
  // @@protoc_insertion_point(field_list:protocol.PbftViewChange.prepared_set)
  return prepared_set_;
}

// required int64 replica_id = 5;
inline bool PbftViewChange::has_replica_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbftViewChange::set_has_replica_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbftViewChange::clear_has_replica_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbftViewChange::clear_replica_id() {
  replica_id_ = GOOGLE_LONGLONG(0);
  clear_has_replica_id();
}
inline ::google::protobuf::int64 PbftViewChange::replica_id() const {
  // @@protoc_insertion_point(field_get:protocol.PbftViewChange.replica_id)
  return replica_id_;
}
inline void PbftViewChange::set_replica_id(::google::protobuf::int64 value) {
  set_has_replica_id();
  replica_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftViewChange.replica_id)
}

// -------------------------------------------------------------------

// PbftNewView

// required int64 view_number = 1;
inline bool PbftNewView::has_view_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbftNewView::set_has_view_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbftNewView::clear_has_view_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbftNewView::clear_view_number() {
  view_number_ = GOOGLE_LONGLONG(0);
  clear_has_view_number();
}
inline ::google::protobuf::int64 PbftNewView::view_number() const {
  // @@protoc_insertion_point(field_get:protocol.PbftNewView.view_number)
  return view_number_;
}
inline void PbftNewView::set_view_number(::google::protobuf::int64 value) {
  set_has_view_number();
  view_number_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftNewView.view_number)
}

// required int64 sequence = 2;
inline bool PbftNewView::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbftNewView::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbftNewView::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbftNewView::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 PbftNewView::sequence() const {
  // @@protoc_insertion_point(field_get:protocol.PbftNewView.sequence)
  return sequence_;
}
inline void PbftNewView::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftNewView.sequence)
}

// required int64 replica_id = 3;
inline bool PbftNewView::has_replica_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbftNewView::set_has_replica_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbftNewView::clear_has_replica_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbftNewView::clear_replica_id() {
  replica_id_ = GOOGLE_LONGLONG(0);
  clear_has_replica_id();
}
inline ::google::protobuf::int64 PbftNewView::replica_id() const {
  // @@protoc_insertion_point(field_get:protocol.PbftNewView.replica_id)
  return replica_id_;
}
inline void PbftNewView::set_replica_id(::google::protobuf::int64 value) {
  set_has_replica_id();
  replica_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.PbftNewView.replica_id)
}

// repeated .protocol.PbftEnv view_changes = 4;
inline int PbftNewView::view_changes_size() const {
  return view_changes_.size();
}
inline void PbftNewView::clear_view_changes() {
  view_changes_.Clear();
}
inline const ::protocol::PbftEnv& PbftNewView::view_changes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PbftNewView.view_changes)
  return view_changes_.Get(index);
}
inline ::protocol::PbftEnv* PbftNewView::mutable_view_changes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PbftNewView.view_changes)
  return view_changes_.Mutable(index);
}
inline ::protocol::PbftEnv* PbftNewView::add_view_changes() {
  // @@protoc_insertion_point(field_add:protocol.PbftNewView.view_changes)
  return view_changes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >*
PbftNewView::mutable_view_changes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PbftNewView.view_changes)
  return &view_changes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >&
PbftNewView::view_changes() const {
  // @@protoc_insertion_point(field_list:protocol.PbftNewView.view_changes)
  return view_changes_;
}

// repeated .protocol.PbftEnv pre_prepares = 5;
inline int PbftNewView::pre_prepares_size() const {
  return pre_prepares_.size();
}
inline void PbftNewView::clear_pre_prepares() {
  pre_prepares_.Clear();
}
inline const ::protocol::PbftEnv& PbftNewView::pre_prepares(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PbftNewView.pre_prepares)
  return pre_prepares_.Get(index);
}
inline ::protocol::PbftEnv* PbftNewView::mutable_pre_prepares(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PbftNewView.pre_prepares)
  return pre_prepares_.Mutable(index);
}
inline ::protocol::PbftEnv* PbftNewView::add_pre_prepares() {
  // @@protoc_insertion_point(field_add:protocol.PbftNewView.pre_prepares)
  return pre_prepares_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >*
PbftNewView::mutable_pre_prepares() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PbftNewView.pre_prepares)
  return &pre_prepares_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::PbftEnv >&
PbftNewView::pre_prepares() const {
  // @@protoc_insertion_point(field_list:protocol.PbftNewView.pre_prepares)
  return pre_prepares_;
}

// -------------------------------------------------------------------

// Pbft

// required uint32 round_number = 1;
inline bool Pbft::has_round_number() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Pbft::set_has_round_number() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Pbft::clear_has_round_number() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Pbft::clear_round_number() {
  round_number_ = 0u;
  clear_has_round_number();
}
inline ::google::protobuf::uint32 Pbft::round_number() const {
  // @@protoc_insertion_point(field_get:protocol.Pbft.round_number)
  return round_number_;
}
inline void Pbft::set_round_number(::google::protobuf::uint32 value) {
  set_has_round_number();
  round_number_ = value;
  // @@protoc_insertion_point(field_set:protocol.Pbft.round_number)
}

// required bytes validator_hash = 2;
inline bool Pbft::has_validator_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pbft::set_has_validator_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pbft::clear_has_validator_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pbft::clear_validator_hash() {
  validator_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_validator_hash();
}
inline const ::std::string& Pbft::validator_hash() const {
  // @@protoc_insertion_point(field_get:protocol.Pbft.validator_hash)
  return validator_hash_.GetNoArena();
}
inline void Pbft::set_validator_hash(const ::std::string& value) {
  set_has_validator_hash();
  validator_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.Pbft.validator_hash)
}
#if LANG_CXX11
inline void Pbft::set_validator_hash(::std::string&& value) {
  set_has_validator_hash();
  validator_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.Pbft.validator_hash)
}
#endif
inline void Pbft::set_validator_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_validator_hash();
  validator_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.Pbft.validator_hash)
}
inline void Pbft::set_validator_hash(const void* value, size_t size) {
  set_has_validator_hash();
  validator_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.Pbft.validator_hash)
}
inline ::std::string* Pbft::mutable_validator_hash() {
  set_has_validator_hash();
  // @@protoc_insertion_point(field_mutable:protocol.Pbft.validator_hash)
  return validator_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pbft::release_validator_hash() {
  // @@protoc_insertion_point(field_release:protocol.Pbft.validator_hash)
  clear_has_validator_hash();
  return validator_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pbft::set_allocated_validator_hash(::std::string* validator_hash) {
  if (validator_hash != NULL) {
    set_has_validator_hash();
  } else {
    clear_has_validator_hash();
  }
  validator_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), validator_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.Pbft.validator_hash)
}

// required .protocol.PbftMessageType type = 3;
inline bool Pbft::has_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Pbft::set_has_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Pbft::clear_has_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Pbft::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::protocol::PbftMessageType Pbft::type() const {
  // @@protoc_insertion_point(field_get:protocol.Pbft.type)
  return static_cast< ::protocol::PbftMessageType >(type_);
}
inline void Pbft::set_type(::protocol::PbftMessageType value) {
  assert(::protocol::PbftMessageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.Pbft.type)
}

// optional .protocol.PbftPrePrepare pre_prepare = 4;
inline bool Pbft::has_pre_prepare() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pbft::set_has_pre_prepare() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pbft::clear_has_pre_prepare() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pbft::clear_pre_prepare() {
  if (pre_prepare_ != NULL) pre_prepare_->::protocol::PbftPrePrepare::Clear();
  clear_has_pre_prepare();
}
inline const ::protocol::PbftPrePrepare& Pbft::pre_prepare() const {
  // @@protoc_insertion_point(field_get:protocol.Pbft.pre_prepare)
  return pre_prepare_ != NULL ? *pre_prepare_
                         : *::protocol::PbftPrePrepare::internal_default_instance();
}
inline ::protocol::PbftPrePrepare* Pbft::mutable_pre_prepare() {
  set_has_pre_prepare();
  if (pre_prepare_ == NULL) {
    pre_prepare_ = new ::protocol::PbftPrePrepare;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Pbft.pre_prepare)
  return pre_prepare_;
}
inline ::protocol::PbftPrePrepare* Pbft::release_pre_prepare() {
  // @@protoc_insertion_point(field_release:protocol.Pbft.pre_prepare)
  clear_has_pre_prepare();
  ::protocol::PbftPrePrepare* temp = pre_prepare_;
  pre_prepare_ = NULL;
  return temp;
}
inline void Pbft::set_allocated_pre_prepare(::protocol::PbftPrePrepare* pre_prepare) {
  delete pre_prepare_;
  pre_prepare_ = pre_prepare;
  if (pre_prepare) {
    set_has_pre_prepare();
  } else {
    clear_has_pre_prepare();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Pbft.pre_prepare)
}

// optional .protocol.PbftPrepare prepare = 5;
inline bool Pbft::has_prepare() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Pbft::set_has_prepare() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Pbft::clear_has_prepare() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Pbft::clear_prepare() {
  if (prepare_ != NULL) prepare_->::protocol::PbftPrepare::Clear();
  clear_has_prepare();
}
inline const ::protocol::PbftPrepare& Pbft::prepare() const {
  // @@protoc_insertion_point(field_get:protocol.Pbft.prepare)
  return prepare_ != NULL ? *prepare_
                         : *::protocol::PbftPrepare::internal_default_instance();
}
inline ::protocol::PbftPrepare* Pbft::mutable_prepare() {
  set_has_prepare();
  if (prepare_ == NULL) {
    prepare_ = new ::protocol::PbftPrepare;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Pbft.prepare)
  return prepare_;
}
inline ::protocol::PbftPrepare* Pbft::release_prepare() {
  // @@protoc_insertion_point(field_release:protocol.Pbft.prepare)
  clear_has_prepare();
  ::protocol::PbftPrepare* temp = prepare_;
  prepare_ = NULL;
  return temp;
}
inline void Pbft::set_allocated_prepare(::protocol::PbftPrepare* prepare) {
  delete prepare_;
  prepare_ = prepare;
  if (prepare) {
    set_has_prepare();
  } else {
    clear_has_prepare();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Pbft.prepare)
}

// optional .protocol.PbftCommit commit = 6;
inline bool Pbft::has_commit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Pbft::set_has_commit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Pbft::clear_has_commit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Pbft::clear_commit() {
  if (commit_ != NULL) commit_->::protocol::PbftCommit::Clear();
  clear_has_commit();
}
inline const ::protocol::PbftCommit& Pbft::commit() const {
  // @@protoc_insertion_point(field_get:protocol.Pbft.commit)
  return commit_ != NULL ? *commit_
                         : *::protocol::PbftCommit::internal_default_instance();
}
inline ::protocol::PbftCommit* Pbft::mutable_commit() {
  set_has_commit();
  if (commit_ == NULL) {
    commit_ = new ::protocol::PbftCommit;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Pbft.commit)
  return commit_;
}
inline ::protocol::PbftCommit* Pbft::release_commit() {
  // @@protoc_insertion_point(field_release:protocol.Pbft.commit)
  clear_has_commit();
  ::protocol::PbftCommit* temp = commit_;
  commit_ = NULL;
  return temp;
}
inline void Pbft::set_allocated_commit(::protocol::PbftCommit* commit) {
  delete commit_;
  commit_ = commit;
  if (commit) {
    set_has_commit();
  } else {
    clear_has_commit();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Pbft.commit)
}

// optional .protocol.PbftCheckPoint checkpoint = 7;
inline bool Pbft::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Pbft::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Pbft::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Pbft::clear_checkpoint() {
  if (checkpoint_ != NULL) checkpoint_->::protocol::PbftCheckPoint::Clear();
  clear_has_checkpoint();
}
inline const ::protocol::PbftCheckPoint& Pbft::checkpoint() const {
  // @@protoc_insertion_point(field_get:protocol.Pbft.checkpoint)
  return checkpoint_ != NULL ? *checkpoint_
                         : *::protocol::PbftCheckPoint::internal_default_instance();
}
inline ::protocol::PbftCheckPoint* Pbft::mutable_checkpoint() {
  set_has_checkpoint();
  if (checkpoint_ == NULL) {
    checkpoint_ = new ::protocol::PbftCheckPoint;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Pbft.checkpoint)
  return checkpoint_;
}
inline ::protocol::PbftCheckPoint* Pbft::release_checkpoint() {
  // @@protoc_insertion_point(field_release:protocol.Pbft.checkpoint)
  clear_has_checkpoint();
  ::protocol::PbftCheckPoint* temp = checkpoint_;
  checkpoint_ = NULL;
  return temp;
}
inline void Pbft::set_allocated_checkpoint(::protocol::PbftCheckPoint* checkpoint) {
  delete checkpoint_;
  checkpoint_ = checkpoint;
  if (checkpoint) {
    set_has_checkpoint();
  } else {
    clear_has_checkpoint();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Pbft.checkpoint)
}

// optional .protocol.PbftViewChange view_change = 8;
inline bool Pbft::has_view_change() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Pbft::set_has_view_change() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Pbft::clear_has_view_change() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Pbft::clear_view_change() {
  if (view_change_ != NULL) view_change_->::protocol::PbftViewChange::Clear();
  clear_has_view_change();
}
inline const ::protocol::PbftViewChange& Pbft::view_change() const {
  // @@protoc_insertion_point(field_get:protocol.Pbft.view_change)
  return view_change_ != NULL ? *view_change_
                         : *::protocol::PbftViewChange::internal_default_instance();
}
inline ::protocol::PbftViewChange* Pbft::mutable_view_change() {
  set_has_view_change();
  if (view_change_ == NULL) {
    view_change_ = new ::protocol::PbftViewChange;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Pbft.view_change)
  return view_change_;
}
inline ::protocol::PbftViewChange* Pbft::release_view_change() {
  // @@protoc_insertion_point(field_release:protocol.Pbft.view_change)
  clear_has_view_change();
  ::protocol::PbftViewChange* temp = view_change_;
  view_change_ = NULL;
  return temp;
}
inline void Pbft::set_allocated_view_change(::protocol::PbftViewChange* view_change) {
  delete view_change_;
  view_change_ = view_change;
  if (view_change) {
    set_has_view_change();
  } else {
    clear_has_view_change();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Pbft.view_change)
}

// optional .protocol.PbftNewView new_view = 9;
inline bool Pbft::has_new_view() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Pbft::set_has_new_view() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Pbft::clear_has_new_view() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Pbft::clear_new_view() {
  if (new_view_ != NULL) new_view_->::protocol::PbftNewView::Clear();
  clear_has_new_view();
}
inline const ::protocol::PbftNewView& Pbft::new_view() const {
  // @@protoc_insertion_point(field_get:protocol.Pbft.new_view)
  return new_view_ != NULL ? *new_view_
                         : *::protocol::PbftNewView::internal_default_instance();
}
inline ::protocol::PbftNewView* Pbft::mutable_new_view() {
  set_has_new_view();
  if (new_view_ == NULL) {
    new_view_ = new ::protocol::PbftNewView;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Pbft.new_view)
  return new_view_;
}
inline ::protocol::PbftNewView* Pbft::release_new_view() {
  // @@protoc_insertion_point(field_release:protocol.Pbft.new_view)
  clear_has_new_view();
  ::protocol::PbftNewView* temp = new_view_;
  new_view_ = NULL;
  return temp;
}
inline void Pbft::set_allocated_new_view(::protocol::PbftNewView* new_view) {
  delete new_view_;
  new_view_ = new_view;
  if (new_view) {
    set_has_new_view();
  } else {
    clear_has_new_view();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Pbft.new_view)
}

// -------------------------------------------------------------------

// PbftEnv

// required .protocol.Pbft pbft = 1;
inline bool PbftEnv::has_pbft() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbftEnv::set_has_pbft() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbftEnv::clear_has_pbft() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbftEnv::clear_pbft() {
  if (pbft_ != NULL) pbft_->::protocol::Pbft::Clear();
  clear_has_pbft();
}
inline const ::protocol::Pbft& PbftEnv::pbft() const {
  // @@protoc_insertion_point(field_get:protocol.PbftEnv.pbft)
  return pbft_ != NULL ? *pbft_
                         : *::protocol::Pbft::internal_default_instance();
}
inline ::protocol::Pbft* PbftEnv::mutable_pbft() {
  set_has_pbft();
  if (pbft_ == NULL) {
    pbft_ = new ::protocol::Pbft;
  }
  // @@protoc_insertion_point(field_mutable:protocol.PbftEnv.pbft)
  return pbft_;
}
inline ::protocol::Pbft* PbftEnv::release_pbft() {
  // @@protoc_insertion_point(field_release:protocol.PbftEnv.pbft)
  clear_has_pbft();
  ::protocol::Pbft* temp = pbft_;
  pbft_ = NULL;
  return temp;
}
inline void PbftEnv::set_allocated_pbft(::protocol::Pbft* pbft) {
  delete pbft_;
  pbft_ = pbft;
  if (pbft) {
    set_has_pbft();
  } else {
    clear_has_pbft();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.PbftEnv.pbft)
}

// required .protocol.Signature signature = 2;
inline bool PbftEnv::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbftEnv::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbftEnv::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbftEnv::clear_signature() {
  if (signature_ != NULL) signature_->::protocol::Signature::Clear();
  clear_has_signature();
}
inline const ::protocol::Signature& PbftEnv::signature() const {
  // @@protoc_insertion_point(field_get:protocol.PbftEnv.signature)
  return signature_ != NULL ? *signature_
                         : *::protocol::Signature::internal_default_instance();
}
inline ::protocol::Signature* PbftEnv::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) {
    signature_ = new ::protocol::Signature;
  }
  // @@protoc_insertion_point(field_mutable:protocol.PbftEnv.signature)
  return signature_;
}
inline ::protocol::Signature* PbftEnv::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.PbftEnv.signature)
  clear_has_signature();
  ::protocol::Signature* temp = signature_;
  signature_ = NULL;
  return temp;
}
inline void PbftEnv::set_allocated_signature(::protocol::Signature* signature) {
  delete signature_;
  signature_ = signature;
  if (signature) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.PbftEnv.signature)
}

// -------------------------------------------------------------------

// EntryList

// repeated bytes entry = 1;
inline int EntryList::entry_size() const {
  return entry_.size();
}
inline void EntryList::clear_entry() {
  entry_.Clear();
}
inline const ::std::string& EntryList::entry(int index) const {
  // @@protoc_insertion_point(field_get:protocol.EntryList.entry)
  return entry_.Get(index);
}
inline ::std::string* EntryList::mutable_entry(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.EntryList.entry)
  return entry_.Mutable(index);
}
inline void EntryList::set_entry(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.EntryList.entry)
  entry_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void EntryList::set_entry(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.EntryList.entry)
  entry_.Mutable(index)->assign(std::move(value));
}
#endif
inline void EntryList::set_entry(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  entry_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.EntryList.entry)
}
inline void EntryList::set_entry(int index, const void* value, size_t size) {
  entry_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.EntryList.entry)
}
inline ::std::string* EntryList::add_entry() {
  // @@protoc_insertion_point(field_add_mutable:protocol.EntryList.entry)
  return entry_.Add();
}
inline void EntryList::add_entry(const ::std::string& value) {
  entry_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.EntryList.entry)
}
#if LANG_CXX11
inline void EntryList::add_entry(::std::string&& value) {
  entry_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.EntryList.entry)
}
#endif
inline void EntryList::add_entry(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  entry_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.EntryList.entry)
}
inline void EntryList::add_entry(const void* value, size_t size) {
  entry_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.EntryList.entry)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EntryList::entry() const {
  // @@protoc_insertion_point(field_list:protocol.EntryList.entry)
  return entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EntryList::mutable_entry() {
  // @@protoc_insertion_point(field_mutable_list:protocol.EntryList.entry)
  return &entry_;
}

// -------------------------------------------------------------------

// WsMessage

// required int64 type = 1;
inline bool WsMessage::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WsMessage::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WsMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WsMessage::clear_type() {
  type_ = GOOGLE_LONGLONG(0);
  clear_has_type();
}
inline ::google::protobuf::int64 WsMessage::type() const {
  // @@protoc_insertion_point(field_get:protocol.WsMessage.type)
  return type_;
}
inline void WsMessage::set_type(::google::protobuf::int64 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:protocol.WsMessage.type)
}

// required bool request = 2;
inline bool WsMessage::has_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WsMessage::set_has_request() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WsMessage::clear_has_request() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WsMessage::clear_request() {
  request_ = false;
  clear_has_request();
}
inline bool WsMessage::request() const {
  // @@protoc_insertion_point(field_get:protocol.WsMessage.request)
  return request_;
}
inline void WsMessage::set_request(bool value) {
  set_has_request();
  request_ = value;
  // @@protoc_insertion_point(field_set:protocol.WsMessage.request)
}

// required int64 sequence = 3;
inline bool WsMessage::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WsMessage::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WsMessage::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WsMessage::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 WsMessage::sequence() const {
  // @@protoc_insertion_point(field_get:protocol.WsMessage.sequence)
  return sequence_;
}
inline void WsMessage::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:protocol.WsMessage.sequence)
}

// required bytes data = 4;
inline bool WsMessage::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WsMessage::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WsMessage::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WsMessage::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& WsMessage::data() const {
  // @@protoc_insertion_point(field_get:protocol.WsMessage.data)
  return data_.GetNoArena();
}
inline void WsMessage::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.WsMessage.data)
}
#if LANG_CXX11
inline void WsMessage::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.WsMessage.data)
}
#endif
inline void WsMessage::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.WsMessage.data)
}
inline void WsMessage::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.WsMessage.data)
}
inline ::std::string* WsMessage::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:protocol.WsMessage.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WsMessage::release_data() {
  // @@protoc_insertion_point(field_release:protocol.WsMessage.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WsMessage::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:protocol.WsMessage.data)
}

// -------------------------------------------------------------------

// KeepOnline

// required string src_peer_addr = 1;
inline bool KeepOnline::has_src_peer_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeepOnline::set_has_src_peer_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeepOnline::clear_has_src_peer_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeepOnline::clear_src_peer_addr() {
  src_peer_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_peer_addr();
}
inline const ::std::string& KeepOnline::src_peer_addr() const {
  // @@protoc_insertion_point(field_get:protocol.KeepOnline.src_peer_addr)
  return src_peer_addr_.GetNoArena();
}
inline void KeepOnline::set_src_peer_addr(const ::std::string& value) {
  set_has_src_peer_addr();
  src_peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.KeepOnline.src_peer_addr)
}
#if LANG_CXX11
inline void KeepOnline::set_src_peer_addr(::std::string&& value) {
  set_has_src_peer_addr();
  src_peer_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.KeepOnline.src_peer_addr)
}
#endif
inline void KeepOnline::set_src_peer_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src_peer_addr();
  src_peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.KeepOnline.src_peer_addr)
}
inline void KeepOnline::set_src_peer_addr(const char* value, size_t size) {
  set_has_src_peer_addr();
  src_peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.KeepOnline.src_peer_addr)
}
inline ::std::string* KeepOnline::mutable_src_peer_addr() {
  set_has_src_peer_addr();
  // @@protoc_insertion_point(field_mutable:protocol.KeepOnline.src_peer_addr)
  return src_peer_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeepOnline::release_src_peer_addr() {
  // @@protoc_insertion_point(field_release:protocol.KeepOnline.src_peer_addr)
  clear_has_src_peer_addr();
  return src_peer_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeepOnline::set_allocated_src_peer_addr(::std::string* src_peer_addr) {
  if (src_peer_addr != NULL) {
    set_has_src_peer_addr();
  } else {
    clear_has_src_peer_addr();
  }
  src_peer_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_peer_addr);
  // @@protoc_insertion_point(field_set_allocated:protocol.KeepOnline.src_peer_addr)
}

// required int64 payload_seq = 2;
inline bool KeepOnline::has_payload_seq() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeepOnline::set_has_payload_seq() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeepOnline::clear_has_payload_seq() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeepOnline::clear_payload_seq() {
  payload_seq_ = GOOGLE_LONGLONG(0);
  clear_has_payload_seq();
}
inline ::google::protobuf::int64 KeepOnline::payload_seq() const {
  // @@protoc_insertion_point(field_get:protocol.KeepOnline.payload_seq)
  return payload_seq_;
}
inline void KeepOnline::set_payload_seq(::google::protobuf::int64 value) {
  set_has_payload_seq();
  payload_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.KeepOnline.payload_seq)
}

// -------------------------------------------------------------------

// KeepOnlineEnv

// required .protocol.KeepOnline keeponline = 1;
inline bool KeepOnlineEnv::has_keeponline() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeepOnlineEnv::set_has_keeponline() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeepOnlineEnv::clear_has_keeponline() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeepOnlineEnv::clear_keeponline() {
  if (keeponline_ != NULL) keeponline_->::protocol::KeepOnline::Clear();
  clear_has_keeponline();
}
inline const ::protocol::KeepOnline& KeepOnlineEnv::keeponline() const {
  // @@protoc_insertion_point(field_get:protocol.KeepOnlineEnv.keeponline)
  return keeponline_ != NULL ? *keeponline_
                         : *::protocol::KeepOnline::internal_default_instance();
}
inline ::protocol::KeepOnline* KeepOnlineEnv::mutable_keeponline() {
  set_has_keeponline();
  if (keeponline_ == NULL) {
    keeponline_ = new ::protocol::KeepOnline;
  }
  // @@protoc_insertion_point(field_mutable:protocol.KeepOnlineEnv.keeponline)
  return keeponline_;
}
inline ::protocol::KeepOnline* KeepOnlineEnv::release_keeponline() {
  // @@protoc_insertion_point(field_release:protocol.KeepOnlineEnv.keeponline)
  clear_has_keeponline();
  ::protocol::KeepOnline* temp = keeponline_;
  keeponline_ = NULL;
  return temp;
}
inline void KeepOnlineEnv::set_allocated_keeponline(::protocol::KeepOnline* keeponline) {
  delete keeponline_;
  keeponline_ = keeponline;
  if (keeponline) {
    set_has_keeponline();
  } else {
    clear_has_keeponline();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.KeepOnlineEnv.keeponline)
}

// required .protocol.Signature signature = 2;
inline bool KeepOnlineEnv::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeepOnlineEnv::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeepOnlineEnv::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeepOnlineEnv::clear_signature() {
  if (signature_ != NULL) signature_->::protocol::Signature::Clear();
  clear_has_signature();
}
inline const ::protocol::Signature& KeepOnlineEnv::signature() const {
  // @@protoc_insertion_point(field_get:protocol.KeepOnlineEnv.signature)
  return signature_ != NULL ? *signature_
                         : *::protocol::Signature::internal_default_instance();
}
inline ::protocol::Signature* KeepOnlineEnv::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) {
    signature_ = new ::protocol::Signature;
  }
  // @@protoc_insertion_point(field_mutable:protocol.KeepOnlineEnv.signature)
  return signature_;
}
inline ::protocol::Signature* KeepOnlineEnv::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.KeepOnlineEnv.signature)
  clear_has_signature();
  ::protocol::Signature* temp = signature_;
  signature_ = NULL;
  return temp;
}
inline void KeepOnlineEnv::set_allocated_signature(::protocol::Signature* signature) {
  delete signature_;
  signature_ = signature;
  if (signature) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.KeepOnlineEnv.signature)
}

// -------------------------------------------------------------------

// PayLoad

// required string src_peer_addr = 1;
inline bool PayLoad::has_src_peer_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayLoad::set_has_src_peer_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayLoad::clear_has_src_peer_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayLoad::clear_src_peer_addr() {
  src_peer_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_peer_addr();
}
inline const ::std::string& PayLoad::src_peer_addr() const {
  // @@protoc_insertion_point(field_get:protocol.PayLoad.src_peer_addr)
  return src_peer_addr_.GetNoArena();
}
inline void PayLoad::set_src_peer_addr(const ::std::string& value) {
  set_has_src_peer_addr();
  src_peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.PayLoad.src_peer_addr)
}
#if LANG_CXX11
inline void PayLoad::set_src_peer_addr(::std::string&& value) {
  set_has_src_peer_addr();
  src_peer_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.PayLoad.src_peer_addr)
}
#endif
inline void PayLoad::set_src_peer_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src_peer_addr();
  src_peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.PayLoad.src_peer_addr)
}
inline void PayLoad::set_src_peer_addr(const char* value, size_t size) {
  set_has_src_peer_addr();
  src_peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.PayLoad.src_peer_addr)
}
inline ::std::string* PayLoad::mutable_src_peer_addr() {
  set_has_src_peer_addr();
  // @@protoc_insertion_point(field_mutable:protocol.PayLoad.src_peer_addr)
  return src_peer_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PayLoad::release_src_peer_addr() {
  // @@protoc_insertion_point(field_release:protocol.PayLoad.src_peer_addr)
  clear_has_src_peer_addr();
  return src_peer_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PayLoad::set_allocated_src_peer_addr(::std::string* src_peer_addr) {
  if (src_peer_addr != NULL) {
    set_has_src_peer_addr();
  } else {
    clear_has_src_peer_addr();
  }
  src_peer_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_peer_addr);
  // @@protoc_insertion_point(field_set_allocated:protocol.PayLoad.src_peer_addr)
}

// repeated string des_peer_addrs = 2;
inline int PayLoad::des_peer_addrs_size() const {
  return des_peer_addrs_.size();
}
inline void PayLoad::clear_des_peer_addrs() {
  des_peer_addrs_.Clear();
}
inline const ::std::string& PayLoad::des_peer_addrs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.PayLoad.des_peer_addrs)
  return des_peer_addrs_.Get(index);
}
inline ::std::string* PayLoad::mutable_des_peer_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.PayLoad.des_peer_addrs)
  return des_peer_addrs_.Mutable(index);
}
inline void PayLoad::set_des_peer_addrs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.PayLoad.des_peer_addrs)
  des_peer_addrs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void PayLoad::set_des_peer_addrs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.PayLoad.des_peer_addrs)
  des_peer_addrs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void PayLoad::set_des_peer_addrs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  des_peer_addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.PayLoad.des_peer_addrs)
}
inline void PayLoad::set_des_peer_addrs(int index, const char* value, size_t size) {
  des_peer_addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.PayLoad.des_peer_addrs)
}
inline ::std::string* PayLoad::add_des_peer_addrs() {
  // @@protoc_insertion_point(field_add_mutable:protocol.PayLoad.des_peer_addrs)
  return des_peer_addrs_.Add();
}
inline void PayLoad::add_des_peer_addrs(const ::std::string& value) {
  des_peer_addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.PayLoad.des_peer_addrs)
}
#if LANG_CXX11
inline void PayLoad::add_des_peer_addrs(::std::string&& value) {
  des_peer_addrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.PayLoad.des_peer_addrs)
}
#endif
inline void PayLoad::add_des_peer_addrs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  des_peer_addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.PayLoad.des_peer_addrs)
}
inline void PayLoad::add_des_peer_addrs(const char* value, size_t size) {
  des_peer_addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.PayLoad.des_peer_addrs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PayLoad::des_peer_addrs() const {
  // @@protoc_insertion_point(field_list:protocol.PayLoad.des_peer_addrs)
  return des_peer_addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PayLoad::mutable_des_peer_addrs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.PayLoad.des_peer_addrs)
  return &des_peer_addrs_;
}

// required int64 timestamp = 4;
inline bool PayLoad::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PayLoad::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PayLoad::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PayLoad::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 PayLoad::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.PayLoad.timestamp)
  return timestamp_;
}
inline void PayLoad::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.PayLoad.timestamp)
}

// required bytes data = 5;
inline bool PayLoad::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayLoad::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayLoad::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayLoad::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& PayLoad::data() const {
  // @@protoc_insertion_point(field_get:protocol.PayLoad.data)
  return data_.GetNoArena();
}
inline void PayLoad::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.PayLoad.data)
}
#if LANG_CXX11
inline void PayLoad::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.PayLoad.data)
}
#endif
inline void PayLoad::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.PayLoad.data)
}
inline void PayLoad::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.PayLoad.data)
}
inline ::std::string* PayLoad::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:protocol.PayLoad.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PayLoad::release_data() {
  // @@protoc_insertion_point(field_release:protocol.PayLoad.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PayLoad::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:protocol.PayLoad.data)
}

// -------------------------------------------------------------------

// PayLoadEnv

// required .protocol.PayLoad payload = 1;
inline bool PayLoadEnv::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PayLoadEnv::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PayLoadEnv::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PayLoadEnv::clear_payload() {
  if (payload_ != NULL) payload_->::protocol::PayLoad::Clear();
  clear_has_payload();
}
inline const ::protocol::PayLoad& PayLoadEnv::payload() const {
  // @@protoc_insertion_point(field_get:protocol.PayLoadEnv.payload)
  return payload_ != NULL ? *payload_
                         : *::protocol::PayLoad::internal_default_instance();
}
inline ::protocol::PayLoad* PayLoadEnv::mutable_payload() {
  set_has_payload();
  if (payload_ == NULL) {
    payload_ = new ::protocol::PayLoad;
  }
  // @@protoc_insertion_point(field_mutable:protocol.PayLoadEnv.payload)
  return payload_;
}
inline ::protocol::PayLoad* PayLoadEnv::release_payload() {
  // @@protoc_insertion_point(field_release:protocol.PayLoadEnv.payload)
  clear_has_payload();
  ::protocol::PayLoad* temp = payload_;
  payload_ = NULL;
  return temp;
}
inline void PayLoadEnv::set_allocated_payload(::protocol::PayLoad* payload) {
  delete payload_;
  payload_ = payload;
  if (payload) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.PayLoadEnv.payload)
}

// required .protocol.Signature signature = 2;
inline bool PayLoadEnv::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PayLoadEnv::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PayLoadEnv::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PayLoadEnv::clear_signature() {
  if (signature_ != NULL) signature_->::protocol::Signature::Clear();
  clear_has_signature();
}
inline const ::protocol::Signature& PayLoadEnv::signature() const {
  // @@protoc_insertion_point(field_get:protocol.PayLoadEnv.signature)
  return signature_ != NULL ? *signature_
                         : *::protocol::Signature::internal_default_instance();
}
inline ::protocol::Signature* PayLoadEnv::mutable_signature() {
  set_has_signature();
  if (signature_ == NULL) {
    signature_ = new ::protocol::Signature;
  }
  // @@protoc_insertion_point(field_mutable:protocol.PayLoadEnv.signature)
  return signature_;
}
inline ::protocol::Signature* PayLoadEnv::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.PayLoadEnv.signature)
  clear_has_signature();
  ::protocol::Signature* temp = signature_;
  signature_ = NULL;
  return temp;
}
inline void PayLoadEnv::set_allocated_signature(::protocol::Signature* signature) {
  delete signature_;
  signature_ = signature;
  if (signature) {
    set_has_signature();
  } else {
    clear_has_signature();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.PayLoadEnv.signature)
}

// -------------------------------------------------------------------

// ChainHello

// repeated .protocol.ChainMessageType api_list = 1;
inline int ChainHello::api_list_size() const {
  return api_list_.size();
}
inline void ChainHello::clear_api_list() {
  api_list_.Clear();
}
inline ::protocol::ChainMessageType ChainHello::api_list(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ChainHello.api_list)
  return static_cast< ::protocol::ChainMessageType >(api_list_.Get(index));
}
inline void ChainHello::set_api_list(int index, ::protocol::ChainMessageType value) {
  assert(::protocol::ChainMessageType_IsValid(value));
  api_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.ChainHello.api_list)
}
inline void ChainHello::add_api_list(::protocol::ChainMessageType value) {
  assert(::protocol::ChainMessageType_IsValid(value));
  api_list_.Add(value);
  // @@protoc_insertion_point(field_add:protocol.ChainHello.api_list)
}
inline const ::google::protobuf::RepeatedField<int>&
ChainHello::api_list() const {
  // @@protoc_insertion_point(field_list:protocol.ChainHello.api_list)
  return api_list_;
}
inline ::google::protobuf::RepeatedField<int>*
ChainHello::mutable_api_list() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ChainHello.api_list)
  return &api_list_;
}

// required int64 timestamp = 2;
inline bool ChainHello::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChainHello::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChainHello::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChainHello::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ChainHello::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.ChainHello.timestamp)
  return timestamp_;
}
inline void ChainHello::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainHello.timestamp)
}

// -------------------------------------------------------------------

// ChainStatus

// required string self_addr = 1;
inline bool ChainStatus::has_self_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChainStatus::set_has_self_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChainStatus::clear_has_self_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChainStatus::clear_self_addr() {
  self_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_self_addr();
}
inline const ::std::string& ChainStatus::self_addr() const {
  // @@protoc_insertion_point(field_get:protocol.ChainStatus.self_addr)
  return self_addr_.GetNoArena();
}
inline void ChainStatus::set_self_addr(const ::std::string& value) {
  set_has_self_addr();
  self_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainStatus.self_addr)
}
#if LANG_CXX11
inline void ChainStatus::set_self_addr(::std::string&& value) {
  set_has_self_addr();
  self_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ChainStatus.self_addr)
}
#endif
inline void ChainStatus::set_self_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_self_addr();
  self_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainStatus.self_addr)
}
inline void ChainStatus::set_self_addr(const char* value, size_t size) {
  set_has_self_addr();
  self_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainStatus.self_addr)
}
inline ::std::string* ChainStatus::mutable_self_addr() {
  set_has_self_addr();
  // @@protoc_insertion_point(field_mutable:protocol.ChainStatus.self_addr)
  return self_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainStatus::release_self_addr() {
  // @@protoc_insertion_point(field_release:protocol.ChainStatus.self_addr)
  clear_has_self_addr();
  return self_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainStatus::set_allocated_self_addr(::std::string* self_addr) {
  if (self_addr != NULL) {
    set_has_self_addr();
  } else {
    clear_has_self_addr();
  }
  self_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), self_addr);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainStatus.self_addr)
}

// required uint32 ledger_version = 2;
inline bool ChainStatus::has_ledger_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChainStatus::set_has_ledger_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChainStatus::clear_has_ledger_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChainStatus::clear_ledger_version() {
  ledger_version_ = 0u;
  clear_has_ledger_version();
}
inline ::google::protobuf::uint32 ChainStatus::ledger_version() const {
  // @@protoc_insertion_point(field_get:protocol.ChainStatus.ledger_version)
  return ledger_version_;
}
inline void ChainStatus::set_ledger_version(::google::protobuf::uint32 value) {
  set_has_ledger_version();
  ledger_version_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainStatus.ledger_version)
}

// required string bubi_version = 3;
inline bool ChainStatus::has_bubi_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChainStatus::set_has_bubi_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChainStatus::clear_has_bubi_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChainStatus::clear_bubi_version() {
  bubi_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_bubi_version();
}
inline const ::std::string& ChainStatus::bubi_version() const {
  // @@protoc_insertion_point(field_get:protocol.ChainStatus.bubi_version)
  return bubi_version_.GetNoArena();
}
inline void ChainStatus::set_bubi_version(const ::std::string& value) {
  set_has_bubi_version();
  bubi_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainStatus.bubi_version)
}
#if LANG_CXX11
inline void ChainStatus::set_bubi_version(::std::string&& value) {
  set_has_bubi_version();
  bubi_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ChainStatus.bubi_version)
}
#endif
inline void ChainStatus::set_bubi_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_bubi_version();
  bubi_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainStatus.bubi_version)
}
inline void ChainStatus::set_bubi_version(const char* value, size_t size) {
  set_has_bubi_version();
  bubi_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainStatus.bubi_version)
}
inline ::std::string* ChainStatus::mutable_bubi_version() {
  set_has_bubi_version();
  // @@protoc_insertion_point(field_mutable:protocol.ChainStatus.bubi_version)
  return bubi_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainStatus::release_bubi_version() {
  // @@protoc_insertion_point(field_release:protocol.ChainStatus.bubi_version)
  clear_has_bubi_version();
  return bubi_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainStatus::set_allocated_bubi_version(::std::string* bubi_version) {
  if (bubi_version != NULL) {
    set_has_bubi_version();
  } else {
    clear_has_bubi_version();
  }
  bubi_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bubi_version);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainStatus.bubi_version)
}

// required int64 timestamp = 4;
inline bool ChainStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChainStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChainStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChainStatus::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ChainStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.ChainStatus.timestamp)
  return timestamp_;
}
inline void ChainStatus::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainStatus.timestamp)
}

// -------------------------------------------------------------------

// ChainPeerOnline

// required string peer_addr = 1;
inline bool ChainPeerOnline::has_peer_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChainPeerOnline::set_has_peer_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChainPeerOnline::clear_has_peer_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChainPeerOnline::clear_peer_addr() {
  peer_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_addr();
}
inline const ::std::string& ChainPeerOnline::peer_addr() const {
  // @@protoc_insertion_point(field_get:protocol.ChainPeerOnline.peer_addr)
  return peer_addr_.GetNoArena();
}
inline void ChainPeerOnline::set_peer_addr(const ::std::string& value) {
  set_has_peer_addr();
  peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainPeerOnline.peer_addr)
}
#if LANG_CXX11
inline void ChainPeerOnline::set_peer_addr(::std::string&& value) {
  set_has_peer_addr();
  peer_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ChainPeerOnline.peer_addr)
}
#endif
inline void ChainPeerOnline::set_peer_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_addr();
  peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainPeerOnline.peer_addr)
}
inline void ChainPeerOnline::set_peer_addr(const char* value, size_t size) {
  set_has_peer_addr();
  peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainPeerOnline.peer_addr)
}
inline ::std::string* ChainPeerOnline::mutable_peer_addr() {
  set_has_peer_addr();
  // @@protoc_insertion_point(field_mutable:protocol.ChainPeerOnline.peer_addr)
  return peer_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainPeerOnline::release_peer_addr() {
  // @@protoc_insertion_point(field_release:protocol.ChainPeerOnline.peer_addr)
  clear_has_peer_addr();
  return peer_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainPeerOnline::set_allocated_peer_addr(::std::string* peer_addr) {
  if (peer_addr != NULL) {
    set_has_peer_addr();
  } else {
    clear_has_peer_addr();
  }
  peer_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_addr);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainPeerOnline.peer_addr)
}

// required string peer_ip = 2;
inline bool ChainPeerOnline::has_peer_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChainPeerOnline::set_has_peer_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChainPeerOnline::clear_has_peer_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChainPeerOnline::clear_peer_ip() {
  peer_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_ip();
}
inline const ::std::string& ChainPeerOnline::peer_ip() const {
  // @@protoc_insertion_point(field_get:protocol.ChainPeerOnline.peer_ip)
  return peer_ip_.GetNoArena();
}
inline void ChainPeerOnline::set_peer_ip(const ::std::string& value) {
  set_has_peer_ip();
  peer_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainPeerOnline.peer_ip)
}
#if LANG_CXX11
inline void ChainPeerOnline::set_peer_ip(::std::string&& value) {
  set_has_peer_ip();
  peer_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ChainPeerOnline.peer_ip)
}
#endif
inline void ChainPeerOnline::set_peer_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_ip();
  peer_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainPeerOnline.peer_ip)
}
inline void ChainPeerOnline::set_peer_ip(const char* value, size_t size) {
  set_has_peer_ip();
  peer_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainPeerOnline.peer_ip)
}
inline ::std::string* ChainPeerOnline::mutable_peer_ip() {
  set_has_peer_ip();
  // @@protoc_insertion_point(field_mutable:protocol.ChainPeerOnline.peer_ip)
  return peer_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainPeerOnline::release_peer_ip() {
  // @@protoc_insertion_point(field_release:protocol.ChainPeerOnline.peer_ip)
  clear_has_peer_ip();
  return peer_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainPeerOnline::set_allocated_peer_ip(::std::string* peer_ip) {
  if (peer_ip != NULL) {
    set_has_peer_ip();
  } else {
    clear_has_peer_ip();
  }
  peer_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_ip);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainPeerOnline.peer_ip)
}

// required int32 peer_port = 3;
inline bool ChainPeerOnline::has_peer_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChainPeerOnline::set_has_peer_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChainPeerOnline::clear_has_peer_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChainPeerOnline::clear_peer_port() {
  peer_port_ = 0;
  clear_has_peer_port();
}
inline ::google::protobuf::int32 ChainPeerOnline::peer_port() const {
  // @@protoc_insertion_point(field_get:protocol.ChainPeerOnline.peer_port)
  return peer_port_;
}
inline void ChainPeerOnline::set_peer_port(::google::protobuf::int32 value) {
  set_has_peer_port();
  peer_port_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainPeerOnline.peer_port)
}

// required int64 timestamp = 4;
inline bool ChainPeerOnline::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChainPeerOnline::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChainPeerOnline::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChainPeerOnline::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ChainPeerOnline::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.ChainPeerOnline.timestamp)
  return timestamp_;
}
inline void ChainPeerOnline::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainPeerOnline.timestamp)
}

// -------------------------------------------------------------------

// ChainPeerOffline

// required string peer_addr = 1;
inline bool ChainPeerOffline::has_peer_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChainPeerOffline::set_has_peer_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChainPeerOffline::clear_has_peer_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChainPeerOffline::clear_peer_addr() {
  peer_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_peer_addr();
}
inline const ::std::string& ChainPeerOffline::peer_addr() const {
  // @@protoc_insertion_point(field_get:protocol.ChainPeerOffline.peer_addr)
  return peer_addr_.GetNoArena();
}
inline void ChainPeerOffline::set_peer_addr(const ::std::string& value) {
  set_has_peer_addr();
  peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainPeerOffline.peer_addr)
}
#if LANG_CXX11
inline void ChainPeerOffline::set_peer_addr(::std::string&& value) {
  set_has_peer_addr();
  peer_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ChainPeerOffline.peer_addr)
}
#endif
inline void ChainPeerOffline::set_peer_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_peer_addr();
  peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainPeerOffline.peer_addr)
}
inline void ChainPeerOffline::set_peer_addr(const char* value, size_t size) {
  set_has_peer_addr();
  peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainPeerOffline.peer_addr)
}
inline ::std::string* ChainPeerOffline::mutable_peer_addr() {
  set_has_peer_addr();
  // @@protoc_insertion_point(field_mutable:protocol.ChainPeerOffline.peer_addr)
  return peer_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainPeerOffline::release_peer_addr() {
  // @@protoc_insertion_point(field_release:protocol.ChainPeerOffline.peer_addr)
  clear_has_peer_addr();
  return peer_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainPeerOffline::set_allocated_peer_addr(::std::string* peer_addr) {
  if (peer_addr != NULL) {
    set_has_peer_addr();
  } else {
    clear_has_peer_addr();
  }
  peer_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), peer_addr);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainPeerOffline.peer_addr)
}

// required int64 timestamp = 2;
inline bool ChainPeerOffline::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChainPeerOffline::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChainPeerOffline::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChainPeerOffline::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ChainPeerOffline::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.ChainPeerOffline.timestamp)
  return timestamp_;
}
inline void ChainPeerOffline::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainPeerOffline.timestamp)
}

// -------------------------------------------------------------------

// ChainPeerMessage

// required string src_peer_addr = 1;
inline bool ChainPeerMessage::has_src_peer_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChainPeerMessage::set_has_src_peer_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChainPeerMessage::clear_has_src_peer_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChainPeerMessage::clear_src_peer_addr() {
  src_peer_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_peer_addr();
}
inline const ::std::string& ChainPeerMessage::src_peer_addr() const {
  // @@protoc_insertion_point(field_get:protocol.ChainPeerMessage.src_peer_addr)
  return src_peer_addr_.GetNoArena();
}
inline void ChainPeerMessage::set_src_peer_addr(const ::std::string& value) {
  set_has_src_peer_addr();
  src_peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainPeerMessage.src_peer_addr)
}
#if LANG_CXX11
inline void ChainPeerMessage::set_src_peer_addr(::std::string&& value) {
  set_has_src_peer_addr();
  src_peer_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ChainPeerMessage.src_peer_addr)
}
#endif
inline void ChainPeerMessage::set_src_peer_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src_peer_addr();
  src_peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainPeerMessage.src_peer_addr)
}
inline void ChainPeerMessage::set_src_peer_addr(const char* value, size_t size) {
  set_has_src_peer_addr();
  src_peer_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainPeerMessage.src_peer_addr)
}
inline ::std::string* ChainPeerMessage::mutable_src_peer_addr() {
  set_has_src_peer_addr();
  // @@protoc_insertion_point(field_mutable:protocol.ChainPeerMessage.src_peer_addr)
  return src_peer_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainPeerMessage::release_src_peer_addr() {
  // @@protoc_insertion_point(field_release:protocol.ChainPeerMessage.src_peer_addr)
  clear_has_src_peer_addr();
  return src_peer_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainPeerMessage::set_allocated_src_peer_addr(::std::string* src_peer_addr) {
  if (src_peer_addr != NULL) {
    set_has_src_peer_addr();
  } else {
    clear_has_src_peer_addr();
  }
  src_peer_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_peer_addr);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainPeerMessage.src_peer_addr)
}

// repeated string des_peer_addrs = 2;
inline int ChainPeerMessage::des_peer_addrs_size() const {
  return des_peer_addrs_.size();
}
inline void ChainPeerMessage::clear_des_peer_addrs() {
  des_peer_addrs_.Clear();
}
inline const ::std::string& ChainPeerMessage::des_peer_addrs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ChainPeerMessage.des_peer_addrs)
  return des_peer_addrs_.Get(index);
}
inline ::std::string* ChainPeerMessage::mutable_des_peer_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ChainPeerMessage.des_peer_addrs)
  return des_peer_addrs_.Mutable(index);
}
inline void ChainPeerMessage::set_des_peer_addrs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.ChainPeerMessage.des_peer_addrs)
  des_peer_addrs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ChainPeerMessage::set_des_peer_addrs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.ChainPeerMessage.des_peer_addrs)
  des_peer_addrs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ChainPeerMessage::set_des_peer_addrs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  des_peer_addrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.ChainPeerMessage.des_peer_addrs)
}
inline void ChainPeerMessage::set_des_peer_addrs(int index, const char* value, size_t size) {
  des_peer_addrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainPeerMessage.des_peer_addrs)
}
inline ::std::string* ChainPeerMessage::add_des_peer_addrs() {
  // @@protoc_insertion_point(field_add_mutable:protocol.ChainPeerMessage.des_peer_addrs)
  return des_peer_addrs_.Add();
}
inline void ChainPeerMessage::add_des_peer_addrs(const ::std::string& value) {
  des_peer_addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.ChainPeerMessage.des_peer_addrs)
}
#if LANG_CXX11
inline void ChainPeerMessage::add_des_peer_addrs(::std::string&& value) {
  des_peer_addrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.ChainPeerMessage.des_peer_addrs)
}
#endif
inline void ChainPeerMessage::add_des_peer_addrs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  des_peer_addrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.ChainPeerMessage.des_peer_addrs)
}
inline void ChainPeerMessage::add_des_peer_addrs(const char* value, size_t size) {
  des_peer_addrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.ChainPeerMessage.des_peer_addrs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ChainPeerMessage::des_peer_addrs() const {
  // @@protoc_insertion_point(field_list:protocol.ChainPeerMessage.des_peer_addrs)
  return des_peer_addrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ChainPeerMessage::mutable_des_peer_addrs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ChainPeerMessage.des_peer_addrs)
  return &des_peer_addrs_;
}

// required bytes data = 3;
inline bool ChainPeerMessage::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChainPeerMessage::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChainPeerMessage::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChainPeerMessage::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& ChainPeerMessage::data() const {
  // @@protoc_insertion_point(field_get:protocol.ChainPeerMessage.data)
  return data_.GetNoArena();
}
inline void ChainPeerMessage::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainPeerMessage.data)
}
#if LANG_CXX11
inline void ChainPeerMessage::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ChainPeerMessage.data)
}
#endif
inline void ChainPeerMessage::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainPeerMessage.data)
}
inline void ChainPeerMessage::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainPeerMessage.data)
}
inline ::std::string* ChainPeerMessage::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:protocol.ChainPeerMessage.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainPeerMessage::release_data() {
  // @@protoc_insertion_point(field_release:protocol.ChainPeerMessage.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainPeerMessage::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainPeerMessage.data)
}

// -------------------------------------------------------------------

// ChainTxStatus

// required .protocol.ChainTxStatus.TxStatus status = 1;
inline bool ChainTxStatus::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChainTxStatus::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChainTxStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChainTxStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::protocol::ChainTxStatus_TxStatus ChainTxStatus::status() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.status)
  return static_cast< ::protocol::ChainTxStatus_TxStatus >(status_);
}
inline void ChainTxStatus::set_status(::protocol::ChainTxStatus_TxStatus value) {
  assert(::protocol::ChainTxStatus_TxStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.status)
}

// required string tx_hash = 2;
inline bool ChainTxStatus::has_tx_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChainTxStatus::set_has_tx_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChainTxStatus::clear_has_tx_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChainTxStatus::clear_tx_hash() {
  tx_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tx_hash();
}
inline const ::std::string& ChainTxStatus::tx_hash() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.tx_hash)
  return tx_hash_.GetNoArena();
}
inline void ChainTxStatus::set_tx_hash(const ::std::string& value) {
  set_has_tx_hash();
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.tx_hash)
}
#if LANG_CXX11
inline void ChainTxStatus::set_tx_hash(::std::string&& value) {
  set_has_tx_hash();
  tx_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ChainTxStatus.tx_hash)
}
#endif
inline void ChainTxStatus::set_tx_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tx_hash();
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainTxStatus.tx_hash)
}
inline void ChainTxStatus::set_tx_hash(const char* value, size_t size) {
  set_has_tx_hash();
  tx_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainTxStatus.tx_hash)
}
inline ::std::string* ChainTxStatus::mutable_tx_hash() {
  set_has_tx_hash();
  // @@protoc_insertion_point(field_mutable:protocol.ChainTxStatus.tx_hash)
  return tx_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainTxStatus::release_tx_hash() {
  // @@protoc_insertion_point(field_release:protocol.ChainTxStatus.tx_hash)
  clear_has_tx_hash();
  return tx_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainTxStatus::set_allocated_tx_hash(::std::string* tx_hash) {
  if (tx_hash != NULL) {
    set_has_tx_hash();
  } else {
    clear_has_tx_hash();
  }
  tx_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_hash);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainTxStatus.tx_hash)
}

// required string source_address = 3;
inline bool ChainTxStatus::has_source_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChainTxStatus::set_has_source_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChainTxStatus::clear_has_source_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChainTxStatus::clear_source_address() {
  source_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source_address();
}
inline const ::std::string& ChainTxStatus::source_address() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.source_address)
  return source_address_.GetNoArena();
}
inline void ChainTxStatus::set_source_address(const ::std::string& value) {
  set_has_source_address();
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.source_address)
}
#if LANG_CXX11
inline void ChainTxStatus::set_source_address(::std::string&& value) {
  set_has_source_address();
  source_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ChainTxStatus.source_address)
}
#endif
inline void ChainTxStatus::set_source_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source_address();
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainTxStatus.source_address)
}
inline void ChainTxStatus::set_source_address(const char* value, size_t size) {
  set_has_source_address();
  source_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainTxStatus.source_address)
}
inline ::std::string* ChainTxStatus::mutable_source_address() {
  set_has_source_address();
  // @@protoc_insertion_point(field_mutable:protocol.ChainTxStatus.source_address)
  return source_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainTxStatus::release_source_address() {
  // @@protoc_insertion_point(field_release:protocol.ChainTxStatus.source_address)
  clear_has_source_address();
  return source_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainTxStatus::set_allocated_source_address(::std::string* source_address) {
  if (source_address != NULL) {
    set_has_source_address();
  } else {
    clear_has_source_address();
  }
  source_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_address);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainTxStatus.source_address)
}

// optional int64 source_account_seq = 4;
inline bool ChainTxStatus::has_source_account_seq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChainTxStatus::set_has_source_account_seq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChainTxStatus::clear_has_source_account_seq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChainTxStatus::clear_source_account_seq() {
  source_account_seq_ = GOOGLE_LONGLONG(0);
  clear_has_source_account_seq();
}
inline ::google::protobuf::int64 ChainTxStatus::source_account_seq() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.source_account_seq)
  return source_account_seq_;
}
inline void ChainTxStatus::set_source_account_seq(::google::protobuf::int64 value) {
  set_has_source_account_seq();
  source_account_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.source_account_seq)
}

// optional int64 ledger_seq = 5;
inline bool ChainTxStatus::has_ledger_seq() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChainTxStatus::set_has_ledger_seq() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChainTxStatus::clear_has_ledger_seq() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChainTxStatus::clear_ledger_seq() {
  ledger_seq_ = GOOGLE_LONGLONG(0);
  clear_has_ledger_seq();
}
inline ::google::protobuf::int64 ChainTxStatus::ledger_seq() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.ledger_seq)
  return ledger_seq_;
}
inline void ChainTxStatus::set_ledger_seq(::google::protobuf::int64 value) {
  set_has_ledger_seq();
  ledger_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.ledger_seq)
}

// optional int64 new_account_seq = 6;
inline bool ChainTxStatus::has_new_account_seq() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChainTxStatus::set_has_new_account_seq() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChainTxStatus::clear_has_new_account_seq() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChainTxStatus::clear_new_account_seq() {
  new_account_seq_ = GOOGLE_LONGLONG(0);
  clear_has_new_account_seq();
}
inline ::google::protobuf::int64 ChainTxStatus::new_account_seq() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.new_account_seq)
  return new_account_seq_;
}
inline void ChainTxStatus::set_new_account_seq(::google::protobuf::int64 value) {
  set_has_new_account_seq();
  new_account_seq_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.new_account_seq)
}

// optional .protocol.ERRORCODE error_code = 7;
inline bool ChainTxStatus::has_error_code() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChainTxStatus::set_has_error_code() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChainTxStatus::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChainTxStatus::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::protocol::ERRORCODE ChainTxStatus::error_code() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.error_code)
  return static_cast< ::protocol::ERRORCODE >(error_code_);
}
inline void ChainTxStatus::set_error_code(::protocol::ERRORCODE value) {
  assert(::protocol::ERRORCODE_IsValid(value));
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.error_code)
}

// optional string error_desc = 8;
inline bool ChainTxStatus::has_error_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChainTxStatus::set_has_error_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChainTxStatus::clear_has_error_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChainTxStatus::clear_error_desc() {
  error_desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_desc();
}
inline const ::std::string& ChainTxStatus::error_desc() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.error_desc)
  return error_desc_.GetNoArena();
}
inline void ChainTxStatus::set_error_desc(const ::std::string& value) {
  set_has_error_desc();
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.error_desc)
}
#if LANG_CXX11
inline void ChainTxStatus::set_error_desc(::std::string&& value) {
  set_has_error_desc();
  error_desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ChainTxStatus.error_desc)
}
#endif
inline void ChainTxStatus::set_error_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_desc();
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ChainTxStatus.error_desc)
}
inline void ChainTxStatus::set_error_desc(const char* value, size_t size) {
  set_has_error_desc();
  error_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ChainTxStatus.error_desc)
}
inline ::std::string* ChainTxStatus::mutable_error_desc() {
  set_has_error_desc();
  // @@protoc_insertion_point(field_mutable:protocol.ChainTxStatus.error_desc)
  return error_desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChainTxStatus::release_error_desc() {
  // @@protoc_insertion_point(field_release:protocol.ChainTxStatus.error_desc)
  clear_has_error_desc();
  return error_desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChainTxStatus::set_allocated_error_desc(::std::string* error_desc) {
  if (error_desc != NULL) {
    set_has_error_desc();
  } else {
    clear_has_error_desc();
  }
  error_desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_desc);
  // @@protoc_insertion_point(field_set_allocated:protocol.ChainTxStatus.error_desc)
}

// required int64 timestamp = 9;
inline bool ChainTxStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ChainTxStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ChainTxStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ChainTxStatus::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ChainTxStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.ChainTxStatus.timestamp)
  return timestamp_;
}
inline void ChainTxStatus::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.ChainTxStatus.timestamp)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace protocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protocol::Account_Limit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Account_Limit>() {
  return ::protocol::Account_Limit_descriptor();
}
template <> struct is_proto_enum< ::protocol::Ledgers_SyncCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Ledgers_SyncCode>() {
  return ::protocol::Ledgers_SyncCode_descriptor();
}
template <> struct is_proto_enum< ::protocol::AssetProperty_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::AssetProperty_Type>() {
  return ::protocol::AssetProperty_Type_descriptor();
}
template <> struct is_proto_enum< ::protocol::Operation_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Operation_Type>() {
  return ::protocol::Operation_Type_descriptor();
}
template <> struct is_proto_enum< ::protocol::Transaction_Limit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Transaction_Limit>() {
  return ::protocol::Transaction_Limit_descriptor();
}
template <> struct is_proto_enum< ::protocol::TransactionEnv_Limit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TransactionEnv_Limit>() {
  return ::protocol::TransactionEnv_Limit_descriptor();
}
template <> struct is_proto_enum< ::protocol::ChainTxStatus_TxStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ChainTxStatus_TxStatus>() {
  return ::protocol::ChainTxStatus_TxStatus_descriptor();
}
template <> struct is_proto_enum< ::protocol::PbftMessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::PbftMessageType>() {
  return ::protocol::PbftMessageType_descriptor();
}
template <> struct is_proto_enum< ::protocol::PbftValueType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::PbftValueType>() {
  return ::protocol::PbftValueType_descriptor();
}
template <> struct is_proto_enum< ::protocol::ChainMessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ChainMessageType>() {
  return ::protocol::ChainMessageType_descriptor();
}
template <> struct is_proto_enum< ::protocol::ERRORCODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ERRORCODE>() {
  return ::protocol::ERRORCODE_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
