/*
Copyright Â© Bubi Technologies Co., Ltd. 2017 All Rights Reserved.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
		 http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: test.proto

#ifndef PROTOBUF_test_2eproto__INCLUDED
#define PROTOBUF_test_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_test_2eproto();
void protobuf_AssignDesc_test_2eproto();
void protobuf_ShutdownFile_test_2eproto();

class Lock;
class Unlock;
class OperationLockUnLock;

enum OperationLockUnLock_Action {
  OperationLockUnLock_Action_LOCK = 0,
  OperationLockUnLock_Action_UNLOCK = 1
};
bool OperationLockUnLock_Action_IsValid(int value);
const OperationLockUnLock_Action OperationLockUnLock_Action_Action_MIN = OperationLockUnLock_Action_LOCK;
const OperationLockUnLock_Action OperationLockUnLock_Action_Action_MAX = OperationLockUnLock_Action_UNLOCK;
const int OperationLockUnLock_Action_Action_ARRAYSIZE = OperationLockUnLock_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* OperationLockUnLock_Action_descriptor();
inline const ::std::string& OperationLockUnLock_Action_Name(OperationLockUnLock_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    OperationLockUnLock_Action_descriptor(), value);
}
inline bool OperationLockUnLock_Action_Parse(
    const ::std::string& name, OperationLockUnLock_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OperationLockUnLock_Action>(
    OperationLockUnLock_Action_descriptor(), name, value);
}
// ===================================================================

class Lock : public ::google::protobuf::Message {
 public:
  Lock();
  virtual ~Lock();

  Lock(const Lock& from);

  inline Lock& operator=(const Lock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lock& default_instance();

  void Swap(Lock* other);

  // implements Message ----------------------------------------------

  inline Lock* New() const { return New(NULL); }

  Lock* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Lock& from);
  void MergeFrom(const Lock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Lock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string depositary = 1;
  inline bool has_depositary() const;
  inline void clear_depositary();
  static const int kDepositaryFieldNumber = 1;
  inline const ::std::string& depositary() const;
  inline void set_depositary(const ::std::string& value);
  inline void set_depositary(const char* value);
  inline void set_depositary(const char* value, size_t size);
  inline ::std::string* mutable_depositary();
  inline ::std::string* release_depositary();
  inline void set_allocated_depositary(::std::string* depositary);

  // required int64 starttime = 2;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 2;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // required int64 endtime = 3;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 3;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Lock)
 private:
  inline void set_has_depositary();
  inline void clear_has_depositary();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr depositary_;
  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 endtime_;
  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static Lock* default_instance_;
};
// -------------------------------------------------------------------

class Unlock : public ::google::protobuf::Message {
 public:
  Unlock();
  virtual ~Unlock();

  Unlock(const Unlock& from);

  inline Unlock& operator=(const Unlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Unlock& default_instance();

  void Swap(Unlock* other);

  // implements Message ----------------------------------------------

  inline Unlock* New() const { return New(NULL); }

  Unlock* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Unlock& from);
  void MergeFrom(const Unlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Unlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string depositary = 1;
  inline bool has_depositary() const;
  inline void clear_depositary();
  static const int kDepositaryFieldNumber = 1;
  inline const ::std::string& depositary() const;
  inline void set_depositary(const ::std::string& value);
  inline void set_depositary(const char* value);
  inline void set_depositary(const char* value, size_t size);
  inline ::std::string* mutable_depositary();
  inline ::std::string* release_depositary();
  inline void set_allocated_depositary(::std::string* depositary);

  // @@protoc_insertion_point(class_scope:Unlock)
 private:
  inline void set_has_depositary();
  inline void clear_has_depositary();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr depositary_;
  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static Unlock* default_instance_;
};
// -------------------------------------------------------------------

class OperationLockUnLock : public ::google::protobuf::Message {
 public:
  OperationLockUnLock();
  virtual ~OperationLockUnLock();

  OperationLockUnLock(const OperationLockUnLock& from);

  inline OperationLockUnLock& operator=(const OperationLockUnLock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OperationLockUnLock& default_instance();

  void Swap(OperationLockUnLock* other);

  // implements Message ----------------------------------------------

  inline OperationLockUnLock* New() const { return New(NULL); }

  OperationLockUnLock* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OperationLockUnLock& from);
  void MergeFrom(const OperationLockUnLock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperationLockUnLock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef OperationLockUnLock_Action Action;
  static const Action LOCK = OperationLockUnLock_Action_LOCK;
  static const Action UNLOCK = OperationLockUnLock_Action_UNLOCK;
  static inline bool Action_IsValid(int value) {
    return OperationLockUnLock_Action_IsValid(value);
  }
  static const Action Action_MIN =
    OperationLockUnLock_Action_Action_MIN;
  static const Action Action_MAX =
    OperationLockUnLock_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    OperationLockUnLock_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return OperationLockUnLock_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return OperationLockUnLock_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return OperationLockUnLock_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string destAddress = 1;
  inline bool has_destaddress() const;
  inline void clear_destaddress();
  static const int kDestAddressFieldNumber = 1;
  inline const ::std::string& destaddress() const;
  inline void set_destaddress(const ::std::string& value);
  inline void set_destaddress(const char* value);
  inline void set_destaddress(const char* value, size_t size);
  inline ::std::string* mutable_destaddress();
  inline ::std::string* release_destaddress();
  inline void set_allocated_destaddress(::std::string* destaddress);

  // optional .Lock lock = 2;
  inline bool has_lock() const;
  inline void clear_lock();
  static const int kLockFieldNumber = 2;
  inline const ::Lock& lock() const;
  inline ::Lock* mutable_lock();
  inline ::Lock* release_lock();
  inline void set_allocated_lock(::Lock* lock);

  // optional .Unlock unlock = 3;
  inline bool has_unlock() const;
  inline void clear_unlock();
  static const int kUnlockFieldNumber = 3;
  inline const ::Unlock& unlock() const;
  inline ::Unlock* mutable_unlock();
  inline ::Unlock* release_unlock();
  inline void set_allocated_unlock(::Unlock* unlock);

  // @@protoc_insertion_point(class_scope:OperationLockUnLock)
 private:
  inline void set_has_destaddress();
  inline void clear_has_destaddress();
  inline void set_has_lock();
  inline void clear_has_lock();
  inline void set_has_unlock();
  inline void clear_has_unlock();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr destaddress_;
  ::Lock* lock_;
  ::Unlock* unlock_;
  friend void  protobuf_AddDesc_test_2eproto();
  friend void protobuf_AssignDesc_test_2eproto();
  friend void protobuf_ShutdownFile_test_2eproto();

  void InitAsDefaultInstance();
  static OperationLockUnLock* default_instance_;
};
// ===================================================================


// ===================================================================

// Lock

// required string depositary = 1;
inline bool Lock::has_depositary() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Lock::set_has_depositary() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Lock::clear_has_depositary() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Lock::clear_depositary() {
  depositary_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_depositary();
}
inline const ::std::string& Lock::depositary() const {
  // @@protoc_insertion_point(field_get:Lock.depositary)
  return depositary_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Lock::set_depositary(const ::std::string& value) {
  set_has_depositary();
  depositary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Lock.depositary)
}
inline void Lock::set_depositary(const char* value) {
  set_has_depositary();
  depositary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Lock.depositary)
}
inline void Lock::set_depositary(const char* value, size_t size) {
  set_has_depositary();
  depositary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Lock.depositary)
}
inline ::std::string* Lock::mutable_depositary() {
  set_has_depositary();
  // @@protoc_insertion_point(field_mutable:Lock.depositary)
  return depositary_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Lock::release_depositary() {
  clear_has_depositary();
  return depositary_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Lock::set_allocated_depositary(::std::string* depositary) {
  if (depositary != NULL) {
    set_has_depositary();
  } else {
    clear_has_depositary();
  }
  depositary_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), depositary);
  // @@protoc_insertion_point(field_set_allocated:Lock.depositary)
}

// required int64 starttime = 2;
inline bool Lock::has_starttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Lock::set_has_starttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Lock::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Lock::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 Lock::starttime() const {
  // @@protoc_insertion_point(field_get:Lock.starttime)
  return starttime_;
}
inline void Lock::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
  // @@protoc_insertion_point(field_set:Lock.starttime)
}

// required int64 endtime = 3;
inline bool Lock::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Lock::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Lock::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Lock::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 Lock::endtime() const {
  // @@protoc_insertion_point(field_get:Lock.endtime)
  return endtime_;
}
inline void Lock::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
  // @@protoc_insertion_point(field_set:Lock.endtime)
}

// -------------------------------------------------------------------

// Unlock

// required string depositary = 1;
inline bool Unlock::has_depositary() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Unlock::set_has_depositary() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Unlock::clear_has_depositary() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Unlock::clear_depositary() {
  depositary_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_depositary();
}
inline const ::std::string& Unlock::depositary() const {
  // @@protoc_insertion_point(field_get:Unlock.depositary)
  return depositary_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Unlock::set_depositary(const ::std::string& value) {
  set_has_depositary();
  depositary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Unlock.depositary)
}
inline void Unlock::set_depositary(const char* value) {
  set_has_depositary();
  depositary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Unlock.depositary)
}
inline void Unlock::set_depositary(const char* value, size_t size) {
  set_has_depositary();
  depositary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Unlock.depositary)
}
inline ::std::string* Unlock::mutable_depositary() {
  set_has_depositary();
  // @@protoc_insertion_point(field_mutable:Unlock.depositary)
  return depositary_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Unlock::release_depositary() {
  clear_has_depositary();
  return depositary_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Unlock::set_allocated_depositary(::std::string* depositary) {
  if (depositary != NULL) {
    set_has_depositary();
  } else {
    clear_has_depositary();
  }
  depositary_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), depositary);
  // @@protoc_insertion_point(field_set_allocated:Unlock.depositary)
}

// -------------------------------------------------------------------

// OperationLockUnLock

// required string destAddress = 1;
inline bool OperationLockUnLock::has_destaddress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperationLockUnLock::set_has_destaddress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperationLockUnLock::clear_has_destaddress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperationLockUnLock::clear_destaddress() {
  destaddress_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destaddress();
}
inline const ::std::string& OperationLockUnLock::destaddress() const {
  // @@protoc_insertion_point(field_get:OperationLockUnLock.destAddress)
  return destaddress_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationLockUnLock::set_destaddress(const ::std::string& value) {
  set_has_destaddress();
  destaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OperationLockUnLock.destAddress)
}
inline void OperationLockUnLock::set_destaddress(const char* value) {
  set_has_destaddress();
  destaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OperationLockUnLock.destAddress)
}
inline void OperationLockUnLock::set_destaddress(const char* value, size_t size) {
  set_has_destaddress();
  destaddress_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OperationLockUnLock.destAddress)
}
inline ::std::string* OperationLockUnLock::mutable_destaddress() {
  set_has_destaddress();
  // @@protoc_insertion_point(field_mutable:OperationLockUnLock.destAddress)
  return destaddress_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperationLockUnLock::release_destaddress() {
  clear_has_destaddress();
  return destaddress_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperationLockUnLock::set_allocated_destaddress(::std::string* destaddress) {
  if (destaddress != NULL) {
    set_has_destaddress();
  } else {
    clear_has_destaddress();
  }
  destaddress_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destaddress);
  // @@protoc_insertion_point(field_set_allocated:OperationLockUnLock.destAddress)
}

// optional .Lock lock = 2;
inline bool OperationLockUnLock::has_lock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperationLockUnLock::set_has_lock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperationLockUnLock::clear_has_lock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperationLockUnLock::clear_lock() {
  if (lock_ != NULL) lock_->::Lock::Clear();
  clear_has_lock();
}
inline const ::Lock& OperationLockUnLock::lock() const {
  // @@protoc_insertion_point(field_get:OperationLockUnLock.lock)
  return lock_ != NULL ? *lock_ : *default_instance_->lock_;
}
inline ::Lock* OperationLockUnLock::mutable_lock() {
  set_has_lock();
  if (lock_ == NULL) {
    lock_ = new ::Lock;
  }
  // @@protoc_insertion_point(field_mutable:OperationLockUnLock.lock)
  return lock_;
}
inline ::Lock* OperationLockUnLock::release_lock() {
  clear_has_lock();
  ::Lock* temp = lock_;
  lock_ = NULL;
  return temp;
}
inline void OperationLockUnLock::set_allocated_lock(::Lock* lock) {
  delete lock_;
  lock_ = lock;
  if (lock) {
    set_has_lock();
  } else {
    clear_has_lock();
  }
  // @@protoc_insertion_point(field_set_allocated:OperationLockUnLock.lock)
}

// optional .Unlock unlock = 3;
inline bool OperationLockUnLock::has_unlock() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperationLockUnLock::set_has_unlock() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperationLockUnLock::clear_has_unlock() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperationLockUnLock::clear_unlock() {
  if (unlock_ != NULL) unlock_->::Unlock::Clear();
  clear_has_unlock();
}
inline const ::Unlock& OperationLockUnLock::unlock() const {
  // @@protoc_insertion_point(field_get:OperationLockUnLock.unlock)
  return unlock_ != NULL ? *unlock_ : *default_instance_->unlock_;
}
inline ::Unlock* OperationLockUnLock::mutable_unlock() {
  set_has_unlock();
  if (unlock_ == NULL) {
    unlock_ = new ::Unlock;
  }
  // @@protoc_insertion_point(field_mutable:OperationLockUnLock.unlock)
  return unlock_;
}
inline ::Unlock* OperationLockUnLock::release_unlock() {
  clear_has_unlock();
  ::Unlock* temp = unlock_;
  unlock_ = NULL;
  return temp;
}
inline void OperationLockUnLock::set_allocated_unlock(::Unlock* unlock) {
  delete unlock_;
  unlock_ = unlock;
  if (unlock) {
    set_has_unlock();
  } else {
    clear_has_unlock();
  }
  // @@protoc_insertion_point(field_set_allocated:OperationLockUnLock.unlock)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::OperationLockUnLock_Action> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OperationLockUnLock_Action>() {
  return ::OperationLockUnLock_Action_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_test_2eproto__INCLUDED
